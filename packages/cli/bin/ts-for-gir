#!/usr/bin/env node
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// ../../.yarn/cache/lodash-npm-4.17.21-6382451519-c08619c038.zip/node_modules/lodash/lodash.js
var require_lodash = __commonJS({
  "../../.yarn/cache/lodash-npm-4.17.21-6382451519-c08619c038.zip/node_modules/lodash/lodash.js"(exports2, module) {
    (function() {
      var undefined2;
      var VERSION = "4.17.21";
      var LARGE_ARRAY_SIZE = 200;
      var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var MAX_MEMOIZE_SIZE = 500;
      var PLACEHOLDER = "__lodash_placeholder__";
      var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
      var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
      var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
      var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
      var HOT_COUNT = 800, HOT_SPAN = 16;
      var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
      var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
      var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
      var wrapFlags = [
        ["ary", WRAP_ARY_FLAG],
        ["bind", WRAP_BIND_FLAG],
        ["bindKey", WRAP_BIND_KEY_FLAG],
        ["curry", WRAP_CURRY_FLAG],
        ["curryRight", WRAP_CURRY_RIGHT_FLAG],
        ["flip", WRAP_FLIP_FLAG],
        ["partial", WRAP_PARTIAL_FLAG],
        ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
        ["rearg", WRAP_REARG_FLAG]
      ];
      var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
      var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
      var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
      var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
      var reTrimStart = /^\s+/;
      var reWhitespace = /\s/;
      var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
      var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
      var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
      var reEscapeChar = /\\(\\)?/g;
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
      var reFlags = /\w*$/;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var reIsOctal = /^0o[0-7]+$/i;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
      var reNoMatch = /($^)/;
      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
      var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
      var rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
      var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
      var reApos = RegExp(rsApos, "g");
      var reComboMark = RegExp(rsCombo, "g");
      var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
      var reUnicodeWord = RegExp([
        rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
        rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
        rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
        rsUpper + "+" + rsOptContrUpper,
        rsOrdUpper,
        rsOrdLower,
        rsDigits,
        rsEmoji
      ].join("|"), "g");
      var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
      var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
      var contextProps = [
        "Array",
        "Buffer",
        "DataView",
        "Date",
        "Error",
        "Float32Array",
        "Float64Array",
        "Function",
        "Int8Array",
        "Int16Array",
        "Int32Array",
        "Map",
        "Math",
        "Object",
        "Promise",
        "RegExp",
        "Set",
        "String",
        "Symbol",
        "TypeError",
        "Uint8Array",
        "Uint8ClampedArray",
        "Uint16Array",
        "Uint32Array",
        "WeakMap",
        "_",
        "clearTimeout",
        "isFinite",
        "parseInt",
        "setTimeout"
      ];
      var templateCounter = -1;
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
      var deburredLetters = {
        // Latin-1 Supplement block.
        "\xC0": "A",
        "\xC1": "A",
        "\xC2": "A",
        "\xC3": "A",
        "\xC4": "A",
        "\xC5": "A",
        "\xE0": "a",
        "\xE1": "a",
        "\xE2": "a",
        "\xE3": "a",
        "\xE4": "a",
        "\xE5": "a",
        "\xC7": "C",
        "\xE7": "c",
        "\xD0": "D",
        "\xF0": "d",
        "\xC8": "E",
        "\xC9": "E",
        "\xCA": "E",
        "\xCB": "E",
        "\xE8": "e",
        "\xE9": "e",
        "\xEA": "e",
        "\xEB": "e",
        "\xCC": "I",
        "\xCD": "I",
        "\xCE": "I",
        "\xCF": "I",
        "\xEC": "i",
        "\xED": "i",
        "\xEE": "i",
        "\xEF": "i",
        "\xD1": "N",
        "\xF1": "n",
        "\xD2": "O",
        "\xD3": "O",
        "\xD4": "O",
        "\xD5": "O",
        "\xD6": "O",
        "\xD8": "O",
        "\xF2": "o",
        "\xF3": "o",
        "\xF4": "o",
        "\xF5": "o",
        "\xF6": "o",
        "\xF8": "o",
        "\xD9": "U",
        "\xDA": "U",
        "\xDB": "U",
        "\xDC": "U",
        "\xF9": "u",
        "\xFA": "u",
        "\xFB": "u",
        "\xFC": "u",
        "\xDD": "Y",
        "\xFD": "y",
        "\xFF": "y",
        "\xC6": "Ae",
        "\xE6": "ae",
        "\xDE": "Th",
        "\xFE": "th",
        "\xDF": "ss",
        // Latin Extended-A block.
        "\u0100": "A",
        "\u0102": "A",
        "\u0104": "A",
        "\u0101": "a",
        "\u0103": "a",
        "\u0105": "a",
        "\u0106": "C",
        "\u0108": "C",
        "\u010A": "C",
        "\u010C": "C",
        "\u0107": "c",
        "\u0109": "c",
        "\u010B": "c",
        "\u010D": "c",
        "\u010E": "D",
        "\u0110": "D",
        "\u010F": "d",
        "\u0111": "d",
        "\u0112": "E",
        "\u0114": "E",
        "\u0116": "E",
        "\u0118": "E",
        "\u011A": "E",
        "\u0113": "e",
        "\u0115": "e",
        "\u0117": "e",
        "\u0119": "e",
        "\u011B": "e",
        "\u011C": "G",
        "\u011E": "G",
        "\u0120": "G",
        "\u0122": "G",
        "\u011D": "g",
        "\u011F": "g",
        "\u0121": "g",
        "\u0123": "g",
        "\u0124": "H",
        "\u0126": "H",
        "\u0125": "h",
        "\u0127": "h",
        "\u0128": "I",
        "\u012A": "I",
        "\u012C": "I",
        "\u012E": "I",
        "\u0130": "I",
        "\u0129": "i",
        "\u012B": "i",
        "\u012D": "i",
        "\u012F": "i",
        "\u0131": "i",
        "\u0134": "J",
        "\u0135": "j",
        "\u0136": "K",
        "\u0137": "k",
        "\u0138": "k",
        "\u0139": "L",
        "\u013B": "L",
        "\u013D": "L",
        "\u013F": "L",
        "\u0141": "L",
        "\u013A": "l",
        "\u013C": "l",
        "\u013E": "l",
        "\u0140": "l",
        "\u0142": "l",
        "\u0143": "N",
        "\u0145": "N",
        "\u0147": "N",
        "\u014A": "N",
        "\u0144": "n",
        "\u0146": "n",
        "\u0148": "n",
        "\u014B": "n",
        "\u014C": "O",
        "\u014E": "O",
        "\u0150": "O",
        "\u014D": "o",
        "\u014F": "o",
        "\u0151": "o",
        "\u0154": "R",
        "\u0156": "R",
        "\u0158": "R",
        "\u0155": "r",
        "\u0157": "r",
        "\u0159": "r",
        "\u015A": "S",
        "\u015C": "S",
        "\u015E": "S",
        "\u0160": "S",
        "\u015B": "s",
        "\u015D": "s",
        "\u015F": "s",
        "\u0161": "s",
        "\u0162": "T",
        "\u0164": "T",
        "\u0166": "T",
        "\u0163": "t",
        "\u0165": "t",
        "\u0167": "t",
        "\u0168": "U",
        "\u016A": "U",
        "\u016C": "U",
        "\u016E": "U",
        "\u0170": "U",
        "\u0172": "U",
        "\u0169": "u",
        "\u016B": "u",
        "\u016D": "u",
        "\u016F": "u",
        "\u0171": "u",
        "\u0173": "u",
        "\u0174": "W",
        "\u0175": "w",
        "\u0176": "Y",
        "\u0177": "y",
        "\u0178": "Y",
        "\u0179": "Z",
        "\u017B": "Z",
        "\u017D": "Z",
        "\u017A": "z",
        "\u017C": "z",
        "\u017E": "z",
        "\u0132": "IJ",
        "\u0133": "ij",
        "\u0152": "Oe",
        "\u0153": "oe",
        "\u0149": "'n",
        "\u017F": "s"
      };
      var htmlEscapes = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      };
      var htmlUnescapes = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'"
      };
      var stringEscapes = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029"
      };
      var freeParseFloat = parseFloat, freeParseInt = parseInt;
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
      var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeProcess = moduleExports && freeGlobal.process;
      var nodeUtil = (function() {
        try {
          var types = freeModule && freeModule.require && freeModule.require("util").types;
          if (types) {
            return types;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e) {
        }
      })();
      var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      function arrayAggregator(array, setter, iteratee, accumulator) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          var value = array[index];
          setter(accumulator, value, iteratee(value), array);
        }
        return accumulator;
      }
      function arrayEach(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (iteratee(array[index], index, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEachRight(array, iteratee) {
        var length = array == null ? 0 : array.length;
        while (length--) {
          if (iteratee(array[length], length, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEvery(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (!predicate(array[index], index, array)) {
            return false;
          }
        }
        return true;
      }
      function arrayFilter(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array[index];
          if (predicate(value, index, array)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      function arrayIncludes(array, value) {
        var length = array == null ? 0 : array.length;
        return !!length && baseIndexOf(array, value, 0) > -1;
      }
      function arrayIncludesWith(array, value, comparator) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (comparator(value, array[index])) {
            return true;
          }
        }
        return false;
      }
      function arrayMap(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length, result = Array(length);
        while (++index < length) {
          result[index] = iteratee(array[index], index, array);
        }
        return result;
      }
      function arrayPush(array, values) {
        var index = -1, length = values.length, offset = array.length;
        while (++index < length) {
          array[offset + index] = values[index];
        }
        return array;
      }
      function arrayReduce(array, iteratee, accumulator, initAccum) {
        var index = -1, length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[++index];
        }
        while (++index < length) {
          accumulator = iteratee(accumulator, array[index], index, array);
        }
        return accumulator;
      }
      function arrayReduceRight(array, iteratee, accumulator, initAccum) {
        var length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[--length];
        }
        while (length--) {
          accumulator = iteratee(accumulator, array[length], length, array);
        }
        return accumulator;
      }
      function arraySome(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (predicate(array[index], index, array)) {
            return true;
          }
        }
        return false;
      }
      var asciiSize = baseProperty("length");
      function asciiToArray(string) {
        return string.split("");
      }
      function asciiWords(string) {
        return string.match(reAsciiWord) || [];
      }
      function baseFindKey(collection, predicate, eachFunc) {
        var result;
        eachFunc(collection, function(value, key, collection2) {
          if (predicate(value, key, collection2)) {
            result = key;
            return false;
          }
        });
        return result;
      }
      function baseFindIndex(array, predicate, fromIndex, fromRight) {
        var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
        while (fromRight ? index-- : ++index < length) {
          if (predicate(array[index], index, array)) {
            return index;
          }
        }
        return -1;
      }
      function baseIndexOf(array, value, fromIndex) {
        return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
      }
      function baseIndexOfWith(array, value, fromIndex, comparator) {
        var index = fromIndex - 1, length = array.length;
        while (++index < length) {
          if (comparator(array[index], value)) {
            return index;
          }
        }
        return -1;
      }
      function baseIsNaN(value) {
        return value !== value;
      }
      function baseMean(array, iteratee) {
        var length = array == null ? 0 : array.length;
        return length ? baseSum(array, iteratee) / length : NAN;
      }
      function baseProperty(key) {
        return function(object) {
          return object == null ? undefined2 : object[key];
        };
      }
      function basePropertyOf(object) {
        return function(key) {
          return object == null ? undefined2 : object[key];
        };
      }
      function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
        eachFunc(collection, function(value, index, collection2) {
          accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
        });
        return accumulator;
      }
      function baseSortBy(array, comparer) {
        var length = array.length;
        array.sort(comparer);
        while (length--) {
          array[length] = array[length].value;
        }
        return array;
      }
      function baseSum(array, iteratee) {
        var result, index = -1, length = array.length;
        while (++index < length) {
          var current = iteratee(array[index]);
          if (current !== undefined2) {
            result = result === undefined2 ? current : result + current;
          }
        }
        return result;
      }
      function baseTimes(n, iteratee) {
        var index = -1, result = Array(n);
        while (++index < n) {
          result[index] = iteratee(index);
        }
        return result;
      }
      function baseToPairs(object, props) {
        return arrayMap(props, function(key) {
          return [key, object[key]];
        });
      }
      function baseTrim(string) {
        return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
      }
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      function baseValues(object, props) {
        return arrayMap(props, function(key) {
          return object[key];
        });
      }
      function cacheHas(cache, key) {
        return cache.has(key);
      }
      function charsStartIndex(strSymbols, chrSymbols) {
        var index = -1, length = strSymbols.length;
        while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      function charsEndIndex(strSymbols, chrSymbols) {
        var index = strSymbols.length;
        while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      function countHolders(array, placeholder) {
        var length = array.length, result = 0;
        while (length--) {
          if (array[length] === placeholder) {
            ++result;
          }
        }
        return result;
      }
      var deburrLetter = basePropertyOf(deburredLetters);
      var escapeHtmlChar = basePropertyOf(htmlEscapes);
      function escapeStringChar(chr) {
        return "\\" + stringEscapes[chr];
      }
      function getValue(object, key) {
        return object == null ? undefined2 : object[key];
      }
      function hasUnicode(string) {
        return reHasUnicode.test(string);
      }
      function hasUnicodeWord(string) {
        return reHasUnicodeWord.test(string);
      }
      function iteratorToArray(iterator) {
        var data, result = [];
        while (!(data = iterator.next()).done) {
          result.push(data.value);
        }
        return result;
      }
      function mapToArray(map2) {
        var index = -1, result = Array(map2.size);
        map2.forEach(function(value, key) {
          result[++index] = [key, value];
        });
        return result;
      }
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      function replaceHolders(array, placeholder) {
        var index = -1, length = array.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array[index];
          if (value === placeholder || value === PLACEHOLDER) {
            array[index] = PLACEHOLDER;
            result[resIndex++] = index;
          }
        }
        return result;
      }
      function setToArray(set) {
        var index = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index] = value;
        });
        return result;
      }
      function setToPairs(set) {
        var index = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index] = [value, value];
        });
        return result;
      }
      function strictIndexOf(array, value, fromIndex) {
        var index = fromIndex - 1, length = array.length;
        while (++index < length) {
          if (array[index] === value) {
            return index;
          }
        }
        return -1;
      }
      function strictLastIndexOf(array, value, fromIndex) {
        var index = fromIndex + 1;
        while (index--) {
          if (array[index] === value) {
            return index;
          }
        }
        return index;
      }
      function stringSize(string) {
        return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
      }
      function stringToArray(string) {
        return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
      }
      function trimmedEndIndex(string) {
        var index = string.length;
        while (index-- && reWhitespace.test(string.charAt(index))) {
        }
        return index;
      }
      var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
      function unicodeSize(string) {
        var result = reUnicode.lastIndex = 0;
        while (reUnicode.test(string)) {
          ++result;
        }
        return result;
      }
      function unicodeToArray(string) {
        return string.match(reUnicode) || [];
      }
      function unicodeWords(string) {
        return string.match(reUnicodeWord) || [];
      }
      var runInContext = (function runInContext2(context) {
        context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));
        var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
        var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
        var coreJsData = context["__core-js_shared__"];
        var funcToString = funcProto.toString;
        var hasOwnProperty = objectProto.hasOwnProperty;
        var idCounter = 0;
        var maskSrcKey = (function() {
          var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
          return uid ? "Symbol(src)_1." + uid : "";
        })();
        var nativeObjectToString = objectProto.toString;
        var objectCtorString = funcToString.call(Object2);
        var oldDash = root._;
        var reIsNative = RegExp2(
          "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
        );
        var Buffer2 = moduleExports ? context.Buffer : undefined2, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined2, symIterator = Symbol2 ? Symbol2.iterator : undefined2, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined2;
        var defineProperty = (function() {
          try {
            var func = getNative(Object2, "defineProperty");
            func({}, "", {});
            return func;
          } catch (e) {
          }
        })();
        var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
        var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined2, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
        var DataView = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
        var metaMap = WeakMap && new WeakMap();
        var realNames = {};
        var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap);
        var symbolProto = Symbol2 ? Symbol2.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
        function lodash2(value) {
          if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
            if (value instanceof LodashWrapper) {
              return value;
            }
            if (hasOwnProperty.call(value, "__wrapped__")) {
              return wrapperClone(value);
            }
          }
          return new LodashWrapper(value);
        }
        var baseCreate = /* @__PURE__ */ (function() {
          function object() {
          }
          return function(proto) {
            if (!isObject(proto)) {
              return {};
            }
            if (objectCreate) {
              return objectCreate(proto);
            }
            object.prototype = proto;
            var result2 = new object();
            object.prototype = undefined2;
            return result2;
          };
        })();
        function baseLodash() {
        }
        function LodashWrapper(value, chainAll) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__chain__ = !!chainAll;
          this.__index__ = 0;
          this.__values__ = undefined2;
        }
        lodash2.templateSettings = {
          /**
           * Used to detect `data` property values to be HTML-escaped.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "escape": reEscape,
          /**
           * Used to detect code to be evaluated.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "evaluate": reEvaluate,
          /**
           * Used to detect `data` property values to inject.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "interpolate": reInterpolate,
          /**
           * Used to reference the data object in the template text.
           *
           * @memberOf _.templateSettings
           * @type {string}
           */
          "variable": "",
          /**
           * Used to import variables into the compiled template.
           *
           * @memberOf _.templateSettings
           * @type {Object}
           */
          "imports": {
            /**
             * A reference to the `lodash` function.
             *
             * @memberOf _.templateSettings.imports
             * @type {Function}
             */
            "_": lodash2
          }
        };
        lodash2.prototype = baseLodash.prototype;
        lodash2.prototype.constructor = lodash2;
        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;
        function LazyWrapper(value) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__dir__ = 1;
          this.__filtered__ = false;
          this.__iteratees__ = [];
          this.__takeCount__ = MAX_ARRAY_LENGTH;
          this.__views__ = [];
        }
        function lazyClone() {
          var result2 = new LazyWrapper(this.__wrapped__);
          result2.__actions__ = copyArray(this.__actions__);
          result2.__dir__ = this.__dir__;
          result2.__filtered__ = this.__filtered__;
          result2.__iteratees__ = copyArray(this.__iteratees__);
          result2.__takeCount__ = this.__takeCount__;
          result2.__views__ = copyArray(this.__views__);
          return result2;
        }
        function lazyReverse() {
          if (this.__filtered__) {
            var result2 = new LazyWrapper(this);
            result2.__dir__ = -1;
            result2.__filtered__ = true;
          } else {
            result2 = this.clone();
            result2.__dir__ *= -1;
          }
          return result2;
        }
        function lazyValue() {
          var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
          if (!isArr || !isRight && arrLength == length && takeCount == length) {
            return baseWrapperValue(array, this.__actions__);
          }
          var result2 = [];
          outer:
            while (length-- && resIndex < takeCount) {
              index += dir;
              var iterIndex = -1, value = array[index];
              while (++iterIndex < iterLength) {
                var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);
                if (type == LAZY_MAP_FLAG) {
                  value = computed;
                } else if (!computed) {
                  if (type == LAZY_FILTER_FLAG) {
                    continue outer;
                  } else {
                    break outer;
                  }
                }
              }
              result2[resIndex++] = value;
            }
          return result2;
        }
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;
        function Hash(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function hashClear() {
          this.__data__ = nativeCreate ? nativeCreate(null) : {};
          this.size = 0;
        }
        function hashDelete(key) {
          var result2 = this.has(key) && delete this.__data__[key];
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function hashGet(key) {
          var data = this.__data__;
          if (nativeCreate) {
            var result2 = data[key];
            return result2 === HASH_UNDEFINED ? undefined2 : result2;
          }
          return hasOwnProperty.call(data, key) ? data[key] : undefined2;
        }
        function hashHas(key) {
          var data = this.__data__;
          return nativeCreate ? data[key] !== undefined2 : hasOwnProperty.call(data, key);
        }
        function hashSet(key, value) {
          var data = this.__data__;
          this.size += this.has(key) ? 0 : 1;
          data[key] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;
          return this;
        }
        Hash.prototype.clear = hashClear;
        Hash.prototype["delete"] = hashDelete;
        Hash.prototype.get = hashGet;
        Hash.prototype.has = hashHas;
        Hash.prototype.set = hashSet;
        function ListCache(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function listCacheClear() {
          this.__data__ = [];
          this.size = 0;
        }
        function listCacheDelete(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            return false;
          }
          var lastIndex = data.length - 1;
          if (index == lastIndex) {
            data.pop();
          } else {
            splice.call(data, index, 1);
          }
          --this.size;
          return true;
        }
        function listCacheGet(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          return index < 0 ? undefined2 : data[index][1];
        }
        function listCacheHas(key) {
          return assocIndexOf(this.__data__, key) > -1;
        }
        function listCacheSet(key, value) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            ++this.size;
            data.push([key, value]);
          } else {
            data[index][1] = value;
          }
          return this;
        }
        ListCache.prototype.clear = listCacheClear;
        ListCache.prototype["delete"] = listCacheDelete;
        ListCache.prototype.get = listCacheGet;
        ListCache.prototype.has = listCacheHas;
        ListCache.prototype.set = listCacheSet;
        function MapCache(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function mapCacheClear() {
          this.size = 0;
          this.__data__ = {
            "hash": new Hash(),
            "map": new (Map2 || ListCache)(),
            "string": new Hash()
          };
        }
        function mapCacheDelete(key) {
          var result2 = getMapData(this, key)["delete"](key);
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function mapCacheGet(key) {
          return getMapData(this, key).get(key);
        }
        function mapCacheHas(key) {
          return getMapData(this, key).has(key);
        }
        function mapCacheSet(key, value) {
          var data = getMapData(this, key), size2 = data.size;
          data.set(key, value);
          this.size += data.size == size2 ? 0 : 1;
          return this;
        }
        MapCache.prototype.clear = mapCacheClear;
        MapCache.prototype["delete"] = mapCacheDelete;
        MapCache.prototype.get = mapCacheGet;
        MapCache.prototype.has = mapCacheHas;
        MapCache.prototype.set = mapCacheSet;
        function SetCache(values2) {
          var index = -1, length = values2 == null ? 0 : values2.length;
          this.__data__ = new MapCache();
          while (++index < length) {
            this.add(values2[index]);
          }
        }
        function setCacheAdd(value) {
          this.__data__.set(value, HASH_UNDEFINED);
          return this;
        }
        function setCacheHas(value) {
          return this.__data__.has(value);
        }
        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
        SetCache.prototype.has = setCacheHas;
        function Stack(entries) {
          var data = this.__data__ = new ListCache(entries);
          this.size = data.size;
        }
        function stackClear() {
          this.__data__ = new ListCache();
          this.size = 0;
        }
        function stackDelete(key) {
          var data = this.__data__, result2 = data["delete"](key);
          this.size = data.size;
          return result2;
        }
        function stackGet(key) {
          return this.__data__.get(key);
        }
        function stackHas(key) {
          return this.__data__.has(key);
        }
        function stackSet(key, value) {
          var data = this.__data__;
          if (data instanceof ListCache) {
            var pairs = data.__data__;
            if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
              pairs.push([key, value]);
              this.size = ++data.size;
              return this;
            }
            data = this.__data__ = new MapCache(pairs);
          }
          data.set(key, value);
          this.size = data.size;
          return this;
        }
        Stack.prototype.clear = stackClear;
        Stack.prototype["delete"] = stackDelete;
        Stack.prototype.get = stackGet;
        Stack.prototype.has = stackHas;
        Stack.prototype.set = stackSet;
        function arrayLikeKeys(value, inherited) {
          var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
          for (var key in value) {
            if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
            (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
            isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
            isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
            isIndex(key, length)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function arraySample(array) {
          var length = array.length;
          return length ? array[baseRandom(0, length - 1)] : undefined2;
        }
        function arraySampleSize(array, n) {
          return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
        }
        function arrayShuffle(array) {
          return shuffleSelf(copyArray(array));
        }
        function assignMergeValue(object, key, value) {
          if (value !== undefined2 && !eq(object[key], value) || value === undefined2 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assignValue(object, key, value) {
          var objValue = object[key];
          if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined2 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assocIndexOf(array, key) {
          var length = array.length;
          while (length--) {
            if (eq(array[length][0], key)) {
              return length;
            }
          }
          return -1;
        }
        function baseAggregator(collection, setter, iteratee2, accumulator) {
          baseEach(collection, function(value, key, collection2) {
            setter(accumulator, value, iteratee2(value), collection2);
          });
          return accumulator;
        }
        function baseAssign(object, source) {
          return object && copyObject(source, keys(source), object);
        }
        function baseAssignIn(object, source) {
          return object && copyObject(source, keysIn(source), object);
        }
        function baseAssignValue(object, key, value) {
          if (key == "__proto__" && defineProperty) {
            defineProperty(object, key, {
              "configurable": true,
              "enumerable": true,
              "value": value,
              "writable": true
            });
          } else {
            object[key] = value;
          }
        }
        function baseAt(object, paths) {
          var index = -1, length = paths.length, result2 = Array2(length), skip = object == null;
          while (++index < length) {
            result2[index] = skip ? undefined2 : get(object, paths[index]);
          }
          return result2;
        }
        function baseClamp(number, lower, upper) {
          if (number === number) {
            if (upper !== undefined2) {
              number = number <= upper ? number : upper;
            }
            if (lower !== undefined2) {
              number = number >= lower ? number : lower;
            }
          }
          return number;
        }
        function baseClone(value, bitmask, customizer, key, object, stack) {
          var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
          if (customizer) {
            result2 = object ? customizer(value, key, object, stack) : customizer(value);
          }
          if (result2 !== undefined2) {
            return result2;
          }
          if (!isObject(value)) {
            return value;
          }
          var isArr = isArray(value);
          if (isArr) {
            result2 = initCloneArray(value);
            if (!isDeep) {
              return copyArray(value, result2);
            }
          } else {
            var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
            if (isBuffer(value)) {
              return cloneBuffer(value, isDeep);
            }
            if (tag == objectTag || tag == argsTag || isFunc && !object) {
              result2 = isFlat || isFunc ? {} : initCloneObject(value);
              if (!isDeep) {
                return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
              }
            } else {
              if (!cloneableTags[tag]) {
                return object ? value : {};
              }
              result2 = initCloneByTag(value, tag, isDeep);
            }
          }
          stack || (stack = new Stack());
          var stacked = stack.get(value);
          if (stacked) {
            return stacked;
          }
          stack.set(value, result2);
          if (isSet(value)) {
            value.forEach(function(subValue) {
              result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
            });
          } else if (isMap(value)) {
            value.forEach(function(subValue, key2) {
              result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
            });
          }
          var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
          var props = isArr ? undefined2 : keysFunc(value);
          arrayEach(props || value, function(subValue, key2) {
            if (props) {
              key2 = subValue;
              subValue = value[key2];
            }
            assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
          return result2;
        }
        function baseConforms(source) {
          var props = keys(source);
          return function(object) {
            return baseConformsTo(object, source, props);
          };
        }
        function baseConformsTo(object, source, props) {
          var length = props.length;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (length--) {
            var key = props[length], predicate = source[key], value = object[key];
            if (value === undefined2 && !(key in object) || !predicate(value)) {
              return false;
            }
          }
          return true;
        }
        function baseDelay(func, wait, args) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return setTimeout(function() {
            func.apply(undefined2, args);
          }, wait);
        }
        function baseDifference(array, values2, iteratee2, comparator) {
          var index = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values2.length;
          if (!length) {
            return result2;
          }
          if (iteratee2) {
            values2 = arrayMap(values2, baseUnary(iteratee2));
          }
          if (comparator) {
            includes2 = arrayIncludesWith;
            isCommon = false;
          } else if (values2.length >= LARGE_ARRAY_SIZE) {
            includes2 = cacheHas;
            isCommon = false;
            values2 = new SetCache(values2);
          }
          outer:
            while (++index < length) {
              var value = array[index], computed = iteratee2 == null ? value : iteratee2(value);
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var valuesIndex = valuesLength;
                while (valuesIndex--) {
                  if (values2[valuesIndex] === computed) {
                    continue outer;
                  }
                }
                result2.push(value);
              } else if (!includes2(values2, computed, comparator)) {
                result2.push(value);
              }
            }
          return result2;
        }
        var baseEach = createBaseEach(baseForOwn);
        var baseEachRight = createBaseEach(baseForOwnRight, true);
        function baseEvery(collection, predicate) {
          var result2 = true;
          baseEach(collection, function(value, index, collection2) {
            result2 = !!predicate(value, index, collection2);
            return result2;
          });
          return result2;
        }
        function baseExtremum(array, iteratee2, comparator) {
          var index = -1, length = array.length;
          while (++index < length) {
            var value = array[index], current = iteratee2(value);
            if (current != null && (computed === undefined2 ? current === current && !isSymbol(current) : comparator(current, computed))) {
              var computed = current, result2 = value;
            }
          }
          return result2;
        }
        function baseFill(array, value, start, end) {
          var length = array.length;
          start = toInteger(start);
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end === undefined2 || end > length ? length : toInteger(end);
          if (end < 0) {
            end += length;
          }
          end = start > end ? 0 : toLength(end);
          while (start < end) {
            array[start++] = value;
          }
          return array;
        }
        function baseFilter(collection, predicate) {
          var result2 = [];
          baseEach(collection, function(value, index, collection2) {
            if (predicate(value, index, collection2)) {
              result2.push(value);
            }
          });
          return result2;
        }
        function baseFlatten(array, depth, predicate, isStrict, result2) {
          var index = -1, length = array.length;
          predicate || (predicate = isFlattenable);
          result2 || (result2 = []);
          while (++index < length) {
            var value = array[index];
            if (depth > 0 && predicate(value)) {
              if (depth > 1) {
                baseFlatten(value, depth - 1, predicate, isStrict, result2);
              } else {
                arrayPush(result2, value);
              }
            } else if (!isStrict) {
              result2[result2.length] = value;
            }
          }
          return result2;
        }
        var baseFor = createBaseFor();
        var baseForRight = createBaseFor(true);
        function baseForOwn(object, iteratee2) {
          return object && baseFor(object, iteratee2, keys);
        }
        function baseForOwnRight(object, iteratee2) {
          return object && baseForRight(object, iteratee2, keys);
        }
        function baseFunctions(object, props) {
          return arrayFilter(props, function(key) {
            return isFunction(object[key]);
          });
        }
        function baseGet(object, path) {
          path = castPath(path, object);
          var index = 0, length = path.length;
          while (object != null && index < length) {
            object = object[toKey(path[index++])];
          }
          return index && index == length ? object : undefined2;
        }
        function baseGetAllKeys(object, keysFunc, symbolsFunc) {
          var result2 = keysFunc(object);
          return isArray(object) ? result2 : arrayPush(result2, symbolsFunc(object));
        }
        function baseGetTag(value) {
          if (value == null) {
            return value === undefined2 ? undefinedTag : nullTag;
          }
          return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
        }
        function baseGt(value, other) {
          return value > other;
        }
        function baseHas(object, key) {
          return object != null && hasOwnProperty.call(object, key);
        }
        function baseHasIn(object, key) {
          return object != null && key in Object2(object);
        }
        function baseInRange(number, start, end) {
          return number >= nativeMin(start, end) && number < nativeMax(start, end);
        }
        function baseIntersection(arrays, iteratee2, comparator) {
          var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
          while (othIndex--) {
            var array = arrays[othIndex];
            if (othIndex && iteratee2) {
              array = arrayMap(array, baseUnary(iteratee2));
            }
            maxLength = nativeMin(array.length, maxLength);
            caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined2;
          }
          array = arrays[0];
          var index = -1, seen = caches[0];
          outer:
            while (++index < length && result2.length < maxLength) {
              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
                othIndex = othLength;
                while (--othIndex) {
                  var cache = caches[othIndex];
                  if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
                    continue outer;
                  }
                }
                if (seen) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseInverter(object, setter, iteratee2, accumulator) {
          baseForOwn(object, function(value, key, object2) {
            setter(accumulator, iteratee2(value), key, object2);
          });
          return accumulator;
        }
        function baseInvoke(object, path, args) {
          path = castPath(path, object);
          object = parent(object, path);
          var func = object == null ? object : object[toKey(last(path))];
          return func == null ? undefined2 : apply(func, object, args);
        }
        function baseIsArguments(value) {
          return isObjectLike(value) && baseGetTag(value) == argsTag;
        }
        function baseIsArrayBuffer(value) {
          return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
        }
        function baseIsDate(value) {
          return isObjectLike(value) && baseGetTag(value) == dateTag;
        }
        function baseIsEqual(value, other, bitmask, customizer, stack) {
          if (value === other) {
            return true;
          }
          if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
        }
        function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
          var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
          objTag = objTag == argsTag ? objectTag : objTag;
          othTag = othTag == argsTag ? objectTag : othTag;
          var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
          if (isSameTag && isBuffer(object)) {
            if (!isBuffer(other)) {
              return false;
            }
            objIsArr = true;
            objIsObj = false;
          }
          if (isSameTag && !objIsObj) {
            stack || (stack = new Stack());
            return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
          }
          if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
            var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
            if (objIsWrapped || othIsWrapped) {
              var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
              stack || (stack = new Stack());
              return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
            }
          }
          if (!isSameTag) {
            return false;
          }
          stack || (stack = new Stack());
          return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
        }
        function baseIsMap(value) {
          return isObjectLike(value) && getTag(value) == mapTag;
        }
        function baseIsMatch(object, source, matchData, customizer) {
          var index = matchData.length, length = index, noCustomizer = !customizer;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (index--) {
            var data = matchData[index];
            if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
              return false;
            }
          }
          while (++index < length) {
            data = matchData[index];
            var key = data[0], objValue = object[key], srcValue = data[1];
            if (noCustomizer && data[2]) {
              if (objValue === undefined2 && !(key in object)) {
                return false;
              }
            } else {
              var stack = new Stack();
              if (customizer) {
                var result2 = customizer(objValue, srcValue, key, object, source, stack);
              }
              if (!(result2 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
                return false;
              }
            }
          }
          return true;
        }
        function baseIsNative(value) {
          if (!isObject(value) || isMasked(value)) {
            return false;
          }
          var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
          return pattern.test(toSource(value));
        }
        function baseIsRegExp(value) {
          return isObjectLike(value) && baseGetTag(value) == regexpTag;
        }
        function baseIsSet(value) {
          return isObjectLike(value) && getTag(value) == setTag;
        }
        function baseIsTypedArray(value) {
          return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
        }
        function baseIteratee(value) {
          if (typeof value == "function") {
            return value;
          }
          if (value == null) {
            return identity;
          }
          if (typeof value == "object") {
            return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
          }
          return property(value);
        }
        function baseKeys(object) {
          if (!isPrototype(object)) {
            return nativeKeys(object);
          }
          var result2 = [];
          for (var key in Object2(object)) {
            if (hasOwnProperty.call(object, key) && key != "constructor") {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseKeysIn(object) {
          if (!isObject(object)) {
            return nativeKeysIn(object);
          }
          var isProto = isPrototype(object), result2 = [];
          for (var key in object) {
            if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseLt(value, other) {
          return value < other;
        }
        function baseMap(collection, iteratee2) {
          var index = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value, key, collection2) {
            result2[++index] = iteratee2(value, key, collection2);
          });
          return result2;
        }
        function baseMatches(source) {
          var matchData = getMatchData(source);
          if (matchData.length == 1 && matchData[0][2]) {
            return matchesStrictComparable(matchData[0][0], matchData[0][1]);
          }
          return function(object) {
            return object === source || baseIsMatch(object, source, matchData);
          };
        }
        function baseMatchesProperty(path, srcValue) {
          if (isKey(path) && isStrictComparable(srcValue)) {
            return matchesStrictComparable(toKey(path), srcValue);
          }
          return function(object) {
            var objValue = get(object, path);
            return objValue === undefined2 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
          };
        }
        function baseMerge(object, source, srcIndex, customizer, stack) {
          if (object === source) {
            return;
          }
          baseFor(source, function(srcValue, key) {
            stack || (stack = new Stack());
            if (isObject(srcValue)) {
              baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
            } else {
              var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined2;
              if (newValue === undefined2) {
                newValue = srcValue;
              }
              assignMergeValue(object, key, newValue);
            }
          }, keysIn);
        }
        function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
          var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
          if (stacked) {
            assignMergeValue(object, key, stacked);
            return;
          }
          var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined2;
          var isCommon = newValue === undefined2;
          if (isCommon) {
            var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
            newValue = srcValue;
            if (isArr || isBuff || isTyped) {
              if (isArray(objValue)) {
                newValue = objValue;
              } else if (isArrayLikeObject(objValue)) {
                newValue = copyArray(objValue);
              } else if (isBuff) {
                isCommon = false;
                newValue = cloneBuffer(srcValue, true);
              } else if (isTyped) {
                isCommon = false;
                newValue = cloneTypedArray(srcValue, true);
              } else {
                newValue = [];
              }
            } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
              newValue = objValue;
              if (isArguments(objValue)) {
                newValue = toPlainObject(objValue);
              } else if (!isObject(objValue) || isFunction(objValue)) {
                newValue = initCloneObject(srcValue);
              }
            } else {
              isCommon = false;
            }
          }
          if (isCommon) {
            stack.set(srcValue, newValue);
            mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
            stack["delete"](srcValue);
          }
          assignMergeValue(object, key, newValue);
        }
        function baseNth(array, n) {
          var length = array.length;
          if (!length) {
            return;
          }
          n += n < 0 ? length : 0;
          return isIndex(n, length) ? array[n] : undefined2;
        }
        function baseOrderBy(collection, iteratees, orders) {
          if (iteratees.length) {
            iteratees = arrayMap(iteratees, function(iteratee2) {
              if (isArray(iteratee2)) {
                return function(value) {
                  return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                };
              }
              return iteratee2;
            });
          } else {
            iteratees = [identity];
          }
          var index = -1;
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          var result2 = baseMap(collection, function(value, key, collection2) {
            var criteria = arrayMap(iteratees, function(iteratee2) {
              return iteratee2(value);
            });
            return { "criteria": criteria, "index": ++index, "value": value };
          });
          return baseSortBy(result2, function(object, other) {
            return compareMultiple(object, other, orders);
          });
        }
        function basePick(object, paths) {
          return basePickBy(object, paths, function(value, path) {
            return hasIn(object, path);
          });
        }
        function basePickBy(object, paths, predicate) {
          var index = -1, length = paths.length, result2 = {};
          while (++index < length) {
            var path = paths[index], value = baseGet(object, path);
            if (predicate(value, path)) {
              baseSet(result2, castPath(path, object), value);
            }
          }
          return result2;
        }
        function basePropertyDeep(path) {
          return function(object) {
            return baseGet(object, path);
          };
        }
        function basePullAll(array, values2, iteratee2, comparator) {
          var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values2.length, seen = array;
          if (array === values2) {
            values2 = copyArray(values2);
          }
          if (iteratee2) {
            seen = arrayMap(array, baseUnary(iteratee2));
          }
          while (++index < length) {
            var fromIndex = 0, value = values2[index], computed = iteratee2 ? iteratee2(value) : value;
            while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
              if (seen !== array) {
                splice.call(seen, fromIndex, 1);
              }
              splice.call(array, fromIndex, 1);
            }
          }
          return array;
        }
        function basePullAt(array, indexes) {
          var length = array ? indexes.length : 0, lastIndex = length - 1;
          while (length--) {
            var index = indexes[length];
            if (length == lastIndex || index !== previous) {
              var previous = index;
              if (isIndex(index)) {
                splice.call(array, index, 1);
              } else {
                baseUnset(array, index);
              }
            }
          }
          return array;
        }
        function baseRandom(lower, upper) {
          return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
        }
        function baseRange(start, end, step, fromRight) {
          var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length);
          while (length--) {
            result2[fromRight ? length : ++index] = start;
            start += step;
          }
          return result2;
        }
        function baseRepeat(string, n) {
          var result2 = "";
          if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
            return result2;
          }
          do {
            if (n % 2) {
              result2 += string;
            }
            n = nativeFloor(n / 2);
            if (n) {
              string += string;
            }
          } while (n);
          return result2;
        }
        function baseRest(func, start) {
          return setToString(overRest(func, start, identity), func + "");
        }
        function baseSample(collection) {
          return arraySample(values(collection));
        }
        function baseSampleSize(collection, n) {
          var array = values(collection);
          return shuffleSelf(array, baseClamp(n, 0, array.length));
        }
        function baseSet(object, path, value, customizer) {
          if (!isObject(object)) {
            return object;
          }
          path = castPath(path, object);
          var index = -1, length = path.length, lastIndex = length - 1, nested = object;
          while (nested != null && ++index < length) {
            var key = toKey(path[index]), newValue = value;
            if (key === "__proto__" || key === "constructor" || key === "prototype") {
              return object;
            }
            if (index != lastIndex) {
              var objValue = nested[key];
              newValue = customizer ? customizer(objValue, key, nested) : undefined2;
              if (newValue === undefined2) {
                newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
              }
            }
            assignValue(nested, key, newValue);
            nested = nested[key];
          }
          return object;
        }
        var baseSetData = !metaMap ? identity : function(func, data) {
          metaMap.set(func, data);
          return func;
        };
        var baseSetToString = !defineProperty ? identity : function(func, string) {
          return defineProperty(func, "toString", {
            "configurable": true,
            "enumerable": false,
            "value": constant(string),
            "writable": true
          });
        };
        function baseShuffle(collection) {
          return shuffleSelf(values(collection));
        }
        function baseSlice(array, start, end) {
          var index = -1, length = array.length;
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end > length ? length : end;
          if (end < 0) {
            end += length;
          }
          length = start > end ? 0 : end - start >>> 0;
          start >>>= 0;
          var result2 = Array2(length);
          while (++index < length) {
            result2[index] = array[index + start];
          }
          return result2;
        }
        function baseSome(collection, predicate) {
          var result2;
          baseEach(collection, function(value, index, collection2) {
            result2 = predicate(value, index, collection2);
            return !result2;
          });
          return !!result2;
        }
        function baseSortedIndex(array, value, retHighest) {
          var low = 0, high = array == null ? low : array.length;
          if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
            while (low < high) {
              var mid = low + high >>> 1, computed = array[mid];
              if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return high;
          }
          return baseSortedIndexBy(array, value, identity, retHighest);
        }
        function baseSortedIndexBy(array, value, iteratee2, retHighest) {
          var low = 0, high = array == null ? 0 : array.length;
          if (high === 0) {
            return 0;
          }
          value = iteratee2(value);
          var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined2;
          while (low < high) {
            var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
            if (valIsNaN) {
              var setLow = retHighest || othIsReflexive;
            } else if (valIsUndefined) {
              setLow = othIsReflexive && (retHighest || othIsDefined);
            } else if (valIsNull) {
              setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
            } else if (valIsSymbol) {
              setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
            } else if (othIsNull || othIsSymbol) {
              setLow = false;
            } else {
              setLow = retHighest ? computed <= value : computed < value;
            }
            if (setLow) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return nativeMin(high, MAX_ARRAY_INDEX);
        }
        function baseSortedUniq(array, iteratee2) {
          var index = -1, length = array.length, resIndex = 0, result2 = [];
          while (++index < length) {
            var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
            if (!index || !eq(computed, seen)) {
              var seen = computed;
              result2[resIndex++] = value === 0 ? 0 : value;
            }
          }
          return result2;
        }
        function baseToNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          return +value;
        }
        function baseToString(value) {
          if (typeof value == "string") {
            return value;
          }
          if (isArray(value)) {
            return arrayMap(value, baseToString) + "";
          }
          if (isSymbol(value)) {
            return symbolToString ? symbolToString.call(value) : "";
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function baseUniq(array, iteratee2, comparator) {
          var index = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen = result2;
          if (comparator) {
            isCommon = false;
            includes2 = arrayIncludesWith;
          } else if (length >= LARGE_ARRAY_SIZE) {
            var set2 = iteratee2 ? null : createSet(array);
            if (set2) {
              return setToArray(set2);
            }
            isCommon = false;
            includes2 = cacheHas;
            seen = new SetCache();
          } else {
            seen = iteratee2 ? [] : result2;
          }
          outer:
            while (++index < length) {
              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var seenIndex = seen.length;
                while (seenIndex--) {
                  if (seen[seenIndex] === computed) {
                    continue outer;
                  }
                }
                if (iteratee2) {
                  seen.push(computed);
                }
                result2.push(value);
              } else if (!includes2(seen, computed, comparator)) {
                if (seen !== result2) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseUnset(object, path) {
          path = castPath(path, object);
          object = parent(object, path);
          return object == null || delete object[toKey(last(path))];
        }
        function baseUpdate(object, path, updater, customizer) {
          return baseSet(object, path, updater(baseGet(object, path)), customizer);
        }
        function baseWhile(array, predicate, isDrop, fromRight) {
          var length = array.length, index = fromRight ? length : -1;
          while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {
          }
          return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
        }
        function baseWrapperValue(value, actions) {
          var result2 = value;
          if (result2 instanceof LazyWrapper) {
            result2 = result2.value();
          }
          return arrayReduce(actions, function(result3, action) {
            return action.func.apply(action.thisArg, arrayPush([result3], action.args));
          }, result2);
        }
        function baseXor(arrays, iteratee2, comparator) {
          var length = arrays.length;
          if (length < 2) {
            return length ? baseUniq(arrays[0]) : [];
          }
          var index = -1, result2 = Array2(length);
          while (++index < length) {
            var array = arrays[index], othIndex = -1;
            while (++othIndex < length) {
              if (othIndex != index) {
                result2[index] = baseDifference(result2[index] || array, arrays[othIndex], iteratee2, comparator);
              }
            }
          }
          return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
        }
        function baseZipObject(props, values2, assignFunc) {
          var index = -1, length = props.length, valsLength = values2.length, result2 = {};
          while (++index < length) {
            var value = index < valsLength ? values2[index] : undefined2;
            assignFunc(result2, props[index], value);
          }
          return result2;
        }
        function castArrayLikeObject(value) {
          return isArrayLikeObject(value) ? value : [];
        }
        function castFunction(value) {
          return typeof value == "function" ? value : identity;
        }
        function castPath(value, object) {
          if (isArray(value)) {
            return value;
          }
          return isKey(value, object) ? [value] : stringToPath(toString(value));
        }
        var castRest = baseRest;
        function castSlice(array, start, end) {
          var length = array.length;
          end = end === undefined2 ? length : end;
          return !start && end >= length ? array : baseSlice(array, start, end);
        }
        var clearTimeout = ctxClearTimeout || function(id) {
          return root.clearTimeout(id);
        };
        function cloneBuffer(buffer, isDeep) {
          if (isDeep) {
            return buffer.slice();
          }
          var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
          buffer.copy(result2);
          return result2;
        }
        function cloneArrayBuffer(arrayBuffer) {
          var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
          new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
          return result2;
        }
        function cloneDataView(dataView, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
          return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
        }
        function cloneRegExp(regexp) {
          var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
          result2.lastIndex = regexp.lastIndex;
          return result2;
        }
        function cloneSymbol(symbol) {
          return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
        }
        function cloneTypedArray(typedArray, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
          return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
        }
        function compareAscending(value, other) {
          if (value !== other) {
            var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
            var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
            if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
              return 1;
            }
            if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
              return -1;
            }
          }
          return 0;
        }
        function compareMultiple(object, other, orders) {
          var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
          while (++index < length) {
            var result2 = compareAscending(objCriteria[index], othCriteria[index]);
            if (result2) {
              if (index >= ordersLength) {
                return result2;
              }
              var order = orders[index];
              return result2 * (order == "desc" ? -1 : 1);
            }
          }
          return object.index - other.index;
        }
        function composeArgs(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
          while (++leftIndex < leftLength) {
            result2[leftIndex] = partials[leftIndex];
          }
          while (++argsIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[holders[argsIndex]] = args[argsIndex];
            }
          }
          while (rangeLength--) {
            result2[leftIndex++] = args[argsIndex++];
          }
          return result2;
        }
        function composeArgsRight(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
          while (++argsIndex < rangeLength) {
            result2[argsIndex] = args[argsIndex];
          }
          var offset = argsIndex;
          while (++rightIndex < rightLength) {
            result2[offset + rightIndex] = partials[rightIndex];
          }
          while (++holdersIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[offset + holders[holdersIndex]] = args[argsIndex++];
            }
          }
          return result2;
        }
        function copyArray(source, array) {
          var index = -1, length = source.length;
          array || (array = Array2(length));
          while (++index < length) {
            array[index] = source[index];
          }
          return array;
        }
        function copyObject(source, props, object, customizer) {
          var isNew = !object;
          object || (object = {});
          var index = -1, length = props.length;
          while (++index < length) {
            var key = props[index];
            var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined2;
            if (newValue === undefined2) {
              newValue = source[key];
            }
            if (isNew) {
              baseAssignValue(object, key, newValue);
            } else {
              assignValue(object, key, newValue);
            }
          }
          return object;
        }
        function copySymbols(source, object) {
          return copyObject(source, getSymbols(source), object);
        }
        function copySymbolsIn(source, object) {
          return copyObject(source, getSymbolsIn(source), object);
        }
        function createAggregator(setter, initializer) {
          return function(collection, iteratee2) {
            var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
            return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
          };
        }
        function createAssigner(assigner) {
          return baseRest(function(object, sources) {
            var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined2, guard = length > 2 ? sources[2] : undefined2;
            customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined2;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              customizer = length < 3 ? undefined2 : customizer;
              length = 1;
            }
            object = Object2(object);
            while (++index < length) {
              var source = sources[index];
              if (source) {
                assigner(object, source, index, customizer);
              }
            }
            return object;
          });
        }
        function createBaseEach(eachFunc, fromRight) {
          return function(collection, iteratee2) {
            if (collection == null) {
              return collection;
            }
            if (!isArrayLike(collection)) {
              return eachFunc(collection, iteratee2);
            }
            var length = collection.length, index = fromRight ? length : -1, iterable = Object2(collection);
            while (fromRight ? index-- : ++index < length) {
              if (iteratee2(iterable[index], index, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }
        function createBaseFor(fromRight) {
          return function(object, iteratee2, keysFunc) {
            var index = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
            while (length--) {
              var key = props[fromRight ? length : ++index];
              if (iteratee2(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object;
          };
        }
        function createBind(func, bitmask, thisArg) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            return fn.apply(isBind ? thisArg : this, arguments);
          }
          return wrapper;
        }
        function createCaseFirst(methodName) {
          return function(string) {
            string = toString(string);
            var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined2;
            var chr = strSymbols ? strSymbols[0] : string.charAt(0);
            var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
            return chr[methodName]() + trailing;
          };
        }
        function createCompounder(callback) {
          return function(string) {
            return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
          };
        }
        function createCtor(Ctor) {
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return new Ctor();
              case 1:
                return new Ctor(args[0]);
              case 2:
                return new Ctor(args[0], args[1]);
              case 3:
                return new Ctor(args[0], args[1], args[2]);
              case 4:
                return new Ctor(args[0], args[1], args[2], args[3]);
              case 5:
                return new Ctor(args[0], args[1], args[2], args[3], args[4]);
              case 6:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
              case 7:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
            }
            var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
            return isObject(result2) ? result2 : thisBinding;
          };
        }
        function createCurry(func, bitmask, arity) {
          var Ctor = createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index = length, placeholder = getHolder(wrapper);
            while (index--) {
              args[index] = arguments[index];
            }
            var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
            length -= holders.length;
            if (length < arity) {
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                undefined2,
                args,
                holders,
                undefined2,
                undefined2,
                arity - length
              );
            }
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            return apply(fn, this, args);
          }
          return wrapper;
        }
        function createFind(findIndexFunc) {
          return function(collection, predicate, fromIndex) {
            var iterable = Object2(collection);
            if (!isArrayLike(collection)) {
              var iteratee2 = getIteratee(predicate, 3);
              collection = keys(collection);
              predicate = function(key) {
                return iteratee2(iterable[key], key, iterable);
              };
            }
            var index = findIndexFunc(collection, predicate, fromIndex);
            return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined2;
          };
        }
        function createFlow(fromRight) {
          return flatRest(function(funcs) {
            var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
            if (fromRight) {
              funcs.reverse();
            }
            while (index--) {
              var func = funcs[index];
              if (typeof func != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT);
              }
              if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                var wrapper = new LodashWrapper([], true);
              }
            }
            index = wrapper ? index : length;
            while (++index < length) {
              func = funcs[index];
              var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined2;
              if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
              } else {
                wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
              }
            }
            return function() {
              var args = arguments, value = args[0];
              if (wrapper && args.length == 1 && isArray(value)) {
                return wrapper.plant(value).value();
              }
              var index2 = 0, result2 = length ? funcs[index2].apply(this, args) : value;
              while (++index2 < length) {
                result2 = funcs[index2].call(this, result2);
              }
              return result2;
            };
          });
        }
        function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
          var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index = length;
            while (index--) {
              args[index] = arguments[index];
            }
            if (isCurried) {
              var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
            }
            if (partials) {
              args = composeArgs(args, partials, holders, isCurried);
            }
            if (partialsRight) {
              args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
            }
            length -= holdersCount;
            if (isCurried && length < arity) {
              var newHolders = replaceHolders(args, placeholder);
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                thisArg,
                args,
                newHolders,
                argPos,
                ary2,
                arity - length
              );
            }
            var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
            length = args.length;
            if (argPos) {
              args = reorder(args, argPos);
            } else if (isFlip && length > 1) {
              args.reverse();
            }
            if (isAry && ary2 < length) {
              args.length = ary2;
            }
            if (this && this !== root && this instanceof wrapper) {
              fn = Ctor || createCtor(fn);
            }
            return fn.apply(thisBinding, args);
          }
          return wrapper;
        }
        function createInverter(setter, toIteratee) {
          return function(object, iteratee2) {
            return baseInverter(object, setter, toIteratee(iteratee2), {});
          };
        }
        function createMathOperation(operator, defaultValue) {
          return function(value, other) {
            var result2;
            if (value === undefined2 && other === undefined2) {
              return defaultValue;
            }
            if (value !== undefined2) {
              result2 = value;
            }
            if (other !== undefined2) {
              if (result2 === undefined2) {
                return other;
              }
              if (typeof value == "string" || typeof other == "string") {
                value = baseToString(value);
                other = baseToString(other);
              } else {
                value = baseToNumber(value);
                other = baseToNumber(other);
              }
              result2 = operator(value, other);
            }
            return result2;
          };
        }
        function createOver(arrayFunc) {
          return flatRest(function(iteratees) {
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            return baseRest(function(args) {
              var thisArg = this;
              return arrayFunc(iteratees, function(iteratee2) {
                return apply(iteratee2, thisArg, args);
              });
            });
          });
        }
        function createPadding(length, chars) {
          chars = chars === undefined2 ? " " : baseToString(chars);
          var charsLength = chars.length;
          if (charsLength < 2) {
            return charsLength ? baseRepeat(chars, length) : chars;
          }
          var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
          return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
        }
        function createPartial(func, bitmask, thisArg, partials) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            while (++leftIndex < leftLength) {
              args[leftIndex] = partials[leftIndex];
            }
            while (argsLength--) {
              args[leftIndex++] = arguments[++argsIndex];
            }
            return apply(fn, isBind ? thisArg : this, args);
          }
          return wrapper;
        }
        function createRange(fromRight) {
          return function(start, end, step) {
            if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
              end = step = undefined2;
            }
            start = toFinite(start);
            if (end === undefined2) {
              end = start;
              start = 0;
            } else {
              end = toFinite(end);
            }
            step = step === undefined2 ? start < end ? 1 : -1 : toFinite(step);
            return baseRange(start, end, step, fromRight);
          };
        }
        function createRelationalOperation(operator) {
          return function(value, other) {
            if (!(typeof value == "string" && typeof other == "string")) {
              value = toNumber2(value);
              other = toNumber2(other);
            }
            return operator(value, other);
          };
        }
        function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
          var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
          bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
          bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
          if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
            bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
          }
          var newData = [
            func,
            bitmask,
            thisArg,
            newPartials,
            newHolders,
            newPartialsRight,
            newHoldersRight,
            argPos,
            ary2,
            arity
          ];
          var result2 = wrapFunc.apply(undefined2, newData);
          if (isLaziable(func)) {
            setData(result2, newData);
          }
          result2.placeholder = placeholder;
          return setWrapToString(result2, func, bitmask);
        }
        function createRound(methodName) {
          var func = Math2[methodName];
          return function(number, precision) {
            number = toNumber2(number);
            precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
            if (precision && nativeIsFinite(number)) {
              var pair = (toString(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
              pair = (toString(value) + "e").split("e");
              return +(pair[0] + "e" + (+pair[1] - precision));
            }
            return func(number);
          };
        }
        var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values2) {
          return new Set2(values2);
        };
        function createToPairs(keysFunc) {
          return function(object) {
            var tag = getTag(object);
            if (tag == mapTag) {
              return mapToArray(object);
            }
            if (tag == setTag) {
              return setToPairs(object);
            }
            return baseToPairs(object, keysFunc(object));
          };
        }
        function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
          var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
          if (!isBindKey && typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var length = partials ? partials.length : 0;
          if (!length) {
            bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
            partials = holders = undefined2;
          }
          ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger(ary2), 0);
          arity = arity === undefined2 ? arity : toInteger(arity);
          length -= holders ? holders.length : 0;
          if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials, holdersRight = holders;
            partials = holders = undefined2;
          }
          var data = isBindKey ? undefined2 : getData(func);
          var newData = [
            func,
            bitmask,
            thisArg,
            partials,
            holders,
            partialsRight,
            holdersRight,
            argPos,
            ary2,
            arity
          ];
          if (data) {
            mergeData(newData, data);
          }
          func = newData[0];
          bitmask = newData[1];
          thisArg = newData[2];
          partials = newData[3];
          holders = newData[4];
          arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
          if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
            bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
          }
          if (!bitmask || bitmask == WRAP_BIND_FLAG) {
            var result2 = createBind(func, bitmask, thisArg);
          } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
            result2 = createCurry(func, bitmask, arity);
          } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
            result2 = createPartial(func, bitmask, thisArg, partials);
          } else {
            result2 = createHybrid.apply(undefined2, newData);
          }
          var setter = data ? baseSetData : setData;
          return setWrapToString(setter(result2, newData), func, bitmask);
        }
        function customDefaultsAssignIn(objValue, srcValue, key, object) {
          if (objValue === undefined2 || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
            return srcValue;
          }
          return objValue;
        }
        function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
          if (isObject(objValue) && isObject(srcValue)) {
            stack.set(srcValue, objValue);
            baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack);
            stack["delete"](srcValue);
          }
          return objValue;
        }
        function customOmitClone(value) {
          return isPlainObject(value) ? undefined2 : value;
        }
        function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
          if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
            return false;
          }
          var arrStacked = stack.get(array);
          var othStacked = stack.get(other);
          if (arrStacked && othStacked) {
            return arrStacked == other && othStacked == array;
          }
          var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined2;
          stack.set(array, other);
          stack.set(other, array);
          while (++index < arrLength) {
            var arrValue = array[index], othValue = other[index];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
            }
            if (compared !== undefined2) {
              if (compared) {
                continue;
              }
              result2 = false;
              break;
            }
            if (seen) {
              if (!arraySome(other, function(othValue2, othIndex) {
                if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
                result2 = false;
                break;
              }
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              result2 = false;
              break;
            }
          }
          stack["delete"](array);
          stack["delete"](other);
          return result2;
        }
        function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
          switch (tag) {
            case dataViewTag:
              if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                return false;
              }
              object = object.buffer;
              other = other.buffer;
            case arrayBufferTag:
              if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
                return false;
              }
              return true;
            case boolTag:
            case dateTag:
            case numberTag:
              return eq(+object, +other);
            case errorTag:
              return object.name == other.name && object.message == other.message;
            case regexpTag:
            case stringTag:
              return object == other + "";
            case mapTag:
              var convert = mapToArray;
            case setTag:
              var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
              convert || (convert = setToArray);
              if (object.size != other.size && !isPartial) {
                return false;
              }
              var stacked = stack.get(object);
              if (stacked) {
                return stacked == other;
              }
              bitmask |= COMPARE_UNORDERED_FLAG;
              stack.set(object, other);
              var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
              stack["delete"](object);
              return result2;
            case symbolTag:
              if (symbolValueOf) {
                return symbolValueOf.call(object) == symbolValueOf.call(other);
              }
          }
          return false;
        }
        function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
          if (objLength != othLength && !isPartial) {
            return false;
          }
          var index = objLength;
          while (index--) {
            var key = objProps[index];
            if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
              return false;
            }
          }
          var objStacked = stack.get(object);
          var othStacked = stack.get(other);
          if (objStacked && othStacked) {
            return objStacked == other && othStacked == object;
          }
          var result2 = true;
          stack.set(object, other);
          stack.set(other, object);
          var skipCtor = isPartial;
          while (++index < objLength) {
            key = objProps[index];
            var objValue = object[key], othValue = other[key];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
            }
            if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
              result2 = false;
              break;
            }
            skipCtor || (skipCtor = key == "constructor");
          }
          if (result2 && !skipCtor) {
            var objCtor = object.constructor, othCtor = other.constructor;
            if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
              result2 = false;
            }
          }
          stack["delete"](object);
          stack["delete"](other);
          return result2;
        }
        function flatRest(func) {
          return setToString(overRest(func, undefined2, flatten), func + "");
        }
        function getAllKeys(object) {
          return baseGetAllKeys(object, keys, getSymbols);
        }
        function getAllKeysIn(object) {
          return baseGetAllKeys(object, keysIn, getSymbolsIn);
        }
        var getData = !metaMap ? noop : function(func) {
          return metaMap.get(func);
        };
        function getFuncName(func) {
          var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty.call(realNames, result2) ? array.length : 0;
          while (length--) {
            var data = array[length], otherFunc = data.func;
            if (otherFunc == null || otherFunc == func) {
              return data.name;
            }
          }
          return result2;
        }
        function getHolder(func) {
          var object = hasOwnProperty.call(lodash2, "placeholder") ? lodash2 : func;
          return object.placeholder;
        }
        function getIteratee() {
          var result2 = lodash2.iteratee || iteratee;
          result2 = result2 === iteratee ? baseIteratee : result2;
          return arguments.length ? result2(arguments[0], arguments[1]) : result2;
        }
        function getMapData(map3, key) {
          var data = map3.__data__;
          return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
        }
        function getMatchData(object) {
          var result2 = keys(object), length = result2.length;
          while (length--) {
            var key = result2[length], value = object[key];
            result2[length] = [key, value, isStrictComparable(value)];
          }
          return result2;
        }
        function getNative(object, key) {
          var value = getValue(object, key);
          return baseIsNative(value) ? value : undefined2;
        }
        function getRawTag(value) {
          var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
          try {
            value[symToStringTag] = undefined2;
            var unmasked = true;
          } catch (e) {
          }
          var result2 = nativeObjectToString.call(value);
          if (unmasked) {
            if (isOwn) {
              value[symToStringTag] = tag;
            } else {
              delete value[symToStringTag];
            }
          }
          return result2;
        }
        var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
          if (object == null) {
            return [];
          }
          object = Object2(object);
          return arrayFilter(nativeGetSymbols(object), function(symbol) {
            return propertyIsEnumerable.call(object, symbol);
          });
        };
        var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
          var result2 = [];
          while (object) {
            arrayPush(result2, getSymbols(object));
            object = getPrototype(object);
          }
          return result2;
        };
        var getTag = baseGetTag;
        if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
          getTag = function(value) {
            var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : "";
            if (ctorString) {
              switch (ctorString) {
                case dataViewCtorString:
                  return dataViewTag;
                case mapCtorString:
                  return mapTag;
                case promiseCtorString:
                  return promiseTag;
                case setCtorString:
                  return setTag;
                case weakMapCtorString:
                  return weakMapTag;
              }
            }
            return result2;
          };
        }
        function getView(start, end, transforms) {
          var index = -1, length = transforms.length;
          while (++index < length) {
            var data = transforms[index], size2 = data.size;
            switch (data.type) {
              case "drop":
                start += size2;
                break;
              case "dropRight":
                end -= size2;
                break;
              case "take":
                end = nativeMin(end, start + size2);
                break;
              case "takeRight":
                start = nativeMax(start, end - size2);
                break;
            }
          }
          return { "start": start, "end": end };
        }
        function getWrapDetails(source) {
          var match = source.match(reWrapDetails);
          return match ? match[1].split(reSplitDetails) : [];
        }
        function hasPath(object, path, hasFunc) {
          path = castPath(path, object);
          var index = -1, length = path.length, result2 = false;
          while (++index < length) {
            var key = toKey(path[index]);
            if (!(result2 = object != null && hasFunc(object, key))) {
              break;
            }
            object = object[key];
          }
          if (result2 || ++index != length) {
            return result2;
          }
          length = object == null ? 0 : object.length;
          return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
        }
        function initCloneArray(array) {
          var length = array.length, result2 = new array.constructor(length);
          if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
            result2.index = array.index;
            result2.input = array.input;
          }
          return result2;
        }
        function initCloneObject(object) {
          return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
        }
        function initCloneByTag(object, tag, isDeep) {
          var Ctor = object.constructor;
          switch (tag) {
            case arrayBufferTag:
              return cloneArrayBuffer(object);
            case boolTag:
            case dateTag:
              return new Ctor(+object);
            case dataViewTag:
              return cloneDataView(object, isDeep);
            case float32Tag:
            case float64Tag:
            case int8Tag:
            case int16Tag:
            case int32Tag:
            case uint8Tag:
            case uint8ClampedTag:
            case uint16Tag:
            case uint32Tag:
              return cloneTypedArray(object, isDeep);
            case mapTag:
              return new Ctor();
            case numberTag:
            case stringTag:
              return new Ctor(object);
            case regexpTag:
              return cloneRegExp(object);
            case setTag:
              return new Ctor();
            case symbolTag:
              return cloneSymbol(object);
          }
        }
        function insertWrapDetails(source, details) {
          var length = details.length;
          if (!length) {
            return source;
          }
          var lastIndex = length - 1;
          details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
          details = details.join(length > 2 ? ", " : " ");
          return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
        }
        function isFlattenable(value) {
          return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
        }
        function isIndex(value, length) {
          var type = typeof value;
          length = length == null ? MAX_SAFE_INTEGER : length;
          return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
        }
        function isIterateeCall(value, index, object) {
          if (!isObject(object)) {
            return false;
          }
          var type = typeof index;
          if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
            return eq(object[index], value);
          }
          return false;
        }
        function isKey(value, object) {
          if (isArray(value)) {
            return false;
          }
          var type = typeof value;
          if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
            return true;
          }
          return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
        }
        function isKeyable(value) {
          var type = typeof value;
          return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
        }
        function isLaziable(func) {
          var funcName = getFuncName(func), other = lodash2[funcName];
          if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
            return false;
          }
          if (func === other) {
            return true;
          }
          var data = getData(other);
          return !!data && func === data[0];
        }
        function isMasked(func) {
          return !!maskSrcKey && maskSrcKey in func;
        }
        var isMaskable = coreJsData ? isFunction : stubFalse;
        function isPrototype(value) {
          var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
          return value === proto;
        }
        function isStrictComparable(value) {
          return value === value && !isObject(value);
        }
        function matchesStrictComparable(key, srcValue) {
          return function(object) {
            if (object == null) {
              return false;
            }
            return object[key] === srcValue && (srcValue !== undefined2 || key in Object2(object));
          };
        }
        function memoizeCapped(func) {
          var result2 = memoize(func, function(key) {
            if (cache.size === MAX_MEMOIZE_SIZE) {
              cache.clear();
            }
            return key;
          });
          var cache = result2.cache;
          return result2;
        }
        function mergeData(data, source) {
          var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
          var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
          if (!(isCommon || isCombo)) {
            return data;
          }
          if (srcBitmask & WRAP_BIND_FLAG) {
            data[2] = source[2];
            newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
          }
          var value = source[3];
          if (value) {
            var partials = data[3];
            data[3] = partials ? composeArgs(partials, value, source[4]) : value;
            data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
          }
          value = source[5];
          if (value) {
            partials = data[5];
            data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
          }
          value = source[7];
          if (value) {
            data[7] = value;
          }
          if (srcBitmask & WRAP_ARY_FLAG) {
            data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
          }
          if (data[9] == null) {
            data[9] = source[9];
          }
          data[0] = source[0];
          data[1] = newBitmask;
          return data;
        }
        function nativeKeysIn(object) {
          var result2 = [];
          if (object != null) {
            for (var key in Object2(object)) {
              result2.push(key);
            }
          }
          return result2;
        }
        function objectToString(value) {
          return nativeObjectToString.call(value);
        }
        function overRest(func, start, transform2) {
          start = nativeMax(start === undefined2 ? func.length - 1 : start, 0);
          return function() {
            var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array2(length);
            while (++index < length) {
              array[index] = args[start + index];
            }
            index = -1;
            var otherArgs = Array2(start + 1);
            while (++index < start) {
              otherArgs[index] = args[index];
            }
            otherArgs[start] = transform2(array);
            return apply(func, this, otherArgs);
          };
        }
        function parent(object, path) {
          return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
        }
        function reorder(array, indexes) {
          var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
          while (length--) {
            var index = indexes[length];
            array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined2;
          }
          return array;
        }
        function safeGet(object, key) {
          if (key === "constructor" && typeof object[key] === "function") {
            return;
          }
          if (key == "__proto__") {
            return;
          }
          return object[key];
        }
        var setData = shortOut(baseSetData);
        var setTimeout = ctxSetTimeout || function(func, wait) {
          return root.setTimeout(func, wait);
        };
        var setToString = shortOut(baseSetToString);
        function setWrapToString(wrapper, reference, bitmask) {
          var source = reference + "";
          return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
        }
        function shortOut(func) {
          var count = 0, lastCalled = 0;
          return function() {
            var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
            lastCalled = stamp;
            if (remaining > 0) {
              if (++count >= HOT_COUNT) {
                return arguments[0];
              }
            } else {
              count = 0;
            }
            return func.apply(undefined2, arguments);
          };
        }
        function shuffleSelf(array, size2) {
          var index = -1, length = array.length, lastIndex = length - 1;
          size2 = size2 === undefined2 ? length : size2;
          while (++index < size2) {
            var rand = baseRandom(index, lastIndex), value = array[rand];
            array[rand] = array[index];
            array[index] = value;
          }
          array.length = size2;
          return array;
        }
        var stringToPath = memoizeCapped(function(string) {
          var result2 = [];
          if (string.charCodeAt(0) === 46) {
            result2.push("");
          }
          string.replace(rePropName, function(match, number, quote, subString) {
            result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
          });
          return result2;
        });
        function toKey(value) {
          if (typeof value == "string" || isSymbol(value)) {
            return value;
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function toSource(func) {
          if (func != null) {
            try {
              return funcToString.call(func);
            } catch (e) {
            }
            try {
              return func + "";
            } catch (e) {
            }
          }
          return "";
        }
        function updateWrapDetails(details, bitmask) {
          arrayEach(wrapFlags, function(pair) {
            var value = "_." + pair[0];
            if (bitmask & pair[1] && !arrayIncludes(details, value)) {
              details.push(value);
            }
          });
          return details.sort();
        }
        function wrapperClone(wrapper) {
          if (wrapper instanceof LazyWrapper) {
            return wrapper.clone();
          }
          var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
          result2.__actions__ = copyArray(wrapper.__actions__);
          result2.__index__ = wrapper.__index__;
          result2.__values__ = wrapper.__values__;
          return result2;
        }
        function chunk(array, size2, guard) {
          if (guard ? isIterateeCall(array, size2, guard) : size2 === undefined2) {
            size2 = 1;
          } else {
            size2 = nativeMax(toInteger(size2), 0);
          }
          var length = array == null ? 0 : array.length;
          if (!length || size2 < 1) {
            return [];
          }
          var index = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2));
          while (index < length) {
            result2[resIndex++] = baseSlice(array, index, index += size2);
          }
          return result2;
        }
        function compact(array) {
          var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
          while (++index < length) {
            var value = array[index];
            if (value) {
              result2[resIndex++] = value;
            }
          }
          return result2;
        }
        function concat() {
          var length = arguments.length;
          if (!length) {
            return [];
          }
          var args = Array2(length - 1), array = arguments[0], index = length;
          while (index--) {
            args[index - 1] = arguments[index];
          }
          return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
        }
        var difference = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
        });
        var differenceBy = baseRest(function(array, values2) {
          var iteratee2 = last(values2);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
        });
        var differenceWith = baseRest(function(array, values2) {
          var comparator = last(values2);
          if (isArrayLikeObject(comparator)) {
            comparator = undefined2;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined2, comparator) : [];
        });
        function drop(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          return baseSlice(array, n < 0 ? 0 : n, length);
        }
        function dropRight(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          n = length - n;
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function dropRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
        }
        function dropWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
        }
        function fill(array, value, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
            start = 0;
            end = length;
          }
          return baseFill(array, value, start, end);
        }
        function findIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index);
        }
        function findLastIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = length - 1;
          if (fromIndex !== undefined2) {
            index = toInteger(fromIndex);
            index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index, true);
        }
        function flatten(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, 1) : [];
        }
        function flattenDeep(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, INFINITY) : [];
        }
        function flattenDepth(array, depth) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(array, depth);
        }
        function fromPairs(pairs) {
          var index = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
          while (++index < length) {
            var pair = pairs[index];
            result2[pair[0]] = pair[1];
          }
          return result2;
        }
        function head(array) {
          return array && array.length ? array[0] : undefined2;
        }
        function indexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseIndexOf(array, value, index);
        }
        function initial(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 0, -1) : [];
        }
        var intersection = baseRest(function(arrays) {
          var mapped = arrayMap(arrays, castArrayLikeObject);
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
        });
        var intersectionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          if (iteratee2 === last(mapped)) {
            iteratee2 = undefined2;
          } else {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
        });
        var intersectionWith = baseRest(function(arrays) {
          var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          if (comparator) {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
        });
        function join10(array, separator) {
          return array == null ? "" : nativeJoin.call(array, separator);
        }
        function last(array) {
          var length = array == null ? 0 : array.length;
          return length ? array[length - 1] : undefined2;
        }
        function lastIndexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = length;
          if (fromIndex !== undefined2) {
            index = toInteger(fromIndex);
            index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
        }
        function nth(array, n) {
          return array && array.length ? baseNth(array, toInteger(n)) : undefined2;
        }
        var pull = baseRest(pullAll);
        function pullAll(array, values2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
        }
        function pullAllBy(array, values2, iteratee2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
        }
        function pullAllWith(array, values2, comparator) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined2, comparator) : array;
        }
        var pullAt = flatRest(function(array, indexes) {
          var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
          basePullAt(array, arrayMap(indexes, function(index) {
            return isIndex(index, length) ? +index : index;
          }).sort(compareAscending));
          return result2;
        });
        function remove(array, predicate) {
          var result2 = [];
          if (!(array && array.length)) {
            return result2;
          }
          var index = -1, indexes = [], length = array.length;
          predicate = getIteratee(predicate, 3);
          while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result2.push(value);
              indexes.push(index);
            }
          }
          basePullAt(array, indexes);
          return result2;
        }
        function reverse(array) {
          return array == null ? array : nativeReverse.call(array);
        }
        function slice(array, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
            start = 0;
            end = length;
          } else {
            start = start == null ? 0 : toInteger(start);
            end = end === undefined2 ? length : toInteger(end);
          }
          return baseSlice(array, start, end);
        }
        function sortedIndex(array, value) {
          return baseSortedIndex(array, value);
        }
        function sortedIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
        }
        function sortedIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value);
            if (index < length && eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedLastIndex(array, value) {
          return baseSortedIndex(array, value, true);
        }
        function sortedLastIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
        }
        function sortedLastIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value, true) - 1;
            if (eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedUniq(array) {
          return array && array.length ? baseSortedUniq(array) : [];
        }
        function sortedUniqBy(array, iteratee2) {
          return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function tail(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 1, length) : [];
        }
        function take(array, n, guard) {
          if (!(array && array.length)) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function takeRight(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          n = length - n;
          return baseSlice(array, n < 0 ? 0 : n, length);
        }
        function takeRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
        }
        function takeWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
        }
        var union2 = baseRest(function(arrays) {
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
        });
        var unionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
        });
        var unionWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);
        });
        function uniq(array) {
          return array && array.length ? baseUniq(array) : [];
        }
        function uniqBy(array, iteratee2) {
          return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function uniqWith(array, comparator) {
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return array && array.length ? baseUniq(array, undefined2, comparator) : [];
        }
        function unzip(array) {
          if (!(array && array.length)) {
            return [];
          }
          var length = 0;
          array = arrayFilter(array, function(group) {
            if (isArrayLikeObject(group)) {
              length = nativeMax(group.length, length);
              return true;
            }
          });
          return baseTimes(length, function(index) {
            return arrayMap(array, baseProperty(index));
          });
        }
        function unzipWith(array, iteratee2) {
          if (!(array && array.length)) {
            return [];
          }
          var result2 = unzip(array);
          if (iteratee2 == null) {
            return result2;
          }
          return arrayMap(result2, function(group) {
            return apply(iteratee2, undefined2, group);
          });
        }
        var without = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
        });
        var xor = baseRest(function(arrays) {
          return baseXor(arrayFilter(arrays, isArrayLikeObject));
        });
        var xorBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
        });
        var xorWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined2, comparator);
        });
        var zip = baseRest(unzip);
        function zipObject(props, values2) {
          return baseZipObject(props || [], values2 || [], assignValue);
        }
        function zipObjectDeep(props, values2) {
          return baseZipObject(props || [], values2 || [], baseSet);
        }
        var zipWith = baseRest(function(arrays) {
          var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined2;
          iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined2;
          return unzipWith(arrays, iteratee2);
        });
        function chain(value) {
          var result2 = lodash2(value);
          result2.__chain__ = true;
          return result2;
        }
        function tap(value, interceptor) {
          interceptor(value);
          return value;
        }
        function thru(value, interceptor) {
          return interceptor(value);
        }
        var wrapperAt = flatRest(function(paths) {
          var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
            return baseAt(object, paths);
          };
          if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
            return this.thru(interceptor);
          }
          value = value.slice(start, +start + (length ? 1 : 0));
          value.__actions__.push({
            "func": thru,
            "args": [interceptor],
            "thisArg": undefined2
          });
          return new LodashWrapper(value, this.__chain__).thru(function(array) {
            if (length && !array.length) {
              array.push(undefined2);
            }
            return array;
          });
        });
        function wrapperChain() {
          return chain(this);
        }
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__);
        }
        function wrapperNext() {
          if (this.__values__ === undefined2) {
            this.__values__ = toArray(this.value());
          }
          var done = this.__index__ >= this.__values__.length, value = done ? undefined2 : this.__values__[this.__index__++];
          return { "done": done, "value": value };
        }
        function wrapperToIterator() {
          return this;
        }
        function wrapperPlant(value) {
          var result2, parent2 = this;
          while (parent2 instanceof baseLodash) {
            var clone3 = wrapperClone(parent2);
            clone3.__index__ = 0;
            clone3.__values__ = undefined2;
            if (result2) {
              previous.__wrapped__ = clone3;
            } else {
              result2 = clone3;
            }
            var previous = clone3;
            parent2 = parent2.__wrapped__;
          }
          previous.__wrapped__ = value;
          return result2;
        }
        function wrapperReverse() {
          var value = this.__wrapped__;
          if (value instanceof LazyWrapper) {
            var wrapped = value;
            if (this.__actions__.length) {
              wrapped = new LazyWrapper(this);
            }
            wrapped = wrapped.reverse();
            wrapped.__actions__.push({
              "func": thru,
              "args": [reverse],
              "thisArg": undefined2
            });
            return new LodashWrapper(wrapped, this.__chain__);
          }
          return this.thru(reverse);
        }
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
        var countBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty.call(result2, key)) {
            ++result2[key];
          } else {
            baseAssignValue(result2, key, 1);
          }
        });
        function every(collection, predicate, guard) {
          var func = isArray(collection) ? arrayEvery : baseEvery;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        function filter(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, getIteratee(predicate, 3));
        }
        var find2 = createFind(findIndex);
        var findLast = createFind(findLastIndex);
        function flatMap(collection, iteratee2) {
          return baseFlatten(map2(collection, iteratee2), 1);
        }
        function flatMapDeep(collection, iteratee2) {
          return baseFlatten(map2(collection, iteratee2), INFINITY);
        }
        function flatMapDepth(collection, iteratee2, depth) {
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(map2(collection, iteratee2), depth);
        }
        function forEach(collection, iteratee2) {
          var func = isArray(collection) ? arrayEach : baseEach;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function forEachRight(collection, iteratee2) {
          var func = isArray(collection) ? arrayEachRight : baseEachRight;
          return func(collection, getIteratee(iteratee2, 3));
        }
        var groupBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty.call(result2, key)) {
            result2[key].push(value);
          } else {
            baseAssignValue(result2, key, [value]);
          }
        });
        function includes(collection, value, fromIndex, guard) {
          collection = isArrayLike(collection) ? collection : values(collection);
          fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
          var length = collection.length;
          if (fromIndex < 0) {
            fromIndex = nativeMax(length + fromIndex, 0);
          }
          return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
        }
        var invokeMap = baseRest(function(collection, path, args) {
          var index = -1, isFunc = typeof path == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value) {
            result2[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
          });
          return result2;
        });
        var keyBy = createAggregator(function(result2, value, key) {
          baseAssignValue(result2, key, value);
        });
        function map2(collection, iteratee2) {
          var func = isArray(collection) ? arrayMap : baseMap;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function orderBy(collection, iteratees, orders, guard) {
          if (collection == null) {
            return [];
          }
          if (!isArray(iteratees)) {
            iteratees = iteratees == null ? [] : [iteratees];
          }
          orders = guard ? undefined2 : orders;
          if (!isArray(orders)) {
            orders = orders == null ? [] : [orders];
          }
          return baseOrderBy(collection, iteratees, orders);
        }
        var partition = createAggregator(function(result2, value, key) {
          result2[key ? 0 : 1].push(value);
        }, function() {
          return [[], []];
        });
        function reduce(collection, iteratee2, accumulator) {
          var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
        }
        function reduceRight(collection, iteratee2, accumulator) {
          var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
        }
        function reject(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, negate(getIteratee(predicate, 3)));
        }
        function sample(collection) {
          var func = isArray(collection) ? arraySample : baseSample;
          return func(collection);
        }
        function sampleSize(collection, n, guard) {
          if (guard ? isIterateeCall(collection, n, guard) : n === undefined2) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          var func = isArray(collection) ? arraySampleSize : baseSampleSize;
          return func(collection, n);
        }
        function shuffle(collection) {
          var func = isArray(collection) ? arrayShuffle : baseShuffle;
          return func(collection);
        }
        function size(collection) {
          if (collection == null) {
            return 0;
          }
          if (isArrayLike(collection)) {
            return isString(collection) ? stringSize(collection) : collection.length;
          }
          var tag = getTag(collection);
          if (tag == mapTag || tag == setTag) {
            return collection.size;
          }
          return baseKeys(collection).length;
        }
        function some(collection, predicate, guard) {
          var func = isArray(collection) ? arraySome : baseSome;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        var sortBy = baseRest(function(collection, iteratees) {
          if (collection == null) {
            return [];
          }
          var length = iteratees.length;
          if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
            iteratees = [];
          } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
            iteratees = [iteratees[0]];
          }
          return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
        });
        var now = ctxNow || function() {
          return root.Date.now();
        };
        function after(n, func) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n < 1) {
              return func.apply(this, arguments);
            }
          };
        }
        function ary(func, n, guard) {
          n = guard ? undefined2 : n;
          n = func && n == null ? func.length : n;
          return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n);
        }
        function before(n, func) {
          var result2;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n > 0) {
              result2 = func.apply(this, arguments);
            }
            if (n <= 1) {
              func = undefined2;
            }
            return result2;
          };
        }
        var bind = baseRest(function(func, thisArg, partials) {
          var bitmask = WRAP_BIND_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bind));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(func, bitmask, thisArg, partials, holders);
        });
        var bindKey = baseRest(function(object, key, partials) {
          var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bindKey));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(key, bitmask, object, partials, holders);
        });
        function curry(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curry.placeholder;
          return result2;
        }
        function curryRight(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curryRight.placeholder;
          return result2;
        }
        function debounce(func, wait, options2) {
          var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          wait = toNumber2(wait) || 0;
          if (isObject(options2)) {
            leading = !!options2.leading;
            maxing = "maxWait" in options2;
            maxWait = maxing ? nativeMax(toNumber2(options2.maxWait) || 0, wait) : maxWait;
            trailing = "trailing" in options2 ? !!options2.trailing : trailing;
          }
          function invokeFunc(time) {
            var args = lastArgs, thisArg = lastThis;
            lastArgs = lastThis = undefined2;
            lastInvokeTime = time;
            result2 = func.apply(thisArg, args);
            return result2;
          }
          function leadingEdge(time) {
            lastInvokeTime = time;
            timerId = setTimeout(timerExpired, wait);
            return leading ? invokeFunc(time) : result2;
          }
          function remainingWait(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
            return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
          }
          function shouldInvoke(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
            return lastCallTime === undefined2 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
          }
          function timerExpired() {
            var time = now();
            if (shouldInvoke(time)) {
              return trailingEdge(time);
            }
            timerId = setTimeout(timerExpired, remainingWait(time));
          }
          function trailingEdge(time) {
            timerId = undefined2;
            if (trailing && lastArgs) {
              return invokeFunc(time);
            }
            lastArgs = lastThis = undefined2;
            return result2;
          }
          function cancel() {
            if (timerId !== undefined2) {
              clearTimeout(timerId);
            }
            lastInvokeTime = 0;
            lastArgs = lastCallTime = lastThis = timerId = undefined2;
          }
          function flush() {
            return timerId === undefined2 ? result2 : trailingEdge(now());
          }
          function debounced() {
            var time = now(), isInvoking = shouldInvoke(time);
            lastArgs = arguments;
            lastThis = this;
            lastCallTime = time;
            if (isInvoking) {
              if (timerId === undefined2) {
                return leadingEdge(lastCallTime);
              }
              if (maxing) {
                clearTimeout(timerId);
                timerId = setTimeout(timerExpired, wait);
                return invokeFunc(lastCallTime);
              }
            }
            if (timerId === undefined2) {
              timerId = setTimeout(timerExpired, wait);
            }
            return result2;
          }
          debounced.cancel = cancel;
          debounced.flush = flush;
          return debounced;
        }
        var defer = baseRest(function(func, args) {
          return baseDelay(func, 1, args);
        });
        var delay = baseRest(function(func, wait, args) {
          return baseDelay(func, toNumber2(wait) || 0, args);
        });
        function flip(func) {
          return createWrap(func, WRAP_FLIP_FLAG);
        }
        function memoize(func, resolver) {
          if (typeof func != "function" || resolver != null && typeof resolver != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var memoized = function() {
            var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
            if (cache.has(key)) {
              return cache.get(key);
            }
            var result2 = func.apply(this, args);
            memoized.cache = cache.set(key, result2) || cache;
            return result2;
          };
          memoized.cache = new (memoize.Cache || MapCache)();
          return memoized;
        }
        memoize.Cache = MapCache;
        function negate(predicate) {
          if (typeof predicate != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return !predicate.call(this);
              case 1:
                return !predicate.call(this, args[0]);
              case 2:
                return !predicate.call(this, args[0], args[1]);
              case 3:
                return !predicate.call(this, args[0], args[1], args[2]);
            }
            return !predicate.apply(this, args);
          };
        }
        function once(func) {
          return before(2, func);
        }
        var overArgs = castRest(function(func, transforms) {
          transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
          var funcsLength = transforms.length;
          return baseRest(function(args) {
            var index = -1, length = nativeMin(args.length, funcsLength);
            while (++index < length) {
              args[index] = transforms[index].call(this, args[index]);
            }
            return apply(func, this, args);
          });
        });
        var partial = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partial));
          return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
        });
        var partialRight = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partialRight));
          return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
        });
        var rearg = flatRest(function(func, indexes) {
          return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);
        });
        function rest(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start === undefined2 ? start : toInteger(start);
          return baseRest(func, start);
        }
        function spread(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start == null ? 0 : nativeMax(toInteger(start), 0);
          return baseRest(function(args) {
            var array = args[start], otherArgs = castSlice(args, 0, start);
            if (array) {
              arrayPush(otherArgs, array);
            }
            return apply(func, this, otherArgs);
          });
        }
        function throttle(func, wait, options2) {
          var leading = true, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          if (isObject(options2)) {
            leading = "leading" in options2 ? !!options2.leading : leading;
            trailing = "trailing" in options2 ? !!options2.trailing : trailing;
          }
          return debounce(func, wait, {
            "leading": leading,
            "maxWait": wait,
            "trailing": trailing
          });
        }
        function unary(func) {
          return ary(func, 1);
        }
        function wrap(value, wrapper) {
          return partial(castFunction(wrapper), value);
        }
        function castArray() {
          if (!arguments.length) {
            return [];
          }
          var value = arguments[0];
          return isArray(value) ? value : [value];
        }
        function clone2(value) {
          return baseClone(value, CLONE_SYMBOLS_FLAG);
        }
        function cloneWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
        }
        function cloneDeep2(value) {
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
        }
        function cloneDeepWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
        }
        function conformsTo(object, source) {
          return source == null || baseConformsTo(object, source, keys(source));
        }
        function eq(value, other) {
          return value === other || value !== value && other !== other;
        }
        var gt = createRelationalOperation(baseGt);
        var gte = createRelationalOperation(function(value, other) {
          return value >= other;
        });
        var isArguments = baseIsArguments(/* @__PURE__ */ (function() {
          return arguments;
        })()) ? baseIsArguments : function(value) {
          return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
        };
        var isArray = Array2.isArray;
        var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
        function isArrayLike(value) {
          return value != null && isLength(value.length) && !isFunction(value);
        }
        function isArrayLikeObject(value) {
          return isObjectLike(value) && isArrayLike(value);
        }
        function isBoolean(value) {
          return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
        }
        var isBuffer = nativeIsBuffer || stubFalse;
        var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
        function isElement(value) {
          return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
        }
        function isEmpty(value) {
          if (value == null) {
            return true;
          }
          if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
            return !value.length;
          }
          var tag = getTag(value);
          if (tag == mapTag || tag == setTag) {
            return !value.size;
          }
          if (isPrototype(value)) {
            return !baseKeys(value).length;
          }
          for (var key in value) {
            if (hasOwnProperty.call(value, key)) {
              return false;
            }
          }
          return true;
        }
        function isEqual2(value, other) {
          return baseIsEqual(value, other);
        }
        function isEqualWith(value, other, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          var result2 = customizer ? customizer(value, other) : undefined2;
          return result2 === undefined2 ? baseIsEqual(value, other, undefined2, customizer) : !!result2;
        }
        function isError(value) {
          if (!isObjectLike(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
        }
        function isFinite(value) {
          return typeof value == "number" && nativeIsFinite(value);
        }
        function isFunction(value) {
          if (!isObject(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
        }
        function isInteger(value) {
          return typeof value == "number" && value == toInteger(value);
        }
        function isLength(value) {
          return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        function isObject(value) {
          var type = typeof value;
          return value != null && (type == "object" || type == "function");
        }
        function isObjectLike(value) {
          return value != null && typeof value == "object";
        }
        var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
        function isMatch(object, source) {
          return object === source || baseIsMatch(object, source, getMatchData(source));
        }
        function isMatchWith(object, source, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseIsMatch(object, source, getMatchData(source), customizer);
        }
        function isNaN(value) {
          return isNumber(value) && value != +value;
        }
        function isNative(value) {
          if (isMaskable(value)) {
            throw new Error2(CORE_ERROR_TEXT);
          }
          return baseIsNative(value);
        }
        function isNull(value) {
          return value === null;
        }
        function isNil(value) {
          return value == null;
        }
        function isNumber(value) {
          return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
        }
        function isPlainObject(value) {
          if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
            return false;
          }
          var proto = getPrototype(value);
          if (proto === null) {
            return true;
          }
          var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
          return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
        }
        var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
        function isSafeInteger(value) {
          return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
        }
        var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
        function isString(value) {
          return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
        }
        function isSymbol(value) {
          return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
        }
        var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
        function isUndefined(value) {
          return value === undefined2;
        }
        function isWeakMap(value) {
          return isObjectLike(value) && getTag(value) == weakMapTag;
        }
        function isWeakSet(value) {
          return isObjectLike(value) && baseGetTag(value) == weakSetTag;
        }
        var lt = createRelationalOperation(baseLt);
        var lte = createRelationalOperation(function(value, other) {
          return value <= other;
        });
        function toArray(value) {
          if (!value) {
            return [];
          }
          if (isArrayLike(value)) {
            return isString(value) ? stringToArray(value) : copyArray(value);
          }
          if (symIterator && value[symIterator]) {
            return iteratorToArray(value[symIterator]());
          }
          var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
          return func(value);
        }
        function toFinite(value) {
          if (!value) {
            return value === 0 ? value : 0;
          }
          value = toNumber2(value);
          if (value === INFINITY || value === -INFINITY) {
            var sign = value < 0 ? -1 : 1;
            return sign * MAX_INTEGER;
          }
          return value === value ? value : 0;
        }
        function toInteger(value) {
          var result2 = toFinite(value), remainder = result2 % 1;
          return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
        }
        function toLength(value) {
          return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
        }
        function toNumber2(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          if (isObject(value)) {
            var other = typeof value.valueOf == "function" ? value.valueOf() : value;
            value = isObject(other) ? other + "" : other;
          }
          if (typeof value != "string") {
            return value === 0 ? value : +value;
          }
          value = baseTrim(value);
          var isBinary = reIsBinary.test(value);
          return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
        }
        function toPlainObject(value) {
          return copyObject(value, keysIn(value));
        }
        function toSafeInteger(value) {
          return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
        }
        function toString(value) {
          return value == null ? "" : baseToString(value);
        }
        var assign = createAssigner(function(object, source) {
          if (isPrototype(source) || isArrayLike(source)) {
            copyObject(source, keys(source), object);
            return;
          }
          for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
              assignValue(object, key, source[key]);
            }
          }
        });
        var assignIn = createAssigner(function(object, source) {
          copyObject(source, keysIn(source), object);
        });
        var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keysIn(source), object, customizer);
        });
        var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keys(source), object, customizer);
        });
        var at = flatRest(baseAt);
        function create(prototype, properties) {
          var result2 = baseCreate(prototype);
          return properties == null ? result2 : baseAssign(result2, properties);
        }
        var defaults2 = baseRest(function(object, sources) {
          object = Object2(object);
          var index = -1;
          var length = sources.length;
          var guard = length > 2 ? sources[2] : undefined2;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            length = 1;
          }
          while (++index < length) {
            var source = sources[index];
            var props = keysIn(source);
            var propsIndex = -1;
            var propsLength = props.length;
            while (++propsIndex < propsLength) {
              var key = props[propsIndex];
              var value = object[key];
              if (value === undefined2 || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
                object[key] = source[key];
              }
            }
          }
          return object;
        });
        var defaultsDeep = baseRest(function(args) {
          args.push(undefined2, customDefaultsMerge);
          return apply(mergeWith, undefined2, args);
        });
        function findKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
        }
        function findLastKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
        }
        function forIn(object, iteratee2) {
          return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forInRight(object, iteratee2) {
          return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forOwn(object, iteratee2) {
          return object && baseForOwn(object, getIteratee(iteratee2, 3));
        }
        function forOwnRight(object, iteratee2) {
          return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
        }
        function functions(object) {
          return object == null ? [] : baseFunctions(object, keys(object));
        }
        function functionsIn(object) {
          return object == null ? [] : baseFunctions(object, keysIn(object));
        }
        function get(object, path, defaultValue) {
          var result2 = object == null ? undefined2 : baseGet(object, path);
          return result2 === undefined2 ? defaultValue : result2;
        }
        function has(object, path) {
          return object != null && hasPath(object, path, baseHas);
        }
        function hasIn(object, path) {
          return object != null && hasPath(object, path, baseHasIn);
        }
        var invert = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          result2[value] = key;
        }, constant(identity));
        var invertBy = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          if (hasOwnProperty.call(result2, value)) {
            result2[value].push(key);
          } else {
            result2[value] = [key];
          }
        }, getIteratee);
        var invoke = baseRest(baseInvoke);
        function keys(object) {
          return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
        }
        function keysIn(object) {
          return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
        }
        function mapKeys(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, iteratee2(value, key, object2), value);
          });
          return result2;
        }
        function mapValues(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, key, iteratee2(value, key, object2));
          });
          return result2;
        }
        var merge2 = createAssigner(function(object, source, srcIndex) {
          baseMerge(object, source, srcIndex);
        });
        var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
          baseMerge(object, source, srcIndex, customizer);
        });
        var omit = flatRest(function(object, paths) {
          var result2 = {};
          if (object == null) {
            return result2;
          }
          var isDeep = false;
          paths = arrayMap(paths, function(path) {
            path = castPath(path, object);
            isDeep || (isDeep = path.length > 1);
            return path;
          });
          copyObject(object, getAllKeysIn(object), result2);
          if (isDeep) {
            result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
          }
          var length = paths.length;
          while (length--) {
            baseUnset(result2, paths[length]);
          }
          return result2;
        });
        function omitBy(object, predicate) {
          return pickBy(object, negate(getIteratee(predicate)));
        }
        var pick = flatRest(function(object, paths) {
          return object == null ? {} : basePick(object, paths);
        });
        function pickBy(object, predicate) {
          if (object == null) {
            return {};
          }
          var props = arrayMap(getAllKeysIn(object), function(prop) {
            return [prop];
          });
          predicate = getIteratee(predicate);
          return basePickBy(object, props, function(value, path) {
            return predicate(value, path[0]);
          });
        }
        function result(object, path, defaultValue) {
          path = castPath(path, object);
          var index = -1, length = path.length;
          if (!length) {
            length = 1;
            object = undefined2;
          }
          while (++index < length) {
            var value = object == null ? undefined2 : object[toKey(path[index])];
            if (value === undefined2) {
              index = length;
              value = defaultValue;
            }
            object = isFunction(value) ? value.call(object) : value;
          }
          return object;
        }
        function set(object, path, value) {
          return object == null ? object : baseSet(object, path, value);
        }
        function setWith(object, path, value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseSet(object, path, value, customizer);
        }
        var toPairs = createToPairs(keys);
        var toPairsIn = createToPairs(keysIn);
        function transform(object, iteratee2, accumulator) {
          var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
          iteratee2 = getIteratee(iteratee2, 4);
          if (accumulator == null) {
            var Ctor = object && object.constructor;
            if (isArrLike) {
              accumulator = isArr ? new Ctor() : [];
            } else if (isObject(object)) {
              accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
            } else {
              accumulator = {};
            }
          }
          (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object2) {
            return iteratee2(accumulator, value, index, object2);
          });
          return accumulator;
        }
        function unset(object, path) {
          return object == null ? true : baseUnset(object, path);
        }
        function update(object, path, updater) {
          return object == null ? object : baseUpdate(object, path, castFunction(updater));
        }
        function updateWith(object, path, updater, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
        }
        function values(object) {
          return object == null ? [] : baseValues(object, keys(object));
        }
        function valuesIn(object) {
          return object == null ? [] : baseValues(object, keysIn(object));
        }
        function clamp(number, lower, upper) {
          if (upper === undefined2) {
            upper = lower;
            lower = undefined2;
          }
          if (upper !== undefined2) {
            upper = toNumber2(upper);
            upper = upper === upper ? upper : 0;
          }
          if (lower !== undefined2) {
            lower = toNumber2(lower);
            lower = lower === lower ? lower : 0;
          }
          return baseClamp(toNumber2(number), lower, upper);
        }
        function inRange(number, start, end) {
          start = toFinite(start);
          if (end === undefined2) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          number = toNumber2(number);
          return baseInRange(number, start, end);
        }
        function random(lower, upper, floating) {
          if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
            upper = floating = undefined2;
          }
          if (floating === undefined2) {
            if (typeof upper == "boolean") {
              floating = upper;
              upper = undefined2;
            } else if (typeof lower == "boolean") {
              floating = lower;
              lower = undefined2;
            }
          }
          if (lower === undefined2 && upper === undefined2) {
            lower = 0;
            upper = 1;
          } else {
            lower = toFinite(lower);
            if (upper === undefined2) {
              upper = lower;
              lower = 0;
            } else {
              upper = toFinite(upper);
            }
          }
          if (lower > upper) {
            var temp = lower;
            lower = upper;
            upper = temp;
          }
          if (floating || lower % 1 || upper % 1) {
            var rand = nativeRandom();
            return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
          }
          return baseRandom(lower, upper);
        }
        var camelCase2 = createCompounder(function(result2, word, index) {
          word = word.toLowerCase();
          return result2 + (index ? capitalize(word) : word);
        });
        function capitalize(string) {
          return upperFirst(toString(string).toLowerCase());
        }
        function deburr(string) {
          string = toString(string);
          return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
        }
        function endsWith(string, target, position) {
          string = toString(string);
          target = baseToString(target);
          var length = string.length;
          position = position === undefined2 ? length : baseClamp(toInteger(position), 0, length);
          var end = position;
          position -= target.length;
          return position >= 0 && string.slice(position, end) == target;
        }
        function escape(string) {
          string = toString(string);
          return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
        }
        function escapeRegExp(string) {
          string = toString(string);
          return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
        }
        var kebabCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? "-" : "") + word.toLowerCase();
        });
        var lowerCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + word.toLowerCase();
        });
        var lowerFirst = createCaseFirst("toLowerCase");
        function pad(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          if (!length || strLength >= length) {
            return string;
          }
          var mid = (length - strLength) / 2;
          return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
        }
        function padEnd(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
        }
        function padStart(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
        }
        function parseInt2(string, radix, guard) {
          if (guard || radix == null) {
            radix = 0;
          } else if (radix) {
            radix = +radix;
          }
          return nativeParseInt(toString(string).replace(reTrimStart, ""), radix || 0);
        }
        function repeat(string, n, guard) {
          if (guard ? isIterateeCall(string, n, guard) : n === undefined2) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          return baseRepeat(toString(string), n);
        }
        function replace() {
          var args = arguments, string = toString(args[0]);
          return args.length < 3 ? string : string.replace(args[1], args[2]);
        }
        var snakeCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? "_" : "") + word.toLowerCase();
        });
        function split(string, separator, limit) {
          if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
            separator = limit = undefined2;
          }
          limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
          if (!limit) {
            return [];
          }
          string = toString(string);
          if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
            separator = baseToString(separator);
            if (!separator && hasUnicode(string)) {
              return castSlice(stringToArray(string), 0, limit);
            }
          }
          return string.split(separator, limit);
        }
        var startCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + upperFirst(word);
        });
        function startsWith(string, target, position) {
          string = toString(string);
          position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
          target = baseToString(target);
          return string.slice(position, position + target.length) == target;
        }
        function template(string, options2, guard) {
          var settings = lodash2.templateSettings;
          if (guard && isIterateeCall(string, options2, guard)) {
            options2 = undefined2;
          }
          string = toString(string);
          options2 = assignInWith({}, options2, settings, customDefaultsAssignIn);
          var imports = assignInWith({}, options2.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
          var isEscaping, isEvaluating, index = 0, interpolate = options2.interpolate || reNoMatch, source = "__p += '";
          var reDelimiters = RegExp2(
            (options2.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options2.evaluate || reNoMatch).source + "|$",
            "g"
          );
          var sourceURL = "//# sourceURL=" + (hasOwnProperty.call(options2, "sourceURL") ? (options2.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
          string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
            interpolateValue || (interpolateValue = esTemplateValue);
            source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
            if (escapeValue) {
              isEscaping = true;
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index = offset + match.length;
            return match;
          });
          source += "';\n";
          var variable = hasOwnProperty.call(options2, "variable") && options2.variable;
          if (!variable) {
            source = "with (obj) {\n" + source + "\n}\n";
          } else if (reForbiddenIdentifierChars.test(variable)) {
            throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
          }
          source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
          source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
          var result2 = attempt(function() {
            return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
          });
          result2.source = source;
          if (isError(result2)) {
            throw result2;
          }
          return result2;
        }
        function toLower(value) {
          return toString(value).toLowerCase();
        }
        function toUpper(value) {
          return toString(value).toUpperCase();
        }
        function trim(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return baseTrim(string);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
          return castSlice(strSymbols, start, end).join("");
        }
        function trimEnd(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return string.slice(0, trimmedEndIndex(string) + 1);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
          return castSlice(strSymbols, 0, end).join("");
        }
        function trimStart(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return string.replace(reTrimStart, "");
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
          return castSlice(strSymbols, start).join("");
        }
        function truncate(string, options2) {
          var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
          if (isObject(options2)) {
            var separator = "separator" in options2 ? options2.separator : separator;
            length = "length" in options2 ? toInteger(options2.length) : length;
            omission = "omission" in options2 ? baseToString(options2.omission) : omission;
          }
          string = toString(string);
          var strLength = string.length;
          if (hasUnicode(string)) {
            var strSymbols = stringToArray(string);
            strLength = strSymbols.length;
          }
          if (length >= strLength) {
            return string;
          }
          var end = length - stringSize(omission);
          if (end < 1) {
            return omission;
          }
          var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
          if (separator === undefined2) {
            return result2 + omission;
          }
          if (strSymbols) {
            end += result2.length - end;
          }
          if (isRegExp(separator)) {
            if (string.slice(end).search(separator)) {
              var match, substring = result2;
              if (!separator.global) {
                separator = RegExp2(separator.source, toString(reFlags.exec(separator)) + "g");
              }
              separator.lastIndex = 0;
              while (match = separator.exec(substring)) {
                var newEnd = match.index;
              }
              result2 = result2.slice(0, newEnd === undefined2 ? end : newEnd);
            }
          } else if (string.indexOf(baseToString(separator), end) != end) {
            var index = result2.lastIndexOf(separator);
            if (index > -1) {
              result2 = result2.slice(0, index);
            }
          }
          return result2 + omission;
        }
        function unescape(string) {
          string = toString(string);
          return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
        }
        var upperCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + word.toUpperCase();
        });
        var upperFirst = createCaseFirst("toUpperCase");
        function words(string, pattern, guard) {
          string = toString(string);
          pattern = guard ? undefined2 : pattern;
          if (pattern === undefined2) {
            return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
          }
          return string.match(pattern) || [];
        }
        var attempt = baseRest(function(func, args) {
          try {
            return apply(func, undefined2, args);
          } catch (e) {
            return isError(e) ? e : new Error2(e);
          }
        });
        var bindAll = flatRest(function(object, methodNames) {
          arrayEach(methodNames, function(key) {
            key = toKey(key);
            baseAssignValue(object, key, bind(object[key], object));
          });
          return object;
        });
        function cond(pairs) {
          var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
          pairs = !length ? [] : arrayMap(pairs, function(pair) {
            if (typeof pair[1] != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return [toIteratee(pair[0]), pair[1]];
          });
          return baseRest(function(args) {
            var index = -1;
            while (++index < length) {
              var pair = pairs[index];
              if (apply(pair[0], this, args)) {
                return apply(pair[1], this, args);
              }
            }
          });
        }
        function conforms(source) {
          return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
        }
        function constant(value) {
          return function() {
            return value;
          };
        }
        function defaultTo(value, defaultValue) {
          return value == null || value !== value ? defaultValue : value;
        }
        var flow = createFlow();
        var flowRight = createFlow(true);
        function identity(value) {
          return value;
        }
        function iteratee(func) {
          return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
        }
        function matches(source) {
          return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
        }
        function matchesProperty(path, srcValue) {
          return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
        }
        var method = baseRest(function(path, args) {
          return function(object) {
            return baseInvoke(object, path, args);
          };
        });
        var methodOf = baseRest(function(object, args) {
          return function(path) {
            return baseInvoke(object, path, args);
          };
        });
        function mixin(object, source, options2) {
          var props = keys(source), methodNames = baseFunctions(source, props);
          if (options2 == null && !(isObject(source) && (methodNames.length || !props.length))) {
            options2 = source;
            source = object;
            object = this;
            methodNames = baseFunctions(source, keys(source));
          }
          var chain2 = !(isObject(options2) && "chain" in options2) || !!options2.chain, isFunc = isFunction(object);
          arrayEach(methodNames, function(methodName) {
            var func = source[methodName];
            object[methodName] = func;
            if (isFunc) {
              object.prototype[methodName] = function() {
                var chainAll = this.__chain__;
                if (chain2 || chainAll) {
                  var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                  actions.push({ "func": func, "args": arguments, "thisArg": object });
                  result2.__chain__ = chainAll;
                  return result2;
                }
                return func.apply(object, arrayPush([this.value()], arguments));
              };
            }
          });
          return object;
        }
        function noConflict() {
          if (root._ === this) {
            root._ = oldDash;
          }
          return this;
        }
        function noop() {
        }
        function nthArg(n) {
          n = toInteger(n);
          return baseRest(function(args) {
            return baseNth(args, n);
          });
        }
        var over = createOver(arrayMap);
        var overEvery = createOver(arrayEvery);
        var overSome = createOver(arraySome);
        function property(path) {
          return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
        }
        function propertyOf(object) {
          return function(path) {
            return object == null ? undefined2 : baseGet(object, path);
          };
        }
        var range = createRange();
        var rangeRight = createRange(true);
        function stubArray() {
          return [];
        }
        function stubFalse() {
          return false;
        }
        function stubObject() {
          return {};
        }
        function stubString() {
          return "";
        }
        function stubTrue() {
          return true;
        }
        function times(n, iteratee2) {
          n = toInteger(n);
          if (n < 1 || n > MAX_SAFE_INTEGER) {
            return [];
          }
          var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
          iteratee2 = getIteratee(iteratee2);
          n -= MAX_ARRAY_LENGTH;
          var result2 = baseTimes(length, iteratee2);
          while (++index < n) {
            iteratee2(index);
          }
          return result2;
        }
        function toPath(value) {
          if (isArray(value)) {
            return arrayMap(value, toKey);
          }
          return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
        }
        function uniqueId(prefix) {
          var id = ++idCounter;
          return toString(prefix) + id;
        }
        var add = createMathOperation(function(augend, addend) {
          return augend + addend;
        }, 0);
        var ceil = createRound("ceil");
        var divide = createMathOperation(function(dividend, divisor) {
          return dividend / divisor;
        }, 1);
        var floor = createRound("floor");
        function max(array) {
          return array && array.length ? baseExtremum(array, identity, baseGt) : undefined2;
        }
        function maxBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined2;
        }
        function mean(array) {
          return baseMean(array, identity);
        }
        function meanBy(array, iteratee2) {
          return baseMean(array, getIteratee(iteratee2, 2));
        }
        function min(array) {
          return array && array.length ? baseExtremum(array, identity, baseLt) : undefined2;
        }
        function minBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined2;
        }
        var multiply = createMathOperation(function(multiplier, multiplicand) {
          return multiplier * multiplicand;
        }, 1);
        var round = createRound("round");
        var subtract = createMathOperation(function(minuend, subtrahend) {
          return minuend - subtrahend;
        }, 0);
        function sum(array) {
          return array && array.length ? baseSum(array, identity) : 0;
        }
        function sumBy(array, iteratee2) {
          return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
        }
        lodash2.after = after;
        lodash2.ary = ary;
        lodash2.assign = assign;
        lodash2.assignIn = assignIn;
        lodash2.assignInWith = assignInWith;
        lodash2.assignWith = assignWith;
        lodash2.at = at;
        lodash2.before = before;
        lodash2.bind = bind;
        lodash2.bindAll = bindAll;
        lodash2.bindKey = bindKey;
        lodash2.castArray = castArray;
        lodash2.chain = chain;
        lodash2.chunk = chunk;
        lodash2.compact = compact;
        lodash2.concat = concat;
        lodash2.cond = cond;
        lodash2.conforms = conforms;
        lodash2.constant = constant;
        lodash2.countBy = countBy;
        lodash2.create = create;
        lodash2.curry = curry;
        lodash2.curryRight = curryRight;
        lodash2.debounce = debounce;
        lodash2.defaults = defaults2;
        lodash2.defaultsDeep = defaultsDeep;
        lodash2.defer = defer;
        lodash2.delay = delay;
        lodash2.difference = difference;
        lodash2.differenceBy = differenceBy;
        lodash2.differenceWith = differenceWith;
        lodash2.drop = drop;
        lodash2.dropRight = dropRight;
        lodash2.dropRightWhile = dropRightWhile;
        lodash2.dropWhile = dropWhile;
        lodash2.fill = fill;
        lodash2.filter = filter;
        lodash2.flatMap = flatMap;
        lodash2.flatMapDeep = flatMapDeep;
        lodash2.flatMapDepth = flatMapDepth;
        lodash2.flatten = flatten;
        lodash2.flattenDeep = flattenDeep;
        lodash2.flattenDepth = flattenDepth;
        lodash2.flip = flip;
        lodash2.flow = flow;
        lodash2.flowRight = flowRight;
        lodash2.fromPairs = fromPairs;
        lodash2.functions = functions;
        lodash2.functionsIn = functionsIn;
        lodash2.groupBy = groupBy;
        lodash2.initial = initial;
        lodash2.intersection = intersection;
        lodash2.intersectionBy = intersectionBy;
        lodash2.intersectionWith = intersectionWith;
        lodash2.invert = invert;
        lodash2.invertBy = invertBy;
        lodash2.invokeMap = invokeMap;
        lodash2.iteratee = iteratee;
        lodash2.keyBy = keyBy;
        lodash2.keys = keys;
        lodash2.keysIn = keysIn;
        lodash2.map = map2;
        lodash2.mapKeys = mapKeys;
        lodash2.mapValues = mapValues;
        lodash2.matches = matches;
        lodash2.matchesProperty = matchesProperty;
        lodash2.memoize = memoize;
        lodash2.merge = merge2;
        lodash2.mergeWith = mergeWith;
        lodash2.method = method;
        lodash2.methodOf = methodOf;
        lodash2.mixin = mixin;
        lodash2.negate = negate;
        lodash2.nthArg = nthArg;
        lodash2.omit = omit;
        lodash2.omitBy = omitBy;
        lodash2.once = once;
        lodash2.orderBy = orderBy;
        lodash2.over = over;
        lodash2.overArgs = overArgs;
        lodash2.overEvery = overEvery;
        lodash2.overSome = overSome;
        lodash2.partial = partial;
        lodash2.partialRight = partialRight;
        lodash2.partition = partition;
        lodash2.pick = pick;
        lodash2.pickBy = pickBy;
        lodash2.property = property;
        lodash2.propertyOf = propertyOf;
        lodash2.pull = pull;
        lodash2.pullAll = pullAll;
        lodash2.pullAllBy = pullAllBy;
        lodash2.pullAllWith = pullAllWith;
        lodash2.pullAt = pullAt;
        lodash2.range = range;
        lodash2.rangeRight = rangeRight;
        lodash2.rearg = rearg;
        lodash2.reject = reject;
        lodash2.remove = remove;
        lodash2.rest = rest;
        lodash2.reverse = reverse;
        lodash2.sampleSize = sampleSize;
        lodash2.set = set;
        lodash2.setWith = setWith;
        lodash2.shuffle = shuffle;
        lodash2.slice = slice;
        lodash2.sortBy = sortBy;
        lodash2.sortedUniq = sortedUniq;
        lodash2.sortedUniqBy = sortedUniqBy;
        lodash2.split = split;
        lodash2.spread = spread;
        lodash2.tail = tail;
        lodash2.take = take;
        lodash2.takeRight = takeRight;
        lodash2.takeRightWhile = takeRightWhile;
        lodash2.takeWhile = takeWhile;
        lodash2.tap = tap;
        lodash2.throttle = throttle;
        lodash2.thru = thru;
        lodash2.toArray = toArray;
        lodash2.toPairs = toPairs;
        lodash2.toPairsIn = toPairsIn;
        lodash2.toPath = toPath;
        lodash2.toPlainObject = toPlainObject;
        lodash2.transform = transform;
        lodash2.unary = unary;
        lodash2.union = union2;
        lodash2.unionBy = unionBy;
        lodash2.unionWith = unionWith;
        lodash2.uniq = uniq;
        lodash2.uniqBy = uniqBy;
        lodash2.uniqWith = uniqWith;
        lodash2.unset = unset;
        lodash2.unzip = unzip;
        lodash2.unzipWith = unzipWith;
        lodash2.update = update;
        lodash2.updateWith = updateWith;
        lodash2.values = values;
        lodash2.valuesIn = valuesIn;
        lodash2.without = without;
        lodash2.words = words;
        lodash2.wrap = wrap;
        lodash2.xor = xor;
        lodash2.xorBy = xorBy;
        lodash2.xorWith = xorWith;
        lodash2.zip = zip;
        lodash2.zipObject = zipObject;
        lodash2.zipObjectDeep = zipObjectDeep;
        lodash2.zipWith = zipWith;
        lodash2.entries = toPairs;
        lodash2.entriesIn = toPairsIn;
        lodash2.extend = assignIn;
        lodash2.extendWith = assignInWith;
        mixin(lodash2, lodash2);
        lodash2.add = add;
        lodash2.attempt = attempt;
        lodash2.camelCase = camelCase2;
        lodash2.capitalize = capitalize;
        lodash2.ceil = ceil;
        lodash2.clamp = clamp;
        lodash2.clone = clone2;
        lodash2.cloneDeep = cloneDeep2;
        lodash2.cloneDeepWith = cloneDeepWith;
        lodash2.cloneWith = cloneWith;
        lodash2.conformsTo = conformsTo;
        lodash2.deburr = deburr;
        lodash2.defaultTo = defaultTo;
        lodash2.divide = divide;
        lodash2.endsWith = endsWith;
        lodash2.eq = eq;
        lodash2.escape = escape;
        lodash2.escapeRegExp = escapeRegExp;
        lodash2.every = every;
        lodash2.find = find2;
        lodash2.findIndex = findIndex;
        lodash2.findKey = findKey;
        lodash2.findLast = findLast;
        lodash2.findLastIndex = findLastIndex;
        lodash2.findLastKey = findLastKey;
        lodash2.floor = floor;
        lodash2.forEach = forEach;
        lodash2.forEachRight = forEachRight;
        lodash2.forIn = forIn;
        lodash2.forInRight = forInRight;
        lodash2.forOwn = forOwn;
        lodash2.forOwnRight = forOwnRight;
        lodash2.get = get;
        lodash2.gt = gt;
        lodash2.gte = gte;
        lodash2.has = has;
        lodash2.hasIn = hasIn;
        lodash2.head = head;
        lodash2.identity = identity;
        lodash2.includes = includes;
        lodash2.indexOf = indexOf;
        lodash2.inRange = inRange;
        lodash2.invoke = invoke;
        lodash2.isArguments = isArguments;
        lodash2.isArray = isArray;
        lodash2.isArrayBuffer = isArrayBuffer;
        lodash2.isArrayLike = isArrayLike;
        lodash2.isArrayLikeObject = isArrayLikeObject;
        lodash2.isBoolean = isBoolean;
        lodash2.isBuffer = isBuffer;
        lodash2.isDate = isDate;
        lodash2.isElement = isElement;
        lodash2.isEmpty = isEmpty;
        lodash2.isEqual = isEqual2;
        lodash2.isEqualWith = isEqualWith;
        lodash2.isError = isError;
        lodash2.isFinite = isFinite;
        lodash2.isFunction = isFunction;
        lodash2.isInteger = isInteger;
        lodash2.isLength = isLength;
        lodash2.isMap = isMap;
        lodash2.isMatch = isMatch;
        lodash2.isMatchWith = isMatchWith;
        lodash2.isNaN = isNaN;
        lodash2.isNative = isNative;
        lodash2.isNil = isNil;
        lodash2.isNull = isNull;
        lodash2.isNumber = isNumber;
        lodash2.isObject = isObject;
        lodash2.isObjectLike = isObjectLike;
        lodash2.isPlainObject = isPlainObject;
        lodash2.isRegExp = isRegExp;
        lodash2.isSafeInteger = isSafeInteger;
        lodash2.isSet = isSet;
        lodash2.isString = isString;
        lodash2.isSymbol = isSymbol;
        lodash2.isTypedArray = isTypedArray;
        lodash2.isUndefined = isUndefined;
        lodash2.isWeakMap = isWeakMap;
        lodash2.isWeakSet = isWeakSet;
        lodash2.join = join10;
        lodash2.kebabCase = kebabCase;
        lodash2.last = last;
        lodash2.lastIndexOf = lastIndexOf;
        lodash2.lowerCase = lowerCase;
        lodash2.lowerFirst = lowerFirst;
        lodash2.lt = lt;
        lodash2.lte = lte;
        lodash2.max = max;
        lodash2.maxBy = maxBy;
        lodash2.mean = mean;
        lodash2.meanBy = meanBy;
        lodash2.min = min;
        lodash2.minBy = minBy;
        lodash2.stubArray = stubArray;
        lodash2.stubFalse = stubFalse;
        lodash2.stubObject = stubObject;
        lodash2.stubString = stubString;
        lodash2.stubTrue = stubTrue;
        lodash2.multiply = multiply;
        lodash2.nth = nth;
        lodash2.noConflict = noConflict;
        lodash2.noop = noop;
        lodash2.now = now;
        lodash2.pad = pad;
        lodash2.padEnd = padEnd;
        lodash2.padStart = padStart;
        lodash2.parseInt = parseInt2;
        lodash2.random = random;
        lodash2.reduce = reduce;
        lodash2.reduceRight = reduceRight;
        lodash2.repeat = repeat;
        lodash2.replace = replace;
        lodash2.result = result;
        lodash2.round = round;
        lodash2.runInContext = runInContext2;
        lodash2.sample = sample;
        lodash2.size = size;
        lodash2.snakeCase = snakeCase;
        lodash2.some = some;
        lodash2.sortedIndex = sortedIndex;
        lodash2.sortedIndexBy = sortedIndexBy;
        lodash2.sortedIndexOf = sortedIndexOf;
        lodash2.sortedLastIndex = sortedLastIndex;
        lodash2.sortedLastIndexBy = sortedLastIndexBy;
        lodash2.sortedLastIndexOf = sortedLastIndexOf;
        lodash2.startCase = startCase;
        lodash2.startsWith = startsWith;
        lodash2.subtract = subtract;
        lodash2.sum = sum;
        lodash2.sumBy = sumBy;
        lodash2.template = template;
        lodash2.times = times;
        lodash2.toFinite = toFinite;
        lodash2.toInteger = toInteger;
        lodash2.toLength = toLength;
        lodash2.toLower = toLower;
        lodash2.toNumber = toNumber2;
        lodash2.toSafeInteger = toSafeInteger;
        lodash2.toString = toString;
        lodash2.toUpper = toUpper;
        lodash2.trim = trim;
        lodash2.trimEnd = trimEnd;
        lodash2.trimStart = trimStart;
        lodash2.truncate = truncate;
        lodash2.unescape = unescape;
        lodash2.uniqueId = uniqueId;
        lodash2.upperCase = upperCase;
        lodash2.upperFirst = upperFirst;
        lodash2.each = forEach;
        lodash2.eachRight = forEachRight;
        lodash2.first = head;
        mixin(lodash2, (function() {
          var source = {};
          baseForOwn(lodash2, function(func, methodName) {
            if (!hasOwnProperty.call(lodash2.prototype, methodName)) {
              source[methodName] = func;
            }
          });
          return source;
        })(), { "chain": false });
        lodash2.VERSION = VERSION;
        arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
          lodash2[methodName].placeholder = lodash2;
        });
        arrayEach(["drop", "take"], function(methodName, index) {
          LazyWrapper.prototype[methodName] = function(n) {
            n = n === undefined2 ? 1 : nativeMax(toInteger(n), 0);
            var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
            if (result2.__filtered__) {
              result2.__takeCount__ = nativeMin(n, result2.__takeCount__);
            } else {
              result2.__views__.push({
                "size": nativeMin(n, MAX_ARRAY_LENGTH),
                "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
              });
            }
            return result2;
          };
          LazyWrapper.prototype[methodName + "Right"] = function(n) {
            return this.reverse()[methodName](n).reverse();
          };
        });
        arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
          var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
          LazyWrapper.prototype[methodName] = function(iteratee2) {
            var result2 = this.clone();
            result2.__iteratees__.push({
              "iteratee": getIteratee(iteratee2, 3),
              "type": type
            });
            result2.__filtered__ = result2.__filtered__ || isFilter;
            return result2;
          };
        });
        arrayEach(["head", "last"], function(methodName, index) {
          var takeName = "take" + (index ? "Right" : "");
          LazyWrapper.prototype[methodName] = function() {
            return this[takeName](1).value()[0];
          };
        });
        arrayEach(["initial", "tail"], function(methodName, index) {
          var dropName = "drop" + (index ? "" : "Right");
          LazyWrapper.prototype[methodName] = function() {
            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
          };
        });
        LazyWrapper.prototype.compact = function() {
          return this.filter(identity);
        };
        LazyWrapper.prototype.find = function(predicate) {
          return this.filter(predicate).head();
        };
        LazyWrapper.prototype.findLast = function(predicate) {
          return this.reverse().find(predicate);
        };
        LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
          if (typeof path == "function") {
            return new LazyWrapper(this);
          }
          return this.map(function(value) {
            return baseInvoke(value, path, args);
          });
        });
        LazyWrapper.prototype.reject = function(predicate) {
          return this.filter(negate(getIteratee(predicate)));
        };
        LazyWrapper.prototype.slice = function(start, end) {
          start = toInteger(start);
          var result2 = this;
          if (result2.__filtered__ && (start > 0 || end < 0)) {
            return new LazyWrapper(result2);
          }
          if (start < 0) {
            result2 = result2.takeRight(-start);
          } else if (start) {
            result2 = result2.drop(start);
          }
          if (end !== undefined2) {
            end = toInteger(end);
            result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
          }
          return result2;
        };
        LazyWrapper.prototype.takeRightWhile = function(predicate) {
          return this.reverse().takeWhile(predicate).reverse();
        };
        LazyWrapper.prototype.toArray = function() {
          return this.take(MAX_ARRAY_LENGTH);
        };
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash2[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
          if (!lodashFunc) {
            return;
          }
          lodash2.prototype[methodName] = function() {
            var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray(value);
            var interceptor = function(value2) {
              var result3 = lodashFunc.apply(lodash2, arrayPush([value2], args));
              return isTaker && chainAll ? result3[0] : result3;
            };
            if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
              isLazy = useLazy = false;
            }
            var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
            if (!retUnwrapped && useLazy) {
              value = onlyLazy ? value : new LazyWrapper(this);
              var result2 = func.apply(value, args);
              result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined2 });
              return new LodashWrapper(result2, chainAll);
            }
            if (isUnwrapped && onlyLazy) {
              return func.apply(this, args);
            }
            result2 = this.thru(interceptor);
            return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
          };
        });
        arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
          var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
          lodash2.prototype[methodName] = function() {
            var args = arguments;
            if (retUnwrapped && !this.__chain__) {
              var value = this.value();
              return func.apply(isArray(value) ? value : [], args);
            }
            return this[chainName](function(value2) {
              return func.apply(isArray(value2) ? value2 : [], args);
            });
          };
        });
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var lodashFunc = lodash2[methodName];
          if (lodashFunc) {
            var key = lodashFunc.name + "";
            if (!hasOwnProperty.call(realNames, key)) {
              realNames[key] = [];
            }
            realNames[key].push({ "name": methodName, "func": lodashFunc });
          }
        });
        realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
          "name": "wrapper",
          "func": undefined2
        }];
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;
        lodash2.prototype.at = wrapperAt;
        lodash2.prototype.chain = wrapperChain;
        lodash2.prototype.commit = wrapperCommit;
        lodash2.prototype.next = wrapperNext;
        lodash2.prototype.plant = wrapperPlant;
        lodash2.prototype.reverse = wrapperReverse;
        lodash2.prototype.toJSON = lodash2.prototype.valueOf = lodash2.prototype.value = wrapperValue;
        lodash2.prototype.first = lodash2.prototype.head;
        if (symIterator) {
          lodash2.prototype[symIterator] = wrapperToIterator;
        }
        return lodash2;
      });
      var _ = runInContext();
      if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        root._ = _;
        define(function() {
          return _;
        });
      } else if (freeModule) {
        (freeModule.exports = _)._ = _;
        freeExports._ = _;
      } else {
        root._ = _;
      }
    }).call(exports2);
  }
});

// ../reporter/src/console-reporter.ts
import { writeFile } from "node:fs/promises";
import { blue, gray, green, red, yellow, yellowBright } from "colorette";

// ../reporter/src/constants.ts
import { readFileSync } from "node:fs";
import { createRequire } from "node:module";
import { dirname, join } from "node:path";
var require2 = createRequire(import.meta.url);
function resolveWorkspacePackageJson() {
  try {
    return require2.resolve("../../../package.json");
  } catch {
    try {
      const currentPackageJson = require2.resolve("@ts-for-gir/reporter/package.json");
      return join(dirname(dirname(currentPackageJson)), "package.json");
    } catch {
      throw new Error("Unable to resolve workspace package.json path");
    }
  }
}
function readWorkspacePackage() {
  try {
    const packagePath = resolveWorkspacePackageJson();
    const content = readFileSync(packagePath, "utf-8");
    return JSON.parse(content);
  } catch (error) {
    const message = error instanceof Error ? error.message : "Unknown error";
    throw new Error(`Failed to read workspace package.json: ${message}`);
  }
}
var WORKSPACE_PACKAGE = readWorkspacePackage();
var REPORTER_VERSION = WORKSPACE_PACKAGE.version;
var PACKAGE_NAME = WORKSPACE_PACKAGE.name;
var PACKAGE_DESCRIPTION = WORKSPACE_PACKAGE.description;

// ../reporter/src/types/problem.ts
var ProblemSeverity = /* @__PURE__ */ ((ProblemSeverity2) => {
  ProblemSeverity2["DEBUG"] = "debug";
  ProblemSeverity2["INFO"] = "info";
  ProblemSeverity2["WARNING"] = "warning";
  ProblemSeverity2["ERROR"] = "error";
  ProblemSeverity2["CRITICAL"] = "critical";
  return ProblemSeverity2;
})(ProblemSeverity || {});
var ProblemCategory = /* @__PURE__ */ ((ProblemCategory2) => {
  ProblemCategory2["TYPE_RESOLUTION"] = "type_resolution";
  ProblemCategory2["PARSING_FAILURE"] = "parsing_failure";
  ProblemCategory2["GENERATION_FAILURE"] = "generation_failure";
  ProblemCategory2["TYPE_CONFLICT"] = "type_conflict";
  ProblemCategory2["DEPENDENCY_ISSUE"] = "dependency_issue";
  ProblemCategory2["CONFIGURATION"] = "configuration";
  ProblemCategory2["IO_ERROR"] = "io_error";
  ProblemCategory2["GENERAL"] = "general";
  return ProblemCategory2;
})(ProblemCategory || {});

// ../reporter/src/message-analyzer.ts
function analyzeWarning(message, args) {
  const details = args && args.length > 0 ? JSON.stringify(args) : void 0;
  if (message.includes("Attempting to fall back on c:type inference") || message.includes("Falling back on c:type inference")) {
    const matches = message.match(/for\s+(\w+)\.(\w+)/);
    if (matches) {
      const [, namespace, typeName] = matches;
      return {
        severity: "warning" /* WARNING */,
        category: "type_resolution" /* TYPE_RESOLUTION */,
        typeName,
        namespace,
        details,
        metadata: { inferenceType: "c:type", namespace, typeName }
      };
    }
  }
  if (message.includes("Type conflict")) {
    const conflictMatch = message.match(/Type conflict \((\w+)\):\s*(\w+)/);
    if (conflictMatch) {
      const [, conflictType, elementName] = conflictMatch;
      const detailsMatch = message.match(/Conflict with (.+)$/);
      const conflictDetails = detailsMatch ? detailsMatch[1] : void 0;
      return {
        severity: "warning" /* WARNING */,
        category: "type_conflict" /* TYPE_CONFLICT */,
        typeName: elementName,
        details: conflictDetails || details,
        metadata: { conflictType, elementName }
      };
    }
  }
  return {
    severity: "warning" /* WARNING */,
    category: "general" /* GENERAL */,
    details
  };
}
function analyzeError(message, args) {
  const details = args && args.length > 0 ? JSON.stringify(args) : void 0;
  if (message.includes("Unable to resolve type") || message.includes("could not be resolved")) {
    const unresolvedMatch = message.match(/Unable to resolve type (\w+) in same namespace (\w+)!/);
    if (unresolvedMatch) {
      const [, typeName, namespace] = unresolvedMatch;
      return {
        severity: "error" /* ERROR */,
        category: "type_resolution" /* TYPE_RESOLUTION */,
        typeName,
        namespace,
        details,
        metadata: { namespace, typeName, resolutionType: "same_namespace" }
      };
    }
    const couldNotResolveMatch = message.match(/Type (\w+) could not be resolved in (\w+)/);
    if (couldNotResolveMatch) {
      const [, typeName, context] = couldNotResolveMatch;
      const namespaceMatch = context.match(/(\w+)\s+[\d.]+/);
      const namespace = namespaceMatch ? namespaceMatch[1] : context;
      return {
        severity: "error" /* ERROR */,
        category: "type_resolution" /* TYPE_RESOLUTION */,
        typeName,
        namespace,
        details,
        metadata: { namespace, typeName, context }
      };
    }
  }
  if (message.includes("Failed to parse")) {
    const parseMatch = message.match(/Failed to parse (\w+):\s*(.+)/);
    if (parseMatch) {
      const [, itemType, itemName] = parseMatch;
      return {
        severity: "error" /* ERROR */,
        category: "parsing_failure" /* PARSING_FAILURE */,
        typeName: itemName,
        details: args && args.length > 0 ? String(args[0]) : message,
        metadata: { itemType, itemName }
      };
    }
  }
  if (message.includes("Failed to generate")) {
    const genMatch = message.match(/Failed to generate (.+):\s*(.+)/);
    if (genMatch) {
      const [, context, namespace] = genMatch;
      return {
        severity: "error" /* ERROR */,
        category: "generation_failure" /* GENERATION_FAILURE */,
        namespace,
        details: args && args.length > 0 ? String(args[0]) : message,
        metadata: { context, namespace }
      };
    }
  }
  return {
    severity: "error" /* ERROR */,
    category: "general" /* GENERAL */,
    details
  };
}

// ../reporter/src/reporter-base.ts
var ReporterBase = class {
  config;
  problems = [];
  startTime = /* @__PURE__ */ new Date();
  problemIdCounter = 0;
  constructor(config) {
    this.config = config;
  }
  /**
   * Generate a unique problem ID
   */
  generateProblemId() {
    return `${this.config.moduleName}_${Date.now()}_${++this.problemIdCounter}`;
  }
  /**
   * Add a problem to the report
   */
  addProblem(severity, category, message, details, typeName, location, metadata) {
    if (!this.config.enabled) {
      return;
    }
    const problem = {
      id: this.generateProblemId(),
      severity,
      category,
      module: this.config.moduleName,
      message,
      details,
      typeName,
      location,
      timestamp: /* @__PURE__ */ new Date(),
      metadata
    };
    this.problems.push(problem);
  }
  /**
   * Get current problem count
   */
  getProblemCount() {
    return this.problems.length;
  }
  /**
   * Get problems by category
   */
  getProblemsByCategory(category) {
    return this.problems.filter((p) => p.category === category);
  }
  /**
   * Get problems by severity
   */
  getProblemsBySeverity(severity) {
    return this.problems.filter((p) => p.severity === severity);
  }
  /**
   * Get all problems
   */
  getProblems() {
    return [...this.problems];
  }
};

// ../reporter/src/console-reporter.ts
var ConsoleReporter = class _ConsoleReporter extends ReporterBase {
  constructor(configOrVerbose, moduleName, reporterEnabled = false, outputPath) {
    let config;
    if (typeof configOrVerbose === "boolean") {
      config = {
        enabled: reporterEnabled,
        verbose: configOrVerbose,
        moduleName: moduleName || "Unknown",
        outputPath
      };
    } else {
      config = configOrVerbose;
    }
    super(config);
  }
  // === Logger compatibility methods ===
  log(...args) {
    if (!this.config.verbose) {
      return;
    }
    console.log(...args);
  }
  dir(...args) {
    if (!this.config.verbose) {
      return;
    }
    args.forEach((arg) => {
      console.dir(arg);
    });
  }
  info(txt, ...args) {
    if (!this.config.verbose) {
      return;
    }
    console.info(blue(txt), ...args);
  }
  warn(txt, ...args) {
    if (this.config.enabled) {
      const analyzed = analyzeWarning(txt, args);
      if (analyzed) {
        this.addProblem(
          analyzed.severity,
          analyzed.category,
          txt,
          analyzed.details,
          analyzed.typeName,
          analyzed.namespace || this.config.moduleName,
          analyzed.metadata
        );
      }
    }
    if (!this.config.verbose) {
      return;
    }
    const formattedTxt = this.prependInfo(txt, "WARN:");
    console.warn(yellow(formattedTxt), ...args);
  }
  debug(txt, ...args) {
    if (!this.config.verbose) {
      return;
    }
    const formattedTxt = this.prependInfo(txt, "DEBUG:");
    console.debug(yellowBright(formattedTxt), ...args);
  }
  error(txt, ...args) {
    if (this.config.enabled) {
      const analyzed = analyzeError(txt, args);
      if (analyzed) {
        this.addProblem(
          analyzed.severity,
          analyzed.category,
          txt,
          analyzed.details,
          analyzed.typeName,
          analyzed.namespace || this.config.moduleName,
          analyzed.metadata
        );
      }
    }
    const formattedTxt = this.prependInfo(txt, "ERROR:");
    this.danger(formattedTxt, ...args);
  }
  success(txt, ...args) {
    if (!this.config.verbose) {
      return;
    }
    this.log(green(txt), ...args);
  }
  danger(txt, ...args) {
    console.error(red(txt), ...args);
  }
  muted(txt, ...args) {
    this.log(gray(txt), ...args);
  }
  white(txt, ...args) {
    this.log(txt, ...args);
  }
  yellow(txt, ...args) {
    this.log(yellow(txt), ...args);
  }
  gray(txt, ...args) {
    this.log(gray(txt), ...args);
  }
  // === Problem-specific reporting methods ===
  reportTypeResolutionError(typeName, namespace, message, details) {
    this.addProblem("error" /* ERROR */, "type_resolution" /* TYPE_RESOLUTION */, message, details, typeName, namespace, {
      namespace,
      typeName
    });
    if (this.config.verbose) {
      const txt = this.prependInfo(message, "ERROR:");
      console.error(red(txt));
    }
  }
  reportTypeResolutionWarning(typeName, namespace, message, details) {
    this.addProblem("warning" /* WARNING */, "type_resolution" /* TYPE_RESOLUTION */, message, details, typeName, namespace, {
      namespace,
      typeName
    });
    if (this.config.verbose) {
      const txt = this.prependInfo(message, "WARN:");
      console.warn(yellow(txt));
    }
  }
  reportParsingFailure(itemName, itemType, namespace, error) {
    const message = `Failed to parse ${itemType}: ${itemName}`;
    const details = error instanceof Error ? error.message : error;
    this.addProblem("error" /* ERROR */, "parsing_failure" /* PARSING_FAILURE */, message, details, itemName, namespace, {
      itemType,
      namespace,
      error: details
    });
    if (this.config.verbose) {
      const txt = this.prependInfo(message, "ERROR:");
      console.error(red(txt), details);
    }
  }
  reportGenerationFailure(namespace, error, context) {
    const message = `Failed to generate ${context || "namespace"}: ${namespace}`;
    const details = error instanceof Error ? error.message : error;
    this.addProblem("error" /* ERROR */, "generation_failure" /* GENERATION_FAILURE */, message, details, void 0, namespace, {
      namespace,
      context,
      error: details
    });
    if (this.config.verbose) {
      const txt = this.prependInfo(message, "ERROR:");
      console.error(red(txt), details);
    }
  }
  reportTypeConflict(conflictType, elementName, namespace, details) {
    const message = `Type conflict (${conflictType}): ${elementName}`;
    this.addProblem("warning" /* WARNING */, "type_conflict" /* TYPE_CONFLICT */, message, details, elementName, namespace, {
      conflictType,
      namespace
    });
    if (this.config.verbose) {
      const txt = this.prependInfo(message, "WARN:");
      console.warn(yellow(txt), details || "");
    }
  }
  reportDependencyIssue(dependencyName, issue, details) {
    const message = `Dependency issue: ${dependencyName} - ${issue}`;
    this.addProblem(
      "warning" /* WARNING */,
      "dependency_issue" /* DEPENDENCY_ISSUE */,
      message,
      details,
      dependencyName,
      this.config.moduleName,
      { dependencyName, issue }
    );
    if (this.config.verbose) {
      this.warn(message, details);
    }
  }
  // === Report generation methods ===
  generateStatistics() {
    const bySeverity = Object.values(ProblemSeverity).reduce(
      (acc, severity) => {
        acc[severity] = 0;
        return acc;
      },
      {}
    );
    const byCategory = Object.values(ProblemCategory).reduce(
      (acc, category) => {
        acc[category] = 0;
        return acc;
      },
      {}
    );
    const byModule = {};
    const unresolvedTypes = {};
    const typeConflicts = {};
    const namespaceProblems = {};
    for (const problem of this.problems) {
      bySeverity[problem.severity]++;
      byCategory[problem.category]++;
      byModule[problem.module] = (byModule[problem.module] || 0) + 1;
      if (problem.category === "type_resolution" /* TYPE_RESOLUTION */ && problem.typeName) {
        if (!unresolvedTypes[problem.typeName]) {
          unresolvedTypes[problem.typeName] = { count: 0, namespaces: /* @__PURE__ */ new Set() };
        }
        unresolvedTypes[problem.typeName].count++;
        if (problem.location) {
          unresolvedTypes[problem.typeName].namespaces.add(problem.location);
        }
        if (problem.location) {
          if (!namespaceProblems[problem.location]) {
            namespaceProblems[problem.location] = { count: 0, types: /* @__PURE__ */ new Set() };
          }
          namespaceProblems[problem.location].count++;
          namespaceProblems[problem.location].types.add(problem.typeName);
        }
      }
      if (problem.category === "type_conflict" /* TYPE_CONFLICT */ && problem.metadata?.conflictType) {
        const conflictType = problem.metadata.conflictType;
        if (!typeConflicts[conflictType]) {
          typeConflicts[conflictType] = { count: 0, examples: /* @__PURE__ */ new Set() };
        }
        typeConflicts[conflictType].count++;
        if (problem.typeName) {
          typeConflicts[conflictType].examples.add(problem.typeName);
        }
      }
    }
    const commonUnresolvedTypes = Object.entries(unresolvedTypes).map(([type, data]) => ({
      type,
      count: data.count,
      namespaces: Array.from(data.namespaces)
    })).sort((a, b) => b.count - a.count).slice(0, 20);
    const commonTypeConflicts = Object.entries(typeConflicts).map(([conflictType, data]) => ({
      conflictType,
      count: data.count,
      examples: Array.from(data.examples).slice(0, 5)
    })).sort((a, b) => b.count - a.count);
    const problematicNamespaces = Object.entries(namespaceProblems).map(([namespace, data]) => ({
      namespace,
      problems: data.count,
      types: Array.from(data.types).slice(0, 10)
    })).sort((a, b) => b.problems - a.problems).slice(0, 10);
    const mostProblematicModules = Object.entries(byModule).sort(([, a], [, b]) => b - a).slice(0, 10).map(([module, count]) => ({ module, count }));
    const endTime = /* @__PURE__ */ new Date();
    const durationMs = endTime.getTime() - this.startTime.getTime();
    return {
      bySeverity,
      byCategory,
      byModule,
      totalProblems: this.problems.length,
      mostProblematicModules,
      typeStatistics: {
        commonUnresolvedTypes,
        commonTypeConflicts,
        problematicNamespaces
      },
      startTime: this.startTime,
      endTime,
      durationMs
    };
  }
  generateSummary(statistics) {
    const { bySeverity, byCategory, totalProblems } = statistics;
    let status = "success";
    if (bySeverity["critical" /* CRITICAL */] > 0 || bySeverity["error" /* ERROR */] > 10) {
      status = "failed";
    } else if (bySeverity["error" /* ERROR */] > 0 || bySeverity["warning" /* WARNING */] > 20) {
      status = "partial";
    }
    const keyIssues = [];
    const recommendations = [];
    if (byCategory["type_resolution" /* TYPE_RESOLUTION */] > 0) {
      keyIssues.push(`${byCategory["type_resolution" /* TYPE_RESOLUTION */]} type resolution issues detected`);
      recommendations.push("Review GIR files for missing or incorrect type definitions");
    }
    if (byCategory["parsing_failure" /* PARSING_FAILURE */] > 0) {
      keyIssues.push(`${byCategory["parsing_failure" /* PARSING_FAILURE */]} parsing failures occurred`);
      recommendations.push("Check GIR file syntax and ensure proper introspection data");
    }
    if (byCategory["generation_failure" /* GENERATION_FAILURE */] > 0) {
      keyIssues.push(`${byCategory["generation_failure" /* GENERATION_FAILURE */]} generation failures encountered`);
      recommendations.push("Review template configuration and output settings");
    }
    if (byCategory["type_conflict" /* TYPE_CONFLICT */] > 5) {
      keyIssues.push(`High number of type conflicts (${byCategory["type_conflict" /* TYPE_CONFLICT */]})`);
      recommendations.push("Consider using ignore patterns or updating GIR files to resolve conflicts");
    }
    if (keyIssues.length === 0 && totalProblems > 0) {
      keyIssues.push(`${totalProblems} minor issues detected`);
    }
    if (recommendations.length === 0 && totalProblems > 0) {
      recommendations.push("Review detailed problem list for specific improvement opportunities");
    }
    return {
      status,
      keyIssues,
      recommendations
    };
  }
  generateReport() {
    const statistics = this.generateStatistics();
    const summary = this.generateSummary(statistics);
    const problemsByCategory = Object.values(ProblemCategory).reduce(
      (acc, category) => {
        acc[category] = [];
        return acc;
      },
      {}
    );
    for (const problem of this.problems) {
      problemsByCategory[problem.category].push(problem);
    }
    return {
      metadata: {
        version: REPORTER_VERSION,
        generatedAt: /* @__PURE__ */ new Date()
      },
      statistics,
      problems: [...this.problems],
      problemsByCategory,
      summary
    };
  }
  async saveReport(outputPath) {
    if (!this.config.enabled) {
      return;
    }
    const report = this.generateReport();
    const filePath = outputPath || this.config.outputPath || "ts-for-gir-report.json";
    try {
      await writeFile(filePath, JSON.stringify(report, null, 2), "utf-8");
      if (this.config.verbose) {
        this.success(`Report saved to: ${filePath}`);
      }
    } catch (error) {
      this.danger(`Failed to save report to ${filePath}: ${error}`);
    }
  }
  printSummary() {
    if (!this.config.enabled) {
      return;
    }
    const report = this.generateReport();
    const { statistics, summary } = report;
    console.log(`
${"=".repeat(50)}`);
    console.log("\u{1F4CA} GENERATION REPORT SUMMARY");
    console.log("=".repeat(50));
    const statusColor = summary.status === "success" ? green : summary.status === "partial" ? yellow : red;
    console.log(`Status: ${statusColor(summary.status.toUpperCase())}`);
    console.log(`
\u{1F4C8} Statistics:`);
    console.log(`  Total Problems: ${statistics.totalProblems}`);
    console.log(`  Duration: ${Math.round((statistics.durationMs || 0) / 1e3)}s`);
    if (statistics.totalProblems > 0) {
      console.log(`
\u{1F50D} By Severity:`);
      for (const [severity, count] of Object.entries(statistics.bySeverity)) {
        if (count > 0) {
          const color = severity === "error" || severity === "critical" ? red : severity === "warning" ? yellow : blue;
          console.log(`  ${color(severity)}: ${count}`);
        }
      }
      console.log(`
\u{1F4C2} By Category:`);
      for (const [category, count] of Object.entries(statistics.byCategory)) {
        if (count > 0) {
          console.log(`  ${category.replace(/_/g, " ")}: ${count}`);
        }
      }
      if (statistics.typeStatistics.commonUnresolvedTypes.length > 0) {
        console.log(`
\u274C Most Common Unresolved Types:`);
        statistics.typeStatistics.commonUnresolvedTypes.slice(0, 10).forEach(({ type, count, namespaces }) => {
          console.log(`  ${red(type)}: ${count} occurrences in ${namespaces.length} namespace(s)`);
          if (namespaces.length <= 3) {
            console.log(`    \u2514\u2500 ${gray(namespaces.join(", "))}`);
          }
        });
      }
      if (statistics.typeStatistics.commonTypeConflicts.length > 0) {
        console.log(`
\u2694\uFE0F  Type Conflicts:`);
        statistics.typeStatistics.commonTypeConflicts.forEach(({ conflictType, count, examples: examples7 }) => {
          console.log(`  ${yellow(conflictType)}: ${count} conflicts`);
          if (examples7.length > 0) {
            console.log(`    \u2514\u2500 Examples: ${gray(examples7.join(", "))}`);
          }
        });
      }
      if (statistics.typeStatistics.problematicNamespaces.length > 0) {
        console.log(`
\u{1F6A8} Most Problematic Namespaces:`);
        statistics.typeStatistics.problematicNamespaces.slice(0, 5).forEach(({ namespace, problems, types }) => {
          console.log(`  ${namespace}: ${problems} problems`);
          if (types.length > 0) {
            const typeList = types.slice(0, 5).join(", ");
            const moreTypes = types.length > 5 ? ` and ${types.length - 5} more` : "";
            console.log(`    \u2514\u2500 Types: ${gray(typeList + moreTypes)}`);
          }
        });
      }
      if (statistics.mostProblematicModules.length > 0) {
        console.log(`
\u{1F4E6} Most Problematic Modules:`);
        statistics.mostProblematicModules.slice(0, 5).forEach(({ module, count }) => {
          console.log(`  ${module}: ${count} issues`);
        });
      }
    }
    if (summary.keyIssues.length > 0) {
      console.log(`
\u26A0\uFE0F  Key Issues:`);
      for (const issue of summary.keyIssues) {
        console.log(`  \u2022 ${issue}`);
      }
    }
    if (summary.recommendations.length > 0) {
      console.log(`
\u{1F4A1} Recommendations:`);
      for (const rec of summary.recommendations) {
        console.log(`  \u2022 ${rec}`);
      }
    }
    console.log(`${"=".repeat(50)}
`);
  }
  // === Private helper methods ===
  static prepend(txt, prepend) {
    if (typeof txt === "string") {
      txt = `${prepend}${txt}`;
    }
    return txt;
  }
  prependInfo(txt, logLevel) {
    if (logLevel || this.config.moduleName.length > 0) {
      txt = _ConsoleReporter.prepend(txt, " ");
    }
    if (logLevel) {
      if (this.config.moduleName.length > 0) {
        txt = _ConsoleReporter.prepend(txt, ` ${logLevel}`);
      } else {
        txt = _ConsoleReporter.prepend(txt, logLevel);
      }
    }
    if (this.config.moduleName.length > 0) {
      txt = _ConsoleReporter.prepend(txt, `[${this.config.moduleName}]`);
    }
    return txt;
  }
};

// ../reporter/src/reporter-service.ts
import { writeFile as writeFile2 } from "node:fs/promises";
import { resolve } from "node:path";
import { blue as blue2, green as green2, red as red2, yellow as yellow2 } from "colorette";
var ReporterService = class _ReporterService {
  static instance = null;
  reporters = /* @__PURE__ */ new Map();
  config = {
    enabled: false,
    outputPath: "ts-for-gir-report.json"
  };
  constructor() {
  }
  /**
   * Get the singleton instance of ReporterService
   */
  static getInstance() {
    if (!_ReporterService.instance) {
      _ReporterService.instance = new _ReporterService();
    }
    return _ReporterService.instance;
  }
  /**
   * Configure the reporter service
   */
  configure(enabled, outputPath) {
    this.config.enabled = enabled;
    this.config.outputPath = outputPath;
  }
  /**
   * Register a Reporter instance
   */
  registerReporter(id, reporter) {
    if (this.config.enabled) {
      this.reporters.set(id, reporter);
    }
  }
  /**
   * Unregister a Reporter instance
   */
  unregisterReporter(id) {
    this.reporters.delete(id);
  }
  /**
   * Check if reporter service is enabled
   */
  isEnabled() {
    return this.config.enabled;
  }
  /**
   * Get all registered reporters
   */
  getReporters() {
    return new Map(this.reporters);
  }
  /**
   * Collect all problems from all registered reporters
   */
  collectAllProblems() {
    const allProblems = [];
    for (const reporter of this.reporters.values()) {
      const report = reporter.generateReport();
      allProblems.push(...report.problems);
    }
    return allProblems;
  }
  /**
   * Generate comprehensive statistics from all reporters
   */
  generateComprehensiveStatistics() {
    const allProblems = this.collectAllProblems();
    if (this.reporters.size === 0) {
      return {
        bySeverity: {
          ["debug" /* DEBUG */]: 0,
          ["info" /* INFO */]: 0,
          ["warning" /* WARNING */]: 0,
          ["error" /* ERROR */]: 0,
          ["critical" /* CRITICAL */]: 0
        },
        byCategory: {
          ["type_resolution" /* TYPE_RESOLUTION */]: 0,
          ["parsing_failure" /* PARSING_FAILURE */]: 0,
          ["generation_failure" /* GENERATION_FAILURE */]: 0,
          ["type_conflict" /* TYPE_CONFLICT */]: 0,
          ["dependency_issue" /* DEPENDENCY_ISSUE */]: 0,
          ["configuration" /* CONFIGURATION */]: 0,
          ["io_error" /* IO_ERROR */]: 0,
          ["general" /* GENERAL */]: 0
        },
        byModule: {},
        totalProblems: 0,
        mostProblematicModules: [],
        typeStatistics: {
          commonUnresolvedTypes: [],
          commonTypeConflicts: [],
          problematicNamespaces: []
        },
        startTime: /* @__PURE__ */ new Date(),
        endTime: /* @__PURE__ */ new Date(),
        durationMs: 0
      };
    }
    const firstReport = this.reporters.values().next().value?.generateReport();
    const startTime = firstReport?.statistics.startTime || /* @__PURE__ */ new Date();
    const endTime = /* @__PURE__ */ new Date();
    const durationMs = endTime.getTime() - startTime.getTime();
    const bySeverity = {
      ["debug" /* DEBUG */]: 0,
      ["info" /* INFO */]: 0,
      ["warning" /* WARNING */]: 0,
      ["error" /* ERROR */]: 0,
      ["critical" /* CRITICAL */]: 0
    };
    const byCategory = {
      ["type_resolution" /* TYPE_RESOLUTION */]: 0,
      ["parsing_failure" /* PARSING_FAILURE */]: 0,
      ["generation_failure" /* GENERATION_FAILURE */]: 0,
      ["type_conflict" /* TYPE_CONFLICT */]: 0,
      ["dependency_issue" /* DEPENDENCY_ISSUE */]: 0,
      ["configuration" /* CONFIGURATION */]: 0,
      ["io_error" /* IO_ERROR */]: 0,
      ["general" /* GENERAL */]: 0
    };
    const byModule = {};
    const unresolvedTypes = {};
    const typeConflicts = {};
    const namespaceProblems = {};
    for (const problem of allProblems) {
      bySeverity[problem.severity] = (bySeverity[problem.severity] || 0) + 1;
      byCategory[problem.category] = (byCategory[problem.category] || 0) + 1;
      byModule[problem.module] = (byModule[problem.module] || 0) + 1;
      if (problem.category === "type_resolution" /* TYPE_RESOLUTION */ && problem.typeName) {
        if (!unresolvedTypes[problem.typeName]) {
          unresolvedTypes[problem.typeName] = { count: 0, namespaces: /* @__PURE__ */ new Set() };
        }
        unresolvedTypes[problem.typeName].count++;
        if (problem.location) {
          unresolvedTypes[problem.typeName].namespaces.add(problem.location);
        }
        if (problem.location) {
          if (!namespaceProblems[problem.location]) {
            namespaceProblems[problem.location] = { count: 0, types: /* @__PURE__ */ new Set() };
          }
          namespaceProblems[problem.location].count++;
          namespaceProblems[problem.location].types.add(problem.typeName);
        }
      }
      if (problem.category === "type_conflict" /* TYPE_CONFLICT */ && problem.metadata?.conflictType) {
        const conflictType = problem.metadata.conflictType;
        if (!typeConflicts[conflictType]) {
          typeConflicts[conflictType] = { count: 0, examples: /* @__PURE__ */ new Set() };
        }
        typeConflicts[conflictType].count++;
        if (problem.typeName) {
          typeConflicts[conflictType].examples.add(problem.typeName);
        }
      }
    }
    const commonUnresolvedTypes = Object.entries(unresolvedTypes).map(([type, data]) => ({
      type,
      count: data.count,
      namespaces: Array.from(data.namespaces)
    })).sort((a, b) => b.count - a.count).slice(0, 20);
    const commonTypeConflicts = Object.entries(typeConflicts).map(([conflictType, data]) => ({
      conflictType,
      count: data.count,
      examples: Array.from(data.examples).slice(0, 5)
    })).sort((a, b) => b.count - a.count);
    const problematicNamespaces = Object.entries(namespaceProblems).map(([namespace, data]) => ({
      namespace,
      problems: data.count,
      types: Array.from(data.types).slice(0, 10)
    })).sort((a, b) => b.problems - a.problems).slice(0, 10);
    const mostProblematicModules = Object.entries(byModule).sort(([, a], [, b]) => b - a).slice(0, 10).map(([module, count]) => ({ module, count }));
    return {
      bySeverity,
      byCategory,
      byModule,
      totalProblems: allProblems.length,
      mostProblematicModules,
      typeStatistics: {
        commonUnresolvedTypes,
        commonTypeConflicts,
        problematicNamespaces
      },
      startTime,
      endTime,
      durationMs
    };
  }
  /**
   * Generate comprehensive report from all reporters
   */
  generateComprehensiveReport() {
    const statistics = this.generateComprehensiveStatistics();
    const allProblems = this.collectAllProblems();
    const problemsByCategory = Object.values(ProblemCategory).reduce(
      (acc, category) => {
        acc[category] = [];
        return acc;
      },
      {}
    );
    for (const problem of allProblems) {
      problemsByCategory[problem.category].push(problem);
    }
    const errorCount = statistics.bySeverity["error" /* ERROR */] || 0;
    const criticalCount = statistics.bySeverity["critical" /* CRITICAL */] || 0;
    const warningCount = statistics.bySeverity["warning" /* WARNING */] || 0;
    let status = "success";
    if (criticalCount > 0 || errorCount > 10) {
      status = "failed";
    } else if (errorCount > 0 || warningCount > 20) {
      status = "partial";
    }
    const keyIssues = [];
    const recommendations = [];
    const typeResolutionCount = statistics.byCategory["type_resolution" /* TYPE_RESOLUTION */] || 0;
    const parsingFailureCount = statistics.byCategory["parsing_failure" /* PARSING_FAILURE */] || 0;
    const generationFailureCount = statistics.byCategory["generation_failure" /* GENERATION_FAILURE */] || 0;
    const conflictCount = statistics.byCategory["type_conflict" /* TYPE_CONFLICT */] || 0;
    if (typeResolutionCount > 0) {
      keyIssues.push(`${typeResolutionCount} type resolution issues across all modules`);
      recommendations.push("Review GIR files for missing or incorrect type definitions");
    }
    if (parsingFailureCount > 0) {
      keyIssues.push(`${parsingFailureCount} parsing failures encountered`);
      recommendations.push("Check GIR file syntax and ensure proper introspection data");
    }
    if (generationFailureCount > 0) {
      keyIssues.push(`${generationFailureCount} generation failures occurred`);
      recommendations.push("Review template configuration and output settings");
    }
    if (conflictCount > 10) {
      keyIssues.push(`High number of type conflicts (${conflictCount})`);
      recommendations.push("Consider using ignore patterns or updating GIR files to resolve conflicts");
    }
    if (keyIssues.length === 0 && statistics.totalProblems > 0) {
      keyIssues.push(`${statistics.totalProblems} minor issues detected across all modules`);
    }
    if (recommendations.length === 0 && statistics.totalProblems > 0) {
      recommendations.push("Review detailed problem list for specific improvement opportunities");
    }
    return {
      metadata: {
        version: REPORTER_VERSION,
        generatedAt: /* @__PURE__ */ new Date()
      },
      statistics,
      problems: allProblems,
      problemsByCategory,
      summary: {
        status,
        keyIssues,
        recommendations
      }
    };
  }
  /**
   * Save comprehensive report to file
   */
  async saveComprehensiveReport(outputPath) {
    if (!this.config.enabled) {
      return;
    }
    const report = this.generateComprehensiveReport();
    const filePath = outputPath || this.config.outputPath;
    try {
      const fullPath = resolve(process.cwd(), filePath);
      await writeFile2(fullPath, JSON.stringify(report, null, 2), "utf-8");
      console.log(`\u{1F4CA} Comprehensive report saved to: ${fullPath}`);
    } catch (error) {
      console.error(`\u274C Failed to save comprehensive report to ${filePath}: ${error}`);
    }
  }
  /**
   * Print comprehensive summary to console
   */
  printComprehensiveSummary() {
    const report = this.generateComprehensiveReport();
    const { statistics, summary } = report;
    console.log(`
${"=".repeat(60)}`);
    console.log("\u{1F4CA} COMPREHENSIVE GENERATION REPORT");
    console.log("=".repeat(60));
    const statusColor = summary.status === "success" ? green2 : summary.status === "partial" ? yellow2 : red2;
    console.log(`
\u{1F3AF} Overall Status: ${statusColor(summary.status.toUpperCase())}`);
    console.log(`
\u{1F4C8} Total Statistics:`);
    console.log(`  \u23F1\uFE0F  Duration: ${Math.round((statistics.durationMs || 0) / 1e3)}s`);
    console.log(`  \u{1F4C1} Modules Processed: ${this.reporters.size}`);
    console.log(`  \u26A0\uFE0F  Total Problems: ${statistics.totalProblems}`);
    if (statistics.totalProblems > 0) {
      console.log(`
\u{1F50D} Problems by Severity:`);
      for (const [severity, count] of Object.entries(statistics.bySeverity)) {
        if (count > 0) {
          const icon = severity === "error" || severity === "critical" ? "\u274C" : severity === "warning" ? "\u26A0\uFE0F" : "\u2139\uFE0F";
          const color = severity === "error" || severity === "critical" ? red2 : severity === "warning" ? yellow2 : blue2;
          console.log(`  ${icon} ${color(severity.toUpperCase())}: ${count}`);
        }
      }
      console.log(`
\u{1F4C2} Problems by Category:`);
      for (const [category, count] of Object.entries(statistics.byCategory)) {
        if (count > 0) {
          const categoryName = category.replace(/_/g, " ").replace(/\b\w/g, (l) => l.toUpperCase());
          console.log(`  \u2022 ${categoryName}: ${count}`);
        }
      }
      if (statistics.mostProblematicModules.length > 0) {
        console.log(`
\u{1F4E6} Most Problematic Modules:`);
        statistics.mostProblematicModules.slice(0, 10).forEach(({ module, count }) => {
          const percentage = Math.round(count / statistics.totalProblems * 100);
          console.log(`  ${module}: ${count} issues (${percentage}%)`);
        });
      }
    }
    if (summary.keyIssues.length > 0) {
      console.log(`
\u26A0\uFE0F  Key Issues:`);
      for (const issue of summary.keyIssues) {
        console.log(`  \u2022 ${issue}`);
      }
    }
    if (summary.recommendations.length > 0) {
      console.log(`
\u{1F4A1} Recommendations:`);
      for (const rec of summary.recommendations) {
        console.log(`  \u2022 ${rec}`);
      }
    }
    console.log(`
${"=".repeat(60)}`);
    console.log(`\u{1F4DD} Detailed report: ${this.config.outputPath || "ts-for-gir-report.json"}`);
    console.log(`${"=".repeat(60)}
`);
  }
  /**
   * Reset the service (mainly for testing)
   */
  reset() {
    this.reporters.clear();
    this.config.enabled = false;
    this.config.outputPath = "ts-for-gir-report.json";
  }
};

// ../lib/src/constants.ts
import { createRequire as createRequire2 } from "node:module";
import { dirname as dirname2, join as join2 } from "node:path";
var require3 = createRequire2(import.meta.url);
var NEW_LINE_REG_EXP = /[\n\r]+/g;
function resolveWorkspacePackageJson2() {
  try {
    return require3.resolve("../../../package.json");
  } catch {
    try {
      const currentPackageJson = require3.resolve("@ts-for-gir/lib/package.json");
      return join2(dirname2(dirname2(currentPackageJson)), "package.json");
    } catch {
      throw new Error("Unable to resolve workspace package.json path");
    }
  }
}
function readWorkspacePackageSync() {
  try {
    const packagePath = resolveWorkspacePackageJson2();
    const { readFileSync: readFileSync3 } = require3("node:fs");
    const content = readFileSync3(packagePath, "utf-8");
    return JSON.parse(content);
  } catch (error) {
    const message = error instanceof Error ? error.message : "Unknown error";
    throw new Error(`Failed to read workspace package.json: ${message}`);
  }
}
var PACKAGE = readWorkspacePackageSync();
var APP_NAME = "ts-for-gir";
var APP_USAGE = "TypeScript type definition generator for GObject introspection GIR files";
var APP_SOURCE = "https://github.com/gjsify/ts-for-gir";
var APP_VERSION = PACKAGE.version;
var PACKAGE_DESC = (packageName, libraryVersion) => {
  if (libraryVersion) {
    return `GJS TypeScript type definitions for ${packageName}, generated from library version ${libraryVersion.toString()}`;
  }
  return `GJS TypeScript type definitions for ${packageName}`;
};
var PACKAGE_KEYWORDS = (packageName) => {
  return `"Gir", "TypeScript", "types", "GObject-Introspection", "GJS", "${packageName}"`;
};
var RESERVED_NAMESPACE_NAMES = {};

// ../lib/src/dependency-manager.ts
import { readFile as readFile2 } from "node:fs/promises";

// ../parser/src/parser.ts
var parser_exports = {};
__export(parser_exports, {
  parseGir: () => parseGir
});

// ../../.yarn/cache/fast-xml-parser-npm-5.2.5-4fd49da1b5-305017cff6.zip/node_modules/fast-xml-parser/src/util.js
var nameStartChar = ":A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
var nameChar = nameStartChar + "\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
var nameRegexp = "[" + nameStartChar + "][" + nameChar + "]*";
var regexName = new RegExp("^" + nameRegexp + "$");
function getAllMatches(string, regex) {
  const matches = [];
  let match = regex.exec(string);
  while (match) {
    const allmatches = [];
    allmatches.startIndex = regex.lastIndex - match[0].length;
    const len = match.length;
    for (let index = 0; index < len; index++) {
      allmatches.push(match[index]);
    }
    matches.push(allmatches);
    match = regex.exec(string);
  }
  return matches;
}
var isName = function(string) {
  const match = regexName.exec(string);
  return !(match === null || typeof match === "undefined");
};
function isExist(v) {
  return typeof v !== "undefined";
}

// ../../.yarn/cache/fast-xml-parser-npm-5.2.5-4fd49da1b5-305017cff6.zip/node_modules/fast-xml-parser/src/validator.js
var defaultOptions = {
  allowBooleanAttributes: false,
  //A tag can have attributes without any value
  unpairedTags: []
};
function validate(xmlData, options2) {
  options2 = Object.assign({}, defaultOptions, options2);
  const tags = [];
  let tagFound = false;
  let reachedRoot = false;
  if (xmlData[0] === "\uFEFF") {
    xmlData = xmlData.substr(1);
  }
  for (let i = 0; i < xmlData.length; i++) {
    if (xmlData[i] === "<" && xmlData[i + 1] === "?") {
      i += 2;
      i = readPI(xmlData, i);
      if (i.err) return i;
    } else if (xmlData[i] === "<") {
      let tagStartPos = i;
      i++;
      if (xmlData[i] === "!") {
        i = readCommentAndCDATA(xmlData, i);
        continue;
      } else {
        let closingTag = false;
        if (xmlData[i] === "/") {
          closingTag = true;
          i++;
        }
        let tagName = "";
        for (; i < xmlData.length && xmlData[i] !== ">" && xmlData[i] !== " " && xmlData[i] !== "	" && xmlData[i] !== "\n" && xmlData[i] !== "\r"; i++) {
          tagName += xmlData[i];
        }
        tagName = tagName.trim();
        if (tagName[tagName.length - 1] === "/") {
          tagName = tagName.substring(0, tagName.length - 1);
          i--;
        }
        if (!validateTagName(tagName)) {
          let msg;
          if (tagName.trim().length === 0) {
            msg = "Invalid space after '<'.";
          } else {
            msg = "Tag '" + tagName + "' is an invalid name.";
          }
          return getErrorObject("InvalidTag", msg, getLineNumberForPosition(xmlData, i));
        }
        const result = readAttributeStr(xmlData, i);
        if (result === false) {
          return getErrorObject("InvalidAttr", "Attributes for '" + tagName + "' have open quote.", getLineNumberForPosition(xmlData, i));
        }
        let attrStr = result.value;
        i = result.index;
        if (attrStr[attrStr.length - 1] === "/") {
          const attrStrStart = i - attrStr.length;
          attrStr = attrStr.substring(0, attrStr.length - 1);
          const isValid = validateAttributeString(attrStr, options2);
          if (isValid === true) {
            tagFound = true;
          } else {
            return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, attrStrStart + isValid.err.line));
          }
        } else if (closingTag) {
          if (!result.tagClosed) {
            return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' doesn't have proper closing.", getLineNumberForPosition(xmlData, i));
          } else if (attrStr.trim().length > 0) {
            return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' can't have attributes or invalid starting.", getLineNumberForPosition(xmlData, tagStartPos));
          } else if (tags.length === 0) {
            return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' has not been opened.", getLineNumberForPosition(xmlData, tagStartPos));
          } else {
            const otg = tags.pop();
            if (tagName !== otg.tagName) {
              let openPos = getLineNumberForPosition(xmlData, otg.tagStartPos);
              return getErrorObject(
                "InvalidTag",
                "Expected closing tag '" + otg.tagName + "' (opened in line " + openPos.line + ", col " + openPos.col + ") instead of closing tag '" + tagName + "'.",
                getLineNumberForPosition(xmlData, tagStartPos)
              );
            }
            if (tags.length == 0) {
              reachedRoot = true;
            }
          }
        } else {
          const isValid = validateAttributeString(attrStr, options2);
          if (isValid !== true) {
            return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, i - attrStr.length + isValid.err.line));
          }
          if (reachedRoot === true) {
            return getErrorObject("InvalidXml", "Multiple possible root nodes found.", getLineNumberForPosition(xmlData, i));
          } else if (options2.unpairedTags.indexOf(tagName) !== -1) {
          } else {
            tags.push({ tagName, tagStartPos });
          }
          tagFound = true;
        }
        for (i++; i < xmlData.length; i++) {
          if (xmlData[i] === "<") {
            if (xmlData[i + 1] === "!") {
              i++;
              i = readCommentAndCDATA(xmlData, i);
              continue;
            } else if (xmlData[i + 1] === "?") {
              i = readPI(xmlData, ++i);
              if (i.err) return i;
            } else {
              break;
            }
          } else if (xmlData[i] === "&") {
            const afterAmp = validateAmpersand(xmlData, i);
            if (afterAmp == -1)
              return getErrorObject("InvalidChar", "char '&' is not expected.", getLineNumberForPosition(xmlData, i));
            i = afterAmp;
          } else {
            if (reachedRoot === true && !isWhiteSpace(xmlData[i])) {
              return getErrorObject("InvalidXml", "Extra text at the end", getLineNumberForPosition(xmlData, i));
            }
          }
        }
        if (xmlData[i] === "<") {
          i--;
        }
      }
    } else {
      if (isWhiteSpace(xmlData[i])) {
        continue;
      }
      return getErrorObject("InvalidChar", "char '" + xmlData[i] + "' is not expected.", getLineNumberForPosition(xmlData, i));
    }
  }
  if (!tagFound) {
    return getErrorObject("InvalidXml", "Start tag expected.", 1);
  } else if (tags.length == 1) {
    return getErrorObject("InvalidTag", "Unclosed tag '" + tags[0].tagName + "'.", getLineNumberForPosition(xmlData, tags[0].tagStartPos));
  } else if (tags.length > 0) {
    return getErrorObject("InvalidXml", "Invalid '" + JSON.stringify(tags.map((t) => t.tagName), null, 4).replace(/\r?\n/g, "") + "' found.", { line: 1, col: 1 });
  }
  return true;
}
function isWhiteSpace(char) {
  return char === " " || char === "	" || char === "\n" || char === "\r";
}
function readPI(xmlData, i) {
  const start = i;
  for (; i < xmlData.length; i++) {
    if (xmlData[i] == "?" || xmlData[i] == " ") {
      const tagname = xmlData.substr(start, i - start);
      if (i > 5 && tagname === "xml") {
        return getErrorObject("InvalidXml", "XML declaration allowed only at the start of the document.", getLineNumberForPosition(xmlData, i));
      } else if (xmlData[i] == "?" && xmlData[i + 1] == ">") {
        i++;
        break;
      } else {
        continue;
      }
    }
  }
  return i;
}
function readCommentAndCDATA(xmlData, i) {
  if (xmlData.length > i + 5 && xmlData[i + 1] === "-" && xmlData[i + 2] === "-") {
    for (i += 3; i < xmlData.length; i++) {
      if (xmlData[i] === "-" && xmlData[i + 1] === "-" && xmlData[i + 2] === ">") {
        i += 2;
        break;
      }
    }
  } else if (xmlData.length > i + 8 && xmlData[i + 1] === "D" && xmlData[i + 2] === "O" && xmlData[i + 3] === "C" && xmlData[i + 4] === "T" && xmlData[i + 5] === "Y" && xmlData[i + 6] === "P" && xmlData[i + 7] === "E") {
    let angleBracketsCount = 1;
    for (i += 8; i < xmlData.length; i++) {
      if (xmlData[i] === "<") {
        angleBracketsCount++;
      } else if (xmlData[i] === ">") {
        angleBracketsCount--;
        if (angleBracketsCount === 0) {
          break;
        }
      }
    }
  } else if (xmlData.length > i + 9 && xmlData[i + 1] === "[" && xmlData[i + 2] === "C" && xmlData[i + 3] === "D" && xmlData[i + 4] === "A" && xmlData[i + 5] === "T" && xmlData[i + 6] === "A" && xmlData[i + 7] === "[") {
    for (i += 8; i < xmlData.length; i++) {
      if (xmlData[i] === "]" && xmlData[i + 1] === "]" && xmlData[i + 2] === ">") {
        i += 2;
        break;
      }
    }
  }
  return i;
}
var doubleQuote = '"';
var singleQuote = "'";
function readAttributeStr(xmlData, i) {
  let attrStr = "";
  let startChar = "";
  let tagClosed = false;
  for (; i < xmlData.length; i++) {
    if (xmlData[i] === doubleQuote || xmlData[i] === singleQuote) {
      if (startChar === "") {
        startChar = xmlData[i];
      } else if (startChar !== xmlData[i]) {
      } else {
        startChar = "";
      }
    } else if (xmlData[i] === ">") {
      if (startChar === "") {
        tagClosed = true;
        break;
      }
    }
    attrStr += xmlData[i];
  }
  if (startChar !== "") {
    return false;
  }
  return {
    value: attrStr,
    index: i,
    tagClosed
  };
}
var validAttrStrRegxp = new RegExp(`(\\s*)([^\\s=]+)(\\s*=)?(\\s*(['"])(([\\s\\S])*?)\\5)?`, "g");
function validateAttributeString(attrStr, options2) {
  const matches = getAllMatches(attrStr, validAttrStrRegxp);
  const attrNames = {};
  for (let i = 0; i < matches.length; i++) {
    if (matches[i][1].length === 0) {
      return getErrorObject("InvalidAttr", "Attribute '" + matches[i][2] + "' has no space in starting.", getPositionFromMatch(matches[i]));
    } else if (matches[i][3] !== void 0 && matches[i][4] === void 0) {
      return getErrorObject("InvalidAttr", "Attribute '" + matches[i][2] + "' is without value.", getPositionFromMatch(matches[i]));
    } else if (matches[i][3] === void 0 && !options2.allowBooleanAttributes) {
      return getErrorObject("InvalidAttr", "boolean attribute '" + matches[i][2] + "' is not allowed.", getPositionFromMatch(matches[i]));
    }
    const attrName = matches[i][2];
    if (!validateAttrName(attrName)) {
      return getErrorObject("InvalidAttr", "Attribute '" + attrName + "' is an invalid name.", getPositionFromMatch(matches[i]));
    }
    if (!attrNames.hasOwnProperty(attrName)) {
      attrNames[attrName] = 1;
    } else {
      return getErrorObject("InvalidAttr", "Attribute '" + attrName + "' is repeated.", getPositionFromMatch(matches[i]));
    }
  }
  return true;
}
function validateNumberAmpersand(xmlData, i) {
  let re = /\d/;
  if (xmlData[i] === "x") {
    i++;
    re = /[\da-fA-F]/;
  }
  for (; i < xmlData.length; i++) {
    if (xmlData[i] === ";")
      return i;
    if (!xmlData[i].match(re))
      break;
  }
  return -1;
}
function validateAmpersand(xmlData, i) {
  i++;
  if (xmlData[i] === ";")
    return -1;
  if (xmlData[i] === "#") {
    i++;
    return validateNumberAmpersand(xmlData, i);
  }
  let count = 0;
  for (; i < xmlData.length; i++, count++) {
    if (xmlData[i].match(/\w/) && count < 20)
      continue;
    if (xmlData[i] === ";")
      break;
    return -1;
  }
  return i;
}
function getErrorObject(code, message, lineNumber) {
  return {
    err: {
      code,
      msg: message,
      line: lineNumber.line || lineNumber,
      col: lineNumber.col
    }
  };
}
function validateAttrName(attrName) {
  return isName(attrName);
}
function validateTagName(tagname) {
  return isName(tagname);
}
function getLineNumberForPosition(xmlData, index) {
  const lines = xmlData.substring(0, index).split(/\r?\n/);
  return {
    line: lines.length,
    // column number is last line's length + 1, because column numbering starts at 1:
    col: lines[lines.length - 1].length + 1
  };
}
function getPositionFromMatch(match) {
  return match.startIndex + match[1].length;
}

// ../../.yarn/cache/fast-xml-parser-npm-5.2.5-4fd49da1b5-305017cff6.zip/node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js
var defaultOptions2 = {
  preserveOrder: false,
  attributeNamePrefix: "@_",
  attributesGroupName: false,
  textNodeName: "#text",
  ignoreAttributes: true,
  removeNSPrefix: false,
  // remove NS from tag name or attribute name if true
  allowBooleanAttributes: false,
  //a tag can have attributes without any value
  //ignoreRootElement : false,
  parseTagValue: true,
  parseAttributeValue: false,
  trimValues: true,
  //Trim string values of tag and attributes
  cdataPropName: false,
  numberParseOptions: {
    hex: true,
    leadingZeros: true,
    eNotation: true
  },
  tagValueProcessor: function(tagName, val) {
    return val;
  },
  attributeValueProcessor: function(attrName, val) {
    return val;
  },
  stopNodes: [],
  //nested tags will not be parsed even for errors
  alwaysCreateTextNode: false,
  isArray: () => false,
  commentPropName: false,
  unpairedTags: [],
  processEntities: true,
  htmlEntities: false,
  ignoreDeclaration: false,
  ignorePiTags: false,
  transformTagName: false,
  transformAttributeName: false,
  updateTag: function(tagName, jPath, attrs) {
    return tagName;
  },
  // skipEmptyListItem: false
  captureMetaData: false
};
var buildOptions = function(options2) {
  return Object.assign({}, defaultOptions2, options2);
};

// ../../.yarn/cache/fast-xml-parser-npm-5.2.5-4fd49da1b5-305017cff6.zip/node_modules/fast-xml-parser/src/xmlparser/xmlNode.js
var METADATA_SYMBOL;
if (typeof Symbol !== "function") {
  METADATA_SYMBOL = "@@xmlMetadata";
} else {
  METADATA_SYMBOL = Symbol("XML Node Metadata");
}
var XmlNode = class {
  constructor(tagname) {
    this.tagname = tagname;
    this.child = [];
    this[":@"] = {};
  }
  add(key, val) {
    if (key === "__proto__") key = "#__proto__";
    this.child.push({ [key]: val });
  }
  addChild(node, startIndex) {
    if (node.tagname === "__proto__") node.tagname = "#__proto__";
    if (node[":@"] && Object.keys(node[":@"]).length > 0) {
      this.child.push({ [node.tagname]: node.child, [":@"]: node[":@"] });
    } else {
      this.child.push({ [node.tagname]: node.child });
    }
    if (startIndex !== void 0) {
      this.child[this.child.length - 1][METADATA_SYMBOL] = { startIndex };
    }
  }
  /** symbol used for metadata */
  static getMetaDataSymbol() {
    return METADATA_SYMBOL;
  }
};

// ../../.yarn/cache/fast-xml-parser-npm-5.2.5-4fd49da1b5-305017cff6.zip/node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js
function readDocType(xmlData, i) {
  const entities = {};
  if (xmlData[i + 3] === "O" && xmlData[i + 4] === "C" && xmlData[i + 5] === "T" && xmlData[i + 6] === "Y" && xmlData[i + 7] === "P" && xmlData[i + 8] === "E") {
    i = i + 9;
    let angleBracketsCount = 1;
    let hasBody = false, comment = false;
    let exp = "";
    for (; i < xmlData.length; i++) {
      if (xmlData[i] === "<" && !comment) {
        if (hasBody && hasSeq(xmlData, "!ENTITY", i)) {
          i += 7;
          let entityName, val;
          [entityName, val, i] = readEntityExp(xmlData, i + 1);
          if (val.indexOf("&") === -1)
            entities[entityName] = {
              regx: RegExp(`&${entityName};`, "g"),
              val
            };
        } else if (hasBody && hasSeq(xmlData, "!ELEMENT", i)) {
          i += 8;
          const { index } = readElementExp(xmlData, i + 1);
          i = index;
        } else if (hasBody && hasSeq(xmlData, "!ATTLIST", i)) {
          i += 8;
        } else if (hasBody && hasSeq(xmlData, "!NOTATION", i)) {
          i += 9;
          const { index } = readNotationExp(xmlData, i + 1);
          i = index;
        } else if (hasSeq(xmlData, "!--", i)) comment = true;
        else throw new Error(`Invalid DOCTYPE`);
        angleBracketsCount++;
        exp = "";
      } else if (xmlData[i] === ">") {
        if (comment) {
          if (xmlData[i - 1] === "-" && xmlData[i - 2] === "-") {
            comment = false;
            angleBracketsCount--;
          }
        } else {
          angleBracketsCount--;
        }
        if (angleBracketsCount === 0) {
          break;
        }
      } else if (xmlData[i] === "[") {
        hasBody = true;
      } else {
        exp += xmlData[i];
      }
    }
    if (angleBracketsCount !== 0) {
      throw new Error(`Unclosed DOCTYPE`);
    }
  } else {
    throw new Error(`Invalid Tag instead of DOCTYPE`);
  }
  return { entities, i };
}
var skipWhitespace = (data, index) => {
  while (index < data.length && /\s/.test(data[index])) {
    index++;
  }
  return index;
};
function readEntityExp(xmlData, i) {
  i = skipWhitespace(xmlData, i);
  let entityName = "";
  while (i < xmlData.length && !/\s/.test(xmlData[i]) && xmlData[i] !== '"' && xmlData[i] !== "'") {
    entityName += xmlData[i];
    i++;
  }
  validateEntityName(entityName);
  i = skipWhitespace(xmlData, i);
  if (xmlData.substring(i, i + 6).toUpperCase() === "SYSTEM") {
    throw new Error("External entities are not supported");
  } else if (xmlData[i] === "%") {
    throw new Error("Parameter entities are not supported");
  }
  let entityValue = "";
  [i, entityValue] = readIdentifierVal(xmlData, i, "entity");
  i--;
  return [entityName, entityValue, i];
}
function readNotationExp(xmlData, i) {
  i = skipWhitespace(xmlData, i);
  let notationName = "";
  while (i < xmlData.length && !/\s/.test(xmlData[i])) {
    notationName += xmlData[i];
    i++;
  }
  validateEntityName(notationName);
  i = skipWhitespace(xmlData, i);
  const identifierType = xmlData.substring(i, i + 6).toUpperCase();
  if (identifierType !== "SYSTEM" && identifierType !== "PUBLIC") {
    throw new Error(`Expected SYSTEM or PUBLIC, found "${identifierType}"`);
  }
  i += identifierType.length;
  i = skipWhitespace(xmlData, i);
  let publicIdentifier = null;
  let systemIdentifier = null;
  if (identifierType === "PUBLIC") {
    [i, publicIdentifier] = readIdentifierVal(xmlData, i, "publicIdentifier");
    i = skipWhitespace(xmlData, i);
    if (xmlData[i] === '"' || xmlData[i] === "'") {
      [i, systemIdentifier] = readIdentifierVal(xmlData, i, "systemIdentifier");
    }
  } else if (identifierType === "SYSTEM") {
    [i, systemIdentifier] = readIdentifierVal(xmlData, i, "systemIdentifier");
    if (!systemIdentifier) {
      throw new Error("Missing mandatory system identifier for SYSTEM notation");
    }
  }
  return { notationName, publicIdentifier, systemIdentifier, index: --i };
}
function readIdentifierVal(xmlData, i, type) {
  let identifierVal = "";
  const startChar = xmlData[i];
  if (startChar !== '"' && startChar !== "'") {
    throw new Error(`Expected quoted string, found "${startChar}"`);
  }
  i++;
  while (i < xmlData.length && xmlData[i] !== startChar) {
    identifierVal += xmlData[i];
    i++;
  }
  if (xmlData[i] !== startChar) {
    throw new Error(`Unterminated ${type} value`);
  }
  i++;
  return [i, identifierVal];
}
function readElementExp(xmlData, i) {
  i = skipWhitespace(xmlData, i);
  let elementName = "";
  while (i < xmlData.length && !/\s/.test(xmlData[i])) {
    elementName += xmlData[i];
    i++;
  }
  if (!validateEntityName(elementName)) {
    throw new Error(`Invalid element name: "${elementName}"`);
  }
  i = skipWhitespace(xmlData, i);
  let contentModel = "";
  if (xmlData[i] === "E" && hasSeq(xmlData, "MPTY", i)) i += 4;
  else if (xmlData[i] === "A" && hasSeq(xmlData, "NY", i)) i += 2;
  else if (xmlData[i] === "(") {
    i++;
    while (i < xmlData.length && xmlData[i] !== ")") {
      contentModel += xmlData[i];
      i++;
    }
    if (xmlData[i] !== ")") {
      throw new Error("Unterminated content model");
    }
  } else {
    throw new Error(`Invalid Element Expression, found "${xmlData[i]}"`);
  }
  return {
    elementName,
    contentModel: contentModel.trim(),
    index: i
  };
}
function hasSeq(data, seq, i) {
  for (let j = 0; j < seq.length; j++) {
    if (seq[j] !== data[i + j + 1]) return false;
  }
  return true;
}
function validateEntityName(name) {
  if (isName(name))
    return name;
  else
    throw new Error(`Invalid entity name ${name}`);
}

// ../../.yarn/cache/strnum-npm-2.1.1-2f45f2aae3-d5fe6e4333.zip/node_modules/strnum/strnum.js
var hexRegex = /^[-+]?0x[a-fA-F0-9]+$/;
var numRegex = /^([\-\+])?(0*)([0-9]*(\.[0-9]*)?)$/;
var consider = {
  hex: true,
  // oct: false,
  leadingZeros: true,
  decimalPoint: ".",
  eNotation: true
  //skipLike: /regex/
};
function toNumber(str, options2 = {}) {
  options2 = Object.assign({}, consider, options2);
  if (!str || typeof str !== "string") return str;
  let trimmedStr = str.trim();
  if (options2.skipLike !== void 0 && options2.skipLike.test(trimmedStr)) return str;
  else if (str === "0") return 0;
  else if (options2.hex && hexRegex.test(trimmedStr)) {
    return parse_int(trimmedStr, 16);
  } else if (trimmedStr.search(/.+[eE].+/) !== -1) {
    return resolveEnotation(str, trimmedStr, options2);
  } else {
    const match = numRegex.exec(trimmedStr);
    if (match) {
      const sign = match[1] || "";
      const leadingZeros = match[2];
      let numTrimmedByZeros = trimZeros(match[3]);
      const decimalAdjacentToLeadingZeros = sign ? (
        // 0., -00., 000.
        str[leadingZeros.length + 1] === "."
      ) : str[leadingZeros.length] === ".";
      if (!options2.leadingZeros && (leadingZeros.length > 1 || leadingZeros.length === 1 && !decimalAdjacentToLeadingZeros)) {
        return str;
      } else {
        const num = Number(trimmedStr);
        const parsedStr = String(num);
        if (num === 0) return num;
        if (parsedStr.search(/[eE]/) !== -1) {
          if (options2.eNotation) return num;
          else return str;
        } else if (trimmedStr.indexOf(".") !== -1) {
          if (parsedStr === "0") return num;
          else if (parsedStr === numTrimmedByZeros) return num;
          else if (parsedStr === `${sign}${numTrimmedByZeros}`) return num;
          else return str;
        }
        let n = leadingZeros ? numTrimmedByZeros : trimmedStr;
        if (leadingZeros) {
          return n === parsedStr || sign + n === parsedStr ? num : str;
        } else {
          return n === parsedStr || n === sign + parsedStr ? num : str;
        }
      }
    } else {
      return str;
    }
  }
}
var eNotationRegx = /^([-+])?(0*)(\d*(\.\d*)?[eE][-\+]?\d+)$/;
function resolveEnotation(str, trimmedStr, options2) {
  if (!options2.eNotation) return str;
  const notation = trimmedStr.match(eNotationRegx);
  if (notation) {
    let sign = notation[1] || "";
    const eChar = notation[3].indexOf("e") === -1 ? "E" : "e";
    const leadingZeros = notation[2];
    const eAdjacentToLeadingZeros = sign ? (
      // 0E.
      str[leadingZeros.length + 1] === eChar
    ) : str[leadingZeros.length] === eChar;
    if (leadingZeros.length > 1 && eAdjacentToLeadingZeros) return str;
    else if (leadingZeros.length === 1 && (notation[3].startsWith(`.${eChar}`) || notation[3][0] === eChar)) {
      return Number(trimmedStr);
    } else if (options2.leadingZeros && !eAdjacentToLeadingZeros) {
      trimmedStr = (notation[1] || "") + notation[3];
      return Number(trimmedStr);
    } else return str;
  } else {
    return str;
  }
}
function trimZeros(numStr) {
  if (numStr && numStr.indexOf(".") !== -1) {
    numStr = numStr.replace(/0+$/, "");
    if (numStr === ".") numStr = "0";
    else if (numStr[0] === ".") numStr = "0" + numStr;
    else if (numStr[numStr.length - 1] === ".") numStr = numStr.substring(0, numStr.length - 1);
    return numStr;
  }
  return numStr;
}
function parse_int(numStr, base) {
  if (parseInt) return parseInt(numStr, base);
  else if (Number.parseInt) return Number.parseInt(numStr, base);
  else if (window && window.parseInt) return window.parseInt(numStr, base);
  else throw new Error("parseInt, Number.parseInt, window.parseInt are not supported");
}

// ../../.yarn/cache/fast-xml-parser-npm-5.2.5-4fd49da1b5-305017cff6.zip/node_modules/fast-xml-parser/src/ignoreAttributes.js
function getIgnoreAttributesFn(ignoreAttributes) {
  if (typeof ignoreAttributes === "function") {
    return ignoreAttributes;
  }
  if (Array.isArray(ignoreAttributes)) {
    return (attrName) => {
      for (const pattern of ignoreAttributes) {
        if (typeof pattern === "string" && attrName === pattern) {
          return true;
        }
        if (pattern instanceof RegExp && pattern.test(attrName)) {
          return true;
        }
      }
    };
  }
  return () => false;
}

// ../../.yarn/cache/fast-xml-parser-npm-5.2.5-4fd49da1b5-305017cff6.zip/node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js
var OrderedObjParser = class {
  constructor(options2) {
    this.options = options2;
    this.currentNode = null;
    this.tagsNodeStack = [];
    this.docTypeEntities = {};
    this.lastEntities = {
      "apos": { regex: /&(apos|#39|#x27);/g, val: "'" },
      "gt": { regex: /&(gt|#62|#x3E);/g, val: ">" },
      "lt": { regex: /&(lt|#60|#x3C);/g, val: "<" },
      "quot": { regex: /&(quot|#34|#x22);/g, val: '"' }
    };
    this.ampEntity = { regex: /&(amp|#38|#x26);/g, val: "&" };
    this.htmlEntities = {
      "space": { regex: /&(nbsp|#160);/g, val: " " },
      // "lt" : { regex: /&(lt|#60);/g, val: "<" },
      // "gt" : { regex: /&(gt|#62);/g, val: ">" },
      // "amp" : { regex: /&(amp|#38);/g, val: "&" },
      // "quot" : { regex: /&(quot|#34);/g, val: "\"" },
      // "apos" : { regex: /&(apos|#39);/g, val: "'" },
      "cent": { regex: /&(cent|#162);/g, val: "\xA2" },
      "pound": { regex: /&(pound|#163);/g, val: "\xA3" },
      "yen": { regex: /&(yen|#165);/g, val: "\xA5" },
      "euro": { regex: /&(euro|#8364);/g, val: "\u20AC" },
      "copyright": { regex: /&(copy|#169);/g, val: "\xA9" },
      "reg": { regex: /&(reg|#174);/g, val: "\xAE" },
      "inr": { regex: /&(inr|#8377);/g, val: "\u20B9" },
      "num_dec": { regex: /&#([0-9]{1,7});/g, val: (_, str) => String.fromCodePoint(Number.parseInt(str, 10)) },
      "num_hex": { regex: /&#x([0-9a-fA-F]{1,6});/g, val: (_, str) => String.fromCodePoint(Number.parseInt(str, 16)) }
    };
    this.addExternalEntities = addExternalEntities;
    this.parseXml = parseXml;
    this.parseTextData = parseTextData;
    this.resolveNameSpace = resolveNameSpace;
    this.buildAttributesMap = buildAttributesMap;
    this.isItStopNode = isItStopNode;
    this.replaceEntitiesValue = replaceEntitiesValue;
    this.readStopNodeData = readStopNodeData;
    this.saveTextToParentTag = saveTextToParentTag;
    this.addChild = addChild;
    this.ignoreAttributesFn = getIgnoreAttributesFn(this.options.ignoreAttributes);
  }
};
function addExternalEntities(externalEntities) {
  const entKeys = Object.keys(externalEntities);
  for (let i = 0; i < entKeys.length; i++) {
    const ent = entKeys[i];
    this.lastEntities[ent] = {
      regex: new RegExp("&" + ent + ";", "g"),
      val: externalEntities[ent]
    };
  }
}
function parseTextData(val, tagName, jPath, dontTrim, hasAttributes, isLeafNode, escapeEntities) {
  if (val !== void 0) {
    if (this.options.trimValues && !dontTrim) {
      val = val.trim();
    }
    if (val.length > 0) {
      if (!escapeEntities) val = this.replaceEntitiesValue(val);
      const newval = this.options.tagValueProcessor(tagName, val, jPath, hasAttributes, isLeafNode);
      if (newval === null || newval === void 0) {
        return val;
      } else if (typeof newval !== typeof val || newval !== val) {
        return newval;
      } else if (this.options.trimValues) {
        return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);
      } else {
        const trimmedVal = val.trim();
        if (trimmedVal === val) {
          return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);
        } else {
          return val;
        }
      }
    }
  }
}
function resolveNameSpace(tagname) {
  if (this.options.removeNSPrefix) {
    const tags = tagname.split(":");
    const prefix = tagname.charAt(0) === "/" ? "/" : "";
    if (tags[0] === "xmlns") {
      return "";
    }
    if (tags.length === 2) {
      tagname = prefix + tags[1];
    }
  }
  return tagname;
}
var attrsRegx = new RegExp(`([^\\s=]+)\\s*(=\\s*(['"])([\\s\\S]*?)\\3)?`, "gm");
function buildAttributesMap(attrStr, jPath, tagName) {
  if (this.options.ignoreAttributes !== true && typeof attrStr === "string") {
    const matches = getAllMatches(attrStr, attrsRegx);
    const len = matches.length;
    const attrs = {};
    for (let i = 0; i < len; i++) {
      const attrName = this.resolveNameSpace(matches[i][1]);
      if (this.ignoreAttributesFn(attrName, jPath)) {
        continue;
      }
      let oldVal = matches[i][4];
      let aName = this.options.attributeNamePrefix + attrName;
      if (attrName.length) {
        if (this.options.transformAttributeName) {
          aName = this.options.transformAttributeName(aName);
        }
        if (aName === "__proto__") aName = "#__proto__";
        if (oldVal !== void 0) {
          if (this.options.trimValues) {
            oldVal = oldVal.trim();
          }
          oldVal = this.replaceEntitiesValue(oldVal);
          const newVal = this.options.attributeValueProcessor(attrName, oldVal, jPath);
          if (newVal === null || newVal === void 0) {
            attrs[aName] = oldVal;
          } else if (typeof newVal !== typeof oldVal || newVal !== oldVal) {
            attrs[aName] = newVal;
          } else {
            attrs[aName] = parseValue(
              oldVal,
              this.options.parseAttributeValue,
              this.options.numberParseOptions
            );
          }
        } else if (this.options.allowBooleanAttributes) {
          attrs[aName] = true;
        }
      }
    }
    if (!Object.keys(attrs).length) {
      return;
    }
    if (this.options.attributesGroupName) {
      const attrCollection = {};
      attrCollection[this.options.attributesGroupName] = attrs;
      return attrCollection;
    }
    return attrs;
  }
}
var parseXml = function(xmlData) {
  xmlData = xmlData.replace(/\r\n?/g, "\n");
  const xmlObj = new XmlNode("!xml");
  let currentNode = xmlObj;
  let textData = "";
  let jPath = "";
  for (let i = 0; i < xmlData.length; i++) {
    const ch = xmlData[i];
    if (ch === "<") {
      if (xmlData[i + 1] === "/") {
        const closeIndex = findClosingIndex(xmlData, ">", i, "Closing Tag is not closed.");
        let tagName = xmlData.substring(i + 2, closeIndex).trim();
        if (this.options.removeNSPrefix) {
          const colonIndex = tagName.indexOf(":");
          if (colonIndex !== -1) {
            tagName = tagName.substr(colonIndex + 1);
          }
        }
        if (this.options.transformTagName) {
          tagName = this.options.transformTagName(tagName);
        }
        if (currentNode) {
          textData = this.saveTextToParentTag(textData, currentNode, jPath);
        }
        const lastTagName = jPath.substring(jPath.lastIndexOf(".") + 1);
        if (tagName && this.options.unpairedTags.indexOf(tagName) !== -1) {
          throw new Error(`Unpaired tag can not be used as closing tag: </${tagName}>`);
        }
        let propIndex = 0;
        if (lastTagName && this.options.unpairedTags.indexOf(lastTagName) !== -1) {
          propIndex = jPath.lastIndexOf(".", jPath.lastIndexOf(".") - 1);
          this.tagsNodeStack.pop();
        } else {
          propIndex = jPath.lastIndexOf(".");
        }
        jPath = jPath.substring(0, propIndex);
        currentNode = this.tagsNodeStack.pop();
        textData = "";
        i = closeIndex;
      } else if (xmlData[i + 1] === "?") {
        let tagData = readTagExp(xmlData, i, false, "?>");
        if (!tagData) throw new Error("Pi Tag is not closed.");
        textData = this.saveTextToParentTag(textData, currentNode, jPath);
        if (this.options.ignoreDeclaration && tagData.tagName === "?xml" || this.options.ignorePiTags) {
        } else {
          const childNode = new XmlNode(tagData.tagName);
          childNode.add(this.options.textNodeName, "");
          if (tagData.tagName !== tagData.tagExp && tagData.attrExpPresent) {
            childNode[":@"] = this.buildAttributesMap(tagData.tagExp, jPath, tagData.tagName);
          }
          this.addChild(currentNode, childNode, jPath, i);
        }
        i = tagData.closeIndex + 1;
      } else if (xmlData.substr(i + 1, 3) === "!--") {
        const endIndex = findClosingIndex(xmlData, "-->", i + 4, "Comment is not closed.");
        if (this.options.commentPropName) {
          const comment = xmlData.substring(i + 4, endIndex - 2);
          textData = this.saveTextToParentTag(textData, currentNode, jPath);
          currentNode.add(this.options.commentPropName, [{ [this.options.textNodeName]: comment }]);
        }
        i = endIndex;
      } else if (xmlData.substr(i + 1, 2) === "!D") {
        const result = readDocType(xmlData, i);
        this.docTypeEntities = result.entities;
        i = result.i;
      } else if (xmlData.substr(i + 1, 2) === "![") {
        const closeIndex = findClosingIndex(xmlData, "]]>", i, "CDATA is not closed.") - 2;
        const tagExp = xmlData.substring(i + 9, closeIndex);
        textData = this.saveTextToParentTag(textData, currentNode, jPath);
        let val = this.parseTextData(tagExp, currentNode.tagname, jPath, true, false, true, true);
        if (val == void 0) val = "";
        if (this.options.cdataPropName) {
          currentNode.add(this.options.cdataPropName, [{ [this.options.textNodeName]: tagExp }]);
        } else {
          currentNode.add(this.options.textNodeName, val);
        }
        i = closeIndex + 2;
      } else {
        let result = readTagExp(xmlData, i, this.options.removeNSPrefix);
        let tagName = result.tagName;
        const rawTagName = result.rawTagName;
        let tagExp = result.tagExp;
        let attrExpPresent = result.attrExpPresent;
        let closeIndex = result.closeIndex;
        if (this.options.transformTagName) {
          tagName = this.options.transformTagName(tagName);
        }
        if (currentNode && textData) {
          if (currentNode.tagname !== "!xml") {
            textData = this.saveTextToParentTag(textData, currentNode, jPath, false);
          }
        }
        const lastTag = currentNode;
        if (lastTag && this.options.unpairedTags.indexOf(lastTag.tagname) !== -1) {
          currentNode = this.tagsNodeStack.pop();
          jPath = jPath.substring(0, jPath.lastIndexOf("."));
        }
        if (tagName !== xmlObj.tagname) {
          jPath += jPath ? "." + tagName : tagName;
        }
        const startIndex = i;
        if (this.isItStopNode(this.options.stopNodes, jPath, tagName)) {
          let tagContent = "";
          if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
            if (tagName[tagName.length - 1] === "/") {
              tagName = tagName.substr(0, tagName.length - 1);
              jPath = jPath.substr(0, jPath.length - 1);
              tagExp = tagName;
            } else {
              tagExp = tagExp.substr(0, tagExp.length - 1);
            }
            i = result.closeIndex;
          } else if (this.options.unpairedTags.indexOf(tagName) !== -1) {
            i = result.closeIndex;
          } else {
            const result2 = this.readStopNodeData(xmlData, rawTagName, closeIndex + 1);
            if (!result2) throw new Error(`Unexpected end of ${rawTagName}`);
            i = result2.i;
            tagContent = result2.tagContent;
          }
          const childNode = new XmlNode(tagName);
          if (tagName !== tagExp && attrExpPresent) {
            childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
          }
          if (tagContent) {
            tagContent = this.parseTextData(tagContent, tagName, jPath, true, attrExpPresent, true, true);
          }
          jPath = jPath.substr(0, jPath.lastIndexOf("."));
          childNode.add(this.options.textNodeName, tagContent);
          this.addChild(currentNode, childNode, jPath, startIndex);
        } else {
          if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
            if (tagName[tagName.length - 1] === "/") {
              tagName = tagName.substr(0, tagName.length - 1);
              jPath = jPath.substr(0, jPath.length - 1);
              tagExp = tagName;
            } else {
              tagExp = tagExp.substr(0, tagExp.length - 1);
            }
            if (this.options.transformTagName) {
              tagName = this.options.transformTagName(tagName);
            }
            const childNode = new XmlNode(tagName);
            if (tagName !== tagExp && attrExpPresent) {
              childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
            }
            this.addChild(currentNode, childNode, jPath, startIndex);
            jPath = jPath.substr(0, jPath.lastIndexOf("."));
          } else {
            const childNode = new XmlNode(tagName);
            this.tagsNodeStack.push(currentNode);
            if (tagName !== tagExp && attrExpPresent) {
              childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
            }
            this.addChild(currentNode, childNode, jPath, startIndex);
            currentNode = childNode;
          }
          textData = "";
          i = closeIndex;
        }
      }
    } else {
      textData += xmlData[i];
    }
  }
  return xmlObj.child;
};
function addChild(currentNode, childNode, jPath, startIndex) {
  if (!this.options.captureMetaData) startIndex = void 0;
  const result = this.options.updateTag(childNode.tagname, jPath, childNode[":@"]);
  if (result === false) {
  } else if (typeof result === "string") {
    childNode.tagname = result;
    currentNode.addChild(childNode, startIndex);
  } else {
    currentNode.addChild(childNode, startIndex);
  }
}
var replaceEntitiesValue = function(val) {
  if (this.options.processEntities) {
    for (let entityName in this.docTypeEntities) {
      const entity = this.docTypeEntities[entityName];
      val = val.replace(entity.regx, entity.val);
    }
    for (let entityName in this.lastEntities) {
      const entity = this.lastEntities[entityName];
      val = val.replace(entity.regex, entity.val);
    }
    if (this.options.htmlEntities) {
      for (let entityName in this.htmlEntities) {
        const entity = this.htmlEntities[entityName];
        val = val.replace(entity.regex, entity.val);
      }
    }
    val = val.replace(this.ampEntity.regex, this.ampEntity.val);
  }
  return val;
};
function saveTextToParentTag(textData, currentNode, jPath, isLeafNode) {
  if (textData) {
    if (isLeafNode === void 0) isLeafNode = currentNode.child.length === 0;
    textData = this.parseTextData(
      textData,
      currentNode.tagname,
      jPath,
      false,
      currentNode[":@"] ? Object.keys(currentNode[":@"]).length !== 0 : false,
      isLeafNode
    );
    if (textData !== void 0 && textData !== "")
      currentNode.add(this.options.textNodeName, textData);
    textData = "";
  }
  return textData;
}
function isItStopNode(stopNodes, jPath, currentTagName) {
  const allNodesExp = "*." + currentTagName;
  for (const stopNodePath in stopNodes) {
    const stopNodeExp = stopNodes[stopNodePath];
    if (allNodesExp === stopNodeExp || jPath === stopNodeExp) return true;
  }
  return false;
}
function tagExpWithClosingIndex(xmlData, i, closingChar = ">") {
  let attrBoundary;
  let tagExp = "";
  for (let index = i; index < xmlData.length; index++) {
    let ch = xmlData[index];
    if (attrBoundary) {
      if (ch === attrBoundary) attrBoundary = "";
    } else if (ch === '"' || ch === "'") {
      attrBoundary = ch;
    } else if (ch === closingChar[0]) {
      if (closingChar[1]) {
        if (xmlData[index + 1] === closingChar[1]) {
          return {
            data: tagExp,
            index
          };
        }
      } else {
        return {
          data: tagExp,
          index
        };
      }
    } else if (ch === "	") {
      ch = " ";
    }
    tagExp += ch;
  }
}
function findClosingIndex(xmlData, str, i, errMsg) {
  const closingIndex = xmlData.indexOf(str, i);
  if (closingIndex === -1) {
    throw new Error(errMsg);
  } else {
    return closingIndex + str.length - 1;
  }
}
function readTagExp(xmlData, i, removeNSPrefix, closingChar = ">") {
  const result = tagExpWithClosingIndex(xmlData, i + 1, closingChar);
  if (!result) return;
  let tagExp = result.data;
  const closeIndex = result.index;
  const separatorIndex = tagExp.search(/\s/);
  let tagName = tagExp;
  let attrExpPresent = true;
  if (separatorIndex !== -1) {
    tagName = tagExp.substring(0, separatorIndex);
    tagExp = tagExp.substring(separatorIndex + 1).trimStart();
  }
  const rawTagName = tagName;
  if (removeNSPrefix) {
    const colonIndex = tagName.indexOf(":");
    if (colonIndex !== -1) {
      tagName = tagName.substr(colonIndex + 1);
      attrExpPresent = tagName !== result.data.substr(colonIndex + 1);
    }
  }
  return {
    tagName,
    tagExp,
    closeIndex,
    attrExpPresent,
    rawTagName
  };
}
function readStopNodeData(xmlData, tagName, i) {
  const startIndex = i;
  let openTagCount = 1;
  for (; i < xmlData.length; i++) {
    if (xmlData[i] === "<") {
      if (xmlData[i + 1] === "/") {
        const closeIndex = findClosingIndex(xmlData, ">", i, `${tagName} is not closed`);
        let closeTagName = xmlData.substring(i + 2, closeIndex).trim();
        if (closeTagName === tagName) {
          openTagCount--;
          if (openTagCount === 0) {
            return {
              tagContent: xmlData.substring(startIndex, i),
              i: closeIndex
            };
          }
        }
        i = closeIndex;
      } else if (xmlData[i + 1] === "?") {
        const closeIndex = findClosingIndex(xmlData, "?>", i + 1, "StopNode is not closed.");
        i = closeIndex;
      } else if (xmlData.substr(i + 1, 3) === "!--") {
        const closeIndex = findClosingIndex(xmlData, "-->", i + 3, "StopNode is not closed.");
        i = closeIndex;
      } else if (xmlData.substr(i + 1, 2) === "![") {
        const closeIndex = findClosingIndex(xmlData, "]]>", i, "StopNode is not closed.") - 2;
        i = closeIndex;
      } else {
        const tagData = readTagExp(xmlData, i, ">");
        if (tagData) {
          const openTagName = tagData && tagData.tagName;
          if (openTagName === tagName && tagData.tagExp[tagData.tagExp.length - 1] !== "/") {
            openTagCount++;
          }
          i = tagData.closeIndex;
        }
      }
    }
  }
}
function parseValue(val, shouldParse, options2) {
  if (shouldParse && typeof val === "string") {
    const newval = val.trim();
    if (newval === "true") return true;
    else if (newval === "false") return false;
    else return toNumber(val, options2);
  } else {
    if (isExist(val)) {
      return val;
    } else {
      return "";
    }
  }
}

// ../../.yarn/cache/fast-xml-parser-npm-5.2.5-4fd49da1b5-305017cff6.zip/node_modules/fast-xml-parser/src/xmlparser/node2json.js
var METADATA_SYMBOL2 = XmlNode.getMetaDataSymbol();
function prettify(node, options2) {
  return compress(node, options2);
}
function compress(arr, options2, jPath) {
  let text;
  const compressedObj = {};
  for (let i = 0; i < arr.length; i++) {
    const tagObj = arr[i];
    const property = propName(tagObj);
    let newJpath = "";
    if (jPath === void 0) newJpath = property;
    else newJpath = jPath + "." + property;
    if (property === options2.textNodeName) {
      if (text === void 0) text = tagObj[property];
      else text += "" + tagObj[property];
    } else if (property === void 0) {
      continue;
    } else if (tagObj[property]) {
      let val = compress(tagObj[property], options2, newJpath);
      const isLeaf = isLeafTag(val, options2);
      if (tagObj[METADATA_SYMBOL2] !== void 0) {
        val[METADATA_SYMBOL2] = tagObj[METADATA_SYMBOL2];
      }
      if (tagObj[":@"]) {
        assignAttributes(val, tagObj[":@"], newJpath, options2);
      } else if (Object.keys(val).length === 1 && val[options2.textNodeName] !== void 0 && !options2.alwaysCreateTextNode) {
        val = val[options2.textNodeName];
      } else if (Object.keys(val).length === 0) {
        if (options2.alwaysCreateTextNode) val[options2.textNodeName] = "";
        else val = "";
      }
      if (compressedObj[property] !== void 0 && compressedObj.hasOwnProperty(property)) {
        if (!Array.isArray(compressedObj[property])) {
          compressedObj[property] = [compressedObj[property]];
        }
        compressedObj[property].push(val);
      } else {
        if (options2.isArray(property, newJpath, isLeaf)) {
          compressedObj[property] = [val];
        } else {
          compressedObj[property] = val;
        }
      }
    }
  }
  if (typeof text === "string") {
    if (text.length > 0) compressedObj[options2.textNodeName] = text;
  } else if (text !== void 0) compressedObj[options2.textNodeName] = text;
  return compressedObj;
}
function propName(obj) {
  const keys = Object.keys(obj);
  for (let i = 0; i < keys.length; i++) {
    const key = keys[i];
    if (key !== ":@") return key;
  }
}
function assignAttributes(obj, attrMap, jpath, options2) {
  if (attrMap) {
    const keys = Object.keys(attrMap);
    const len = keys.length;
    for (let i = 0; i < len; i++) {
      const atrrName = keys[i];
      if (options2.isArray(atrrName, jpath + "." + atrrName, true, true)) {
        obj[atrrName] = [attrMap[atrrName]];
      } else {
        obj[atrrName] = attrMap[atrrName];
      }
    }
  }
}
function isLeafTag(obj, options2) {
  const { textNodeName } = options2;
  const propCount = Object.keys(obj).length;
  if (propCount === 0) {
    return true;
  }
  if (propCount === 1 && (obj[textNodeName] || typeof obj[textNodeName] === "boolean" || obj[textNodeName] === 0)) {
    return true;
  }
  return false;
}

// ../../.yarn/cache/fast-xml-parser-npm-5.2.5-4fd49da1b5-305017cff6.zip/node_modules/fast-xml-parser/src/xmlparser/XMLParser.js
var XMLParser = class {
  constructor(options2) {
    this.externalEntities = {};
    this.options = buildOptions(options2);
  }
  /**
   * Parse XML dats to JS object 
   * @param {string|Buffer} xmlData 
   * @param {boolean|Object} validationOption 
   */
  parse(xmlData, validationOption) {
    if (typeof xmlData === "string") {
    } else if (xmlData.toString) {
      xmlData = xmlData.toString();
    } else {
      throw new Error("XML data is accepted in String or Bytes[] form.");
    }
    if (validationOption) {
      if (validationOption === true) validationOption = {};
      const result = validate(xmlData, validationOption);
      if (result !== true) {
        throw Error(`${result.err.msg}:${result.err.line}:${result.err.col}`);
      }
    }
    const orderedObjParser = new OrderedObjParser(this.options);
    orderedObjParser.addExternalEntities(this.externalEntities);
    const orderedResult = orderedObjParser.parseXml(xmlData);
    if (this.options.preserveOrder || orderedResult === void 0) return orderedResult;
    else return prettify(orderedResult, this.options);
  }
  /**
   * Add Entity which is not by default supported by this library
   * @param {string} key 
   * @param {string} value 
   */
  addEntity(key, value) {
    if (value.indexOf("&") !== -1) {
      throw new Error("Entity value can't have '&'");
    } else if (key.indexOf("&") !== -1 || key.indexOf(";") !== -1) {
      throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'");
    } else if (value === "&") {
      throw new Error("An entity with value '&' is not permitted");
    } else {
      this.externalEntities[key] = value;
    }
  }
  /**
   * Returns a Symbol that can be used to access the metadata
   * property on a node.
   * 
   * If Symbol is not available in the environment, an ordinary property is used
   * and the name of the property is here returned.
   * 
   * The XMLMetaData property is only present when `captureMetaData`
   * is true in the options.
   */
  static getMetaDataSymbol() {
    return XmlNode.getMetaDataSymbol();
  }
};

// ../parser/src/parser.ts
var isArrayProperty = [
  "type",
  "include",
  "c:include",
  "member",
  "parameter",
  "parameters",
  "return-value",
  "class",
  "constructor",
  "constructors",
  "method",
  "virtual-method",
  "property",
  "field",
  "constant",
  "enumeration",
  "bitfield",
  "alias",
  "function",
  "callback",
  "record",
  "union",
  "interface",
  "namespace",
  "repository",
  "package",
  "glib:boxed",
  "implements",
  "prerequisite",
  "doc",
  "doc-deprecated",
  "signal",
  "glib:signal",
  "annotation",
  "stability",
  "doc-version",
  "doc-stability",
  "source-position",
  "column",
  "array",
  "moved-to",
  "varargs",
  "instance-parameter"
];
var numericAttributes = ["fixed-size", "length", "closure", "destroy", "bits"];
var parser = new XMLParser({
  attributeNamePrefix: "",
  attributesGroupName: "$",
  // default is 'false',
  textNodeName: "_",
  ignoreAttributes: false,
  removeNSPrefix: false,
  allowBooleanAttributes: true,
  parseTagValue: true,
  parseAttributeValue: false,
  trimValues: true,
  isArray: (name, _jpath, isLeafNode, _isAttribute) => {
    if (isArrayProperty.includes(name)) {
      return true;
    }
    return !isLeafNode;
  }
});
function transformNumericAttributes(obj) {
  if (obj === null || typeof obj !== "object") {
    return obj;
  }
  if (Array.isArray(obj)) {
    return obj.map(transformNumericAttributes);
  }
  const result = { ...obj };
  if (result.$ && typeof result.$ === "object") {
    const attrs = result.$;
    for (const attr of numericAttributes) {
      if (attr in attrs && typeof attrs[attr] === "string") {
        const numValue = Number.parseInt(attrs[attr], 10);
        if (!Number.isNaN(numValue)) {
          attrs[attr] = numValue;
        }
      }
    }
  }
  for (const key in result) {
    if (key !== "$" && result[key] !== null && typeof result[key] === "object") {
      result[key] = transformNumericAttributes(result[key]);
    }
  }
  return result;
}
function parseGir(contents) {
  const parsed = parser.parse(contents);
  return transformNumericAttributes(parsed);
}

// ../lib/src/library-version.ts
var LibraryVersion = class {
  major;
  minor;
  patch;
  constructor(constants2 = [], version = "0.0.0") {
    const [_major, _minor, _micro] = version.split(".").filter((v) => v !== "");
    if (_major) {
      this.major = Number(_major) || void 0;
    }
    if (_minor) {
      this.minor = Number(_minor) || void 0;
    }
    if (_micro) {
      this.patch = Number(_micro) || void 0;
    }
    for (const constant of constants2) {
      if (constant.$.name === "MAJOR_VERSION" || constant.$.name === "VERSION_MAJOR" && constant.$.value) {
        this.major = Number(constant.$.value) || void 0;
      }
      if (constant.$.name === "MINOR_VERSION" || constant.$.name === "VERSION_MINOR" && constant.$.value) {
        this.minor = Number(constant.$.value) || void 0;
      }
      if (constant.$.name === "MICRO_VERSION" || constant.$.name === "VERSION_MICRO" && constant.$.value) {
        this.patch = Number(constant.$.value) || void 0;
      }
    }
  }
  toString() {
    return `${this.major || "0"}.${this.minor || "0"}.${this.patch || "0"}`;
  }
  /** Compare two library versions and return -1 if this version is greater than the other, 1 if this version is less than the other, and 0 if they are equal. */
  compare(other) {
    if (this.major !== other.major) {
      return (this.major || 0) > (other.major || 0) ? -1 : 1;
    }
    if (this.minor !== other.minor) {
      return (this.minor || 0) > (other.minor || 0) ? -1 : 1;
    }
    if (this.patch !== other.patch) {
      return (this.patch || 0) > (other.patch || 0) ? -1 : 1;
    }
    return 0;
  }
};

// ../lib/src/logger.ts
import { blue as blue3, gray as gray2, green as green3, red as red3, yellow as yellow3, yellowBright as yellowBright2 } from "colorette";
var Logger = class _Logger {
  verbose;
  moduleName;
  constructor(verbose, moduleName) {
    this.verbose = verbose;
    this.moduleName = moduleName;
  }
  static prepend(txt, prepend) {
    if (typeof txt === "string") {
      txt = `${prepend}${txt}`;
    }
    return txt;
  }
  /**
   * Returns something like '[node][Gda-5.0] Could not find type 'Gda.SqlExpr' for 'expr''
   * @param txt
   * @param logLevel
   */
  prependInfo(txt, logLevel) {
    if (logLevel || this.moduleName.length > 0) {
      txt = _Logger.prepend(txt, " ");
    }
    if (logLevel) {
      if (this.moduleName.length > 0) {
        txt = _Logger.prepend(txt, ` ${logLevel}`);
      } else {
        txt = _Logger.prepend(txt, logLevel);
      }
    }
    if (this.moduleName.length > 0) {
      txt = _Logger.prepend(txt, `[${this.moduleName}]`);
    }
    return txt;
  }
  log(...args) {
    if (!this.verbose) {
      return;
    }
    console.log(...args);
  }
  dir(...args) {
    if (!this.verbose) {
      return;
    }
    args.forEach((arg) => {
      console.dir(arg);
    });
    return;
  }
  info(txt, ...args) {
    if (!this.verbose) {
      return;
    }
    console.info(blue3(txt), ...args);
  }
  warn(txt, ...args) {
    if (!this.verbose) {
      return;
    }
    txt = this.prependInfo(txt, "WARN:");
    console.warn(yellow3(txt), ...args);
  }
  debug(txt, ...args) {
    if (!this.verbose) {
      return;
    }
    txt = this.prependInfo(txt, "DEBUG:");
    console.debug(yellowBright2(txt), ...args);
  }
  error(txt, ...args) {
    txt = this.prependInfo(txt, "ERROR:");
    this.danger(txt, ...args);
  }
  success(txt, ...args) {
    if (!this.verbose) {
      return;
    }
    this.log(green3(txt), ...args);
  }
  danger(txt, ...args) {
    console.error(red3(txt), ...args);
  }
  muted(txt, ...args) {
    this.log(gray2(txt), ...args);
  }
  white(txt, ...args) {
    this.log(txt, ...args);
  }
  yellow(txt, ...args) {
    this.log(yellow3(txt), ...args);
  }
  gray(txt, ...args) {
    this.log(gray2(txt), ...args);
  }
};

// ../lib/src/utils/files.ts
import { constants } from "node:fs";
import { access, readFile } from "node:fs/promises";
import { join as join3 } from "node:path";
import { glob } from "glob";
var fileExists = async (filePath) => {
  try {
    await access(filePath, constants.F_OK);
    return true;
  } catch {
    return false;
  }
};
var findFilesInDirs = async (dirs, filename) => {
  const filesInfo = [];
  const pattern = dirs.map((dir) => join3(dir, filename));
  const _files = await glob(pattern);
  const files = [...new Set(_files)];
  for (const filePath of files) {
    const fileInfo = {
      path: null,
      filename,
      exists: false
    };
    fileInfo.exists = await fileExists(filePath);
    if (fileInfo.exists) {
      fileInfo.path = filePath;
      filesInfo.push(fileInfo);
    }
  }
  if (filesInfo.length === 0) {
    filesInfo.push({
      path: null,
      filename,
      exists: false
    });
  }
  return filesInfo;
};

// ../lib/src/utils/girs.ts
var splitModuleName = (packageName) => {
  if (packageName.startsWith("Vte-4")) {
    return {
      packageName,
      namespace: "Vte",
      version: packageName.replace("Vte-", "")
    };
  }
  if (!packageName.includes("-")) {
    return {
      packageName,
      namespace: packageName,
      version: ""
    };
  }
  const splits = packageName.split("-");
  const version = splits.splice(-1, 1)[0];
  const namespace = splits.join("");
  return {
    packageName,
    namespace,
    version
  };
};
var removeNamespace = (type, namespace) => {
  if (type.startsWith(`${namespace}.`)) {
    type = type.substring(namespace.length + 1);
  }
  return type;
};
var removeClassModule = removeNamespace;
var printGirDocComment = (tsDoc, config) => {
  const desc = [];
  if (config.noComments) {
    return desc.join("\n");
  }
  const text = tsDoc.text;
  if (text) {
    if (text) {
      const lines = text.split("\n");
      if (lines.length) {
        for (const line of lines) {
          desc.push(`${line}`);
        }
      }
    }
    for (const tag of tsDoc.tags) {
      if (tag.paramName) {
        desc.push(`@${tag.tagName} ${tag.paramName} ${tag.text}`);
      } else {
        desc.push(`@${tag.tagName} ${tag.text}`);
      }
    }
  }
  return desc.join("\n");
};
var isIntrospectable = (e) => !e || !e.$ || !e.$.introspectable || e.$.introspectable === "1";
var isDeprecated = (e) => e?.$ && e.$.deprecated === "1";
var deprecatedVersion = (e) => e?.$?.["deprecated-version"];
var introducedVersion = (e) => e?.$?.version;

// ../lib/src/utils/numbers.ts
var isNumeric = (str) => {
  return !Number.isNaN(Number(str) - parseFloat(str));
};

// ../lib/src/utils/strings.ts
var getFirstChar = (str) => {
  return str.charAt(0);
};
var isFirstCharNumeric = (str) => {
  return isNumeric(getFirstChar(str));
};
var camelCase = (str) => {
  return str.replace(/\s(.)|(\s|-|_|\.)(.)/g, (a) => {
    return a.toUpperCase();
  }).replace(/(\s|-|_|\.)/g, "");
};
var pascalCase = (str) => {
  str = camelCase(str);
  str = getFirstChar(str).toUpperCase() + str.slice(1);
  return str;
};
var upperCamelCase = pascalCase;
var generateIndent = (indents = 1, spaceForIndent = 4) => {
  return " ".repeat(indents * spaceForIndent);
};

// ../lib/src/utils/naming.ts
var reservedWords = [
  "abstract",
  "arguments",
  "await",
  "boolean",
  "break",
  "byte",
  "case",
  "catch",
  "char",
  "class",
  "const",
  "continue",
  "constructor",
  // This isn't technically reserved, but it's problematic.
  "debugger",
  "default",
  "delete",
  "do",
  "else",
  "enum",
  "eval",
  "export",
  "extends",
  "false",
  "final",
  "finally",
  "for",
  "function",
  "goto",
  "if",
  "implements",
  "import",
  "in",
  "instanceof",
  "interface",
  "let",
  "native",
  "new",
  "null",
  "package",
  "private",
  "protected",
  "public",
  "return",
  "short",
  "static",
  "super",
  "switch",
  "synchronized",
  "this",
  "throw",
  "throws",
  "transient",
  "true",
  "try",
  "typeof",
  "var",
  "void",
  "volatile",
  "while",
  "with",
  "yield"
];
var SanitizedIdentifiers = /* @__PURE__ */ new Map();
function transformImportName(packageName) {
  return packageName.toLowerCase();
}
function transformModuleNamespaceName(name) {
  name = transformNumericName(name);
  name = upperCamelCase(name);
  if (RESERVED_NAMESPACE_NAMES[name]) {
    name = `${name}_`;
  }
  return name;
}
function transformNumericName(name) {
  if (isFirstCharNumeric(name)) {
    name = `TODO_${name}`;
  }
  return name;
}
function sanitizeIdentifierName(namespace, name) {
  if (name === "") {
    return "''";
  }
  let sanitized_name = name.replace(/[^A-z0-9_]/gi, "_");
  if (reservedWords.includes(sanitized_name)) {
    sanitized_name = `__${sanitized_name}`;
  }
  if (sanitized_name.match(/^[^A-z_]/) != null) {
    sanitized_name = `__${sanitized_name}`;
  }
  if (namespace && sanitized_name !== name) {
    SanitizedIdentifiers.set(`${namespace}.${name}`, `${namespace}.${sanitized_name}`);
  }
  return sanitized_name;
}
function sanitizeNamespace(namespace) {
  if (namespace === "Tracker_Vala") {
    return "Tracker";
  }
  return namespace;
}
function sanitizeMemberName(name) {
  if (name === "") {
    return "''";
  }
  return name.replace(/[^A-z0-9_]/gi, "_");
}
function isInvalid(name) {
  if (reservedWords.includes(name)) {
    return true;
  }
  const sanitized = sanitizeMemberName(name);
  if (sanitized.match(/^[^A-z_]/) != null) {
    return true;
  }
  return false;
}

// ../lib/src/dependency-manager.ts
var DependencyManager = class _DependencyManager {
  log;
  config;
  _cache = {};
  static instances = {};
  constructor(config) {
    this.config = config;
    this.log = new Logger(config.verbose, "DependencyManager");
  }
  /**
   * Get the DependencyManager singleton instance
   */
  static getInstance(config) {
    const configKey = config ? JSON.stringify(config) : Object.keys(_DependencyManager.instances)[0];
    if (_DependencyManager.instances[configKey]) {
      return _DependencyManager.instances[configKey];
    }
    if (!config) {
      throw new Error("config parameter is required to initialize DependencyManager");
    }
    const instance = new _DependencyManager(config);
    _DependencyManager.instances[configKey] = instance;
    return instance;
  }
  parsePackageName(namespaceOrPackageName, version) {
    let packageName;
    let namespace;
    if (version) {
      namespace = namespaceOrPackageName;
      packageName = `${namespace}-${version}`;
    } else {
      packageName = namespaceOrPackageName;
      const { namespace: _namespace, version: _version } = splitModuleName(packageName);
      namespace = _namespace;
      version = _version;
    }
    return { packageName, namespace, version };
  }
  parseArgs(namespaceOrPackageNameOrRepo, version, noOverride) {
    let packageName;
    let namespace;
    let repo = null;
    if (typeof namespaceOrPackageNameOrRepo === "string") {
      if (!noOverride && namespaceOrPackageNameOrRepo === "Gjs") {
        return { ...this.getGjs(), repo: null };
      }
      const args = this.parsePackageName(namespaceOrPackageNameOrRepo, version);
      version = args.version;
      packageName = args.packageName;
      namespace = args.namespace;
    } else {
      repo = namespaceOrPackageNameOrRepo;
      const ns = repo.namespace?.[0];
      if (!ns) {
        throw new Error("Invalid GirRepository");
      }
      version = ns.$.version;
      namespace = ns.$.name;
      packageName = `${namespace}-${version}`;
    }
    return { packageName, namespace, version, repo };
  }
  /**
   * Get all dependencies in the cache
   * @returns All dependencies in the cache
   */
  all() {
    return Object.values(this._cache);
  }
  getAllPackageNames() {
    return Object.keys(this._cache);
  }
  /**
   * Get the core dependencies
   * @returns
   */
  async core() {
    return [
      await this.get("GObject", "2.0"),
      await this.get("GLib", "2.0"),
      await this.get("Gio", "2.0"),
      await this.get("cairo", "1.0")
    ];
  }
  createImportProperties(namespace, packageName, version) {
    const importPath = this.createImportPath(packageName, namespace, version);
    const importDef = this.createImportDef(namespace, importPath);
    const packageJsonImport = this.createPackageJsonImport(importPath);
    return {
      importPath,
      importDef,
      packageJsonImport
    };
  }
  createImportPath(packageName, namespace, version) {
    if (!this.config.package) {
      return `gi://${namespace}?version=${version}`;
    }
    const importName = transformImportName(packageName);
    const importPath = `${this.config.npmScope}/${importName}`;
    return importPath;
  }
  createImportDef(namespace, importPath) {
    return this.config.noNamespace ? `import type * as ${namespace} from '${importPath}'` : `import type ${namespace} from '${importPath}';`;
  }
  createPackageJsonImport(importPath) {
    const depVersion = this.config.workspace ? "workspace:^" : "*";
    return `"${importPath}": "${depVersion}"`;
  }
  async parseGir(path) {
    const girXML = parser_exports.parseGir(await readFile2(path, "utf8"));
    const repo = girXML.repository[0];
    const ns = repo?.namespace?.[0];
    const version = ns?.$.version;
    return { girXML, repo, ns, version };
  }
  async parseGirAndReturnLatestVersion(filesInfo) {
    const libraryVersions = [];
    if (filesInfo.length > 1) {
      this.log.warn(`Multiple paths found for ${filesInfo[0].filename}`);
    }
    for (const fileInfo of filesInfo) {
      if (!fileInfo.exists || !fileInfo.path) {
        continue;
      }
      const { girXML, ns, version } = await this.parseGir(fileInfo.path);
      if (!version || !ns) {
        continue;
      }
      const libraryVersion = new LibraryVersion(ns?.constant, version);
      if (filesInfo.length > 1) {
        this.log.muted(` - ${fileInfo.path} (${libraryVersion.toString()})`);
      }
      libraryVersions.push({
        libraryVersion,
        girXML,
        fileInfo
      });
    }
    const latestLibraryVersion = libraryVersions.sort((a, b) => a.libraryVersion.compare(b.libraryVersion))[0];
    if (!latestLibraryVersion) {
      this.log.warn("No latest library version found", {
        libraryVersions,
        filesInfo
      });
      return {
        libraryVersion: new LibraryVersion(),
        girXML: null,
        fileInfo: filesInfo[0]
      };
    }
    if (filesInfo.length > 1) {
      this.log.muted(
        `Use latest version ${latestLibraryVersion.libraryVersion.toString()} from ${latestLibraryVersion.fileInfo.path}`
      );
    }
    return latestLibraryVersion;
  }
  async get(namespaceOrPackageNameOrRepo, _version, noOverride) {
    const parsedArgs = this.parseArgs(namespaceOrPackageNameOrRepo, _version, noOverride);
    const { packageName, repo } = parsedArgs;
    let { namespace, version } = parsedArgs;
    namespace = sanitizeNamespace(namespace);
    if (this._cache[packageName]) {
      const dep = this._cache[packageName];
      return dep;
    }
    const filename = `${packageName}.gir`;
    const filesInfo = await findFilesInDirs(this.config.girDirectories, filename);
    const { libraryVersion, girXML, fileInfo } = await this.parseGirAndReturnLatestVersion(filesInfo);
    const ns = girXML?.repository[0]?.namespace?.[0] || repo?.namespace?.[0] || null;
    if (ns?.$.version) {
      version = ns?.$.version;
    }
    if (ns?.$.name) {
      namespace = ns?.$.name;
    }
    const dependency = {
      ...fileInfo,
      namespace,
      packageName,
      importName: transformImportName(packageName),
      importNamespace: transformModuleNamespaceName(packageName),
      version,
      libraryVersion,
      girXML,
      ...this.createImportProperties(namespace, packageName, version)
    };
    if (!noOverride && namespace === "cairo" && version === "1.0") {
      dependency.importDef = this.createImportDef("cairo", "cairo");
    }
    this._cache[packageName] = dependency;
    return dependency;
  }
  /**
   * Get all dependencies with the given namespace
   * @param namespace The namespace of the dependency
   * @returns All dependencies with the given namespace
   */
  list(namespace) {
    const packageNames = this.all();
    const candidates = packageNames.filter((dep) => {
      return dep.namespace === namespace && dep.exists;
    });
    return candidates;
  }
  /**
   * Get girModule for dependency
   * @param girModules
   * @param packageName
   */
  getModule(girModules, dep) {
    return girModules.find(
      (m) => m.packageName === dep.packageName && m.namespace === dep.namespace && m.version === dep.version
    );
  }
  /**
   * Add all dependencies from an array of gir modules
   * @param girModules
   */
  async addAll(girModules) {
    for (const girModule of girModules) {
      await this.get(girModule.namespace, girModule.version || "0.0");
    }
    return this.all();
  }
  /**
   * Transforms a gir include object array to a dependency object array
   * @param girIncludes - Array of gir includes
   * @returns Array of dependencies
   */
  async fromGirIncludes(girIncludes) {
    const dependencies = [];
    for (const i of girIncludes) {
      dependencies.unshift(await this.get(i.$.name, i.$.version || "0.0"));
    }
    return dependencies;
  }
  /**
   * Check if multiple dependencies with the given namespace exist in the cache
   * @param namespace The namespace of the dependency
   * @returns
   */
  hasConflict(namespace) {
    const packageNames = this.getAllPackageNames();
    const candidates = packageNames.filter((packageName) => {
      return packageName.startsWith(`${namespace}-`) && this._cache[packageName].namespace === namespace;
    });
    return candidates.length > 1;
  }
  /**
   * get the latest version of the dependency with the given namespace
   * @param namespace The namespace of the dependency
   * @returns The latest version of the dependency
   */
  getLatestVersion(namespace) {
    const candidates = this.list(namespace);
    const latestVersion = candidates.sort((a, b) => {
      return a.version.localeCompare(b.version);
    }).pop();
    return latestVersion;
  }
  /**
   * Check if the given version is the latest version of the dependency
   * @param namespace The namespace of the dependency
   * @param version The version of the dependency
   * @returns
   */
  isLatestVersion(namespace, version) {
    const latestVersion = this.getLatestVersion(namespace);
    return latestVersion?.version === version;
  }
  /**
   * Find a dependency by it's namespace from the cache, if multiple versions are found, the latest version is returned
   * @param namespace The namespace of the dependency
   * @returns The dependency object or null if not found
   */
  find(namespace) {
    if (namespace === "Gjs") {
      return this.getGjs();
    }
    const packageNames = this.getAllPackageNames();
    const candidates = packageNames.filter((packageName) => {
      return packageName.startsWith(`${namespace}-`) && this._cache[packageName].namespace === namespace;
    });
    if (candidates.length > 1) {
      this.log.warn(`Found multiple versions of ${namespace}: ${candidates.join(", ")}`);
    }
    const latestVersion = candidates.sort().pop();
    if (latestVersion && this._cache[latestVersion]) {
      const dep = this._cache[latestVersion];
      return dep;
    }
    return null;
  }
  getPseudoPackage(packageName, namespace = pascalCase(packageName), version = "2.0") {
    if (this._cache[`${packageName}_pseudo`]) {
      return this._cache[`${packageName}_pseudo`];
    }
    const dep = {
      namespace,
      exists: true,
      filename: "",
      path: "",
      packageName,
      importName: transformImportName(packageName),
      importNamespace: transformModuleNamespaceName(packageName),
      version,
      libraryVersion: new LibraryVersion(),
      girXML: null,
      ...this.createImportProperties(packageName, packageName, version)
    };
    this._cache[`${packageName}_pseudo`] = dep;
    return dep;
  }
  getGjs() {
    return this.getPseudoPackage("Gjs");
  }
};

// ../lib/src/formatters/formatter.ts
var Formatter = class {
};

// ../lib/src/formatters/default.ts
var DefaultFormatter = class extends Formatter {
  format(source) {
    return Promise.resolve(source);
  }
};

// ../lib/src/formatters/json.ts
var JSONFormatter = class extends Formatter {
  format(source) {
    return Promise.resolve(JSON.stringify(JSON.parse(source), null, 4));
  }
};

// ../lib/src/generators/generator.ts
var FormatGenerator = class {
  namespace;
  options;
  constructor(namespace, options2) {
    this.namespace = namespace;
    this.options = options2;
  }
};

// ../lib/src/gir.ts
var TypeExpression = class {
  isPointer = false;
  deepUnwrap() {
    return this.unwrap();
  }
  rootPrint(namespace, options2) {
    return this.print(namespace, options2);
  }
};
var TypeIdentifier = class _TypeIdentifier extends TypeExpression {
  name;
  namespace;
  // Global reporter configuration and instance
  static reporterConfig = {
    enabled: false,
    output: "ts-for-gir-report.json"
  };
  static globalReporter = null;
  static configureReporter(enabled, output = "ts-for-gir-report.json") {
    _TypeIdentifier.reporterConfig = { enabled, output };
    if (_TypeIdentifier.globalReporter) {
      _TypeIdentifier.globalReporter = null;
    }
    if (enabled) {
      _TypeIdentifier.globalReporter = new ConsoleReporter(true, "TypeIdentifier", enabled, output);
      const reporterService = ReporterService.getInstance();
      reporterService.registerReporter("TypeIdentifier", _TypeIdentifier.globalReporter);
    }
  }
  static getReporter() {
    if (!_TypeIdentifier.globalReporter) {
      const config = _TypeIdentifier.reporterConfig;
      _TypeIdentifier.globalReporter = new ConsoleReporter(true, "TypeIdentifier", config.enabled, config.output);
      if (config.enabled) {
        const reporterService = ReporterService.getInstance();
        reporterService.registerReporter("TypeIdentifier", _TypeIdentifier.globalReporter);
      }
    }
    return _TypeIdentifier.globalReporter;
  }
  get log() {
    return _TypeIdentifier.getReporter();
  }
  constructor(name, namespace) {
    super();
    this.name = name;
    this.namespace = namespace;
  }
  equals(type) {
    return type instanceof _TypeIdentifier && type.name === this.name && type.namespace === this.namespace;
  }
  is(namespace, name) {
    return this.namespace === namespace && this.name === name;
  }
  unwrap() {
    return this;
  }
  rewrap(type) {
    return type;
  }
  /**
   * TODO: gi.ts didn't deal with sanitizing types but probably should have to avoid
   * invalid names such as "3gppProfile"
   */
  sanitize() {
    return new _TypeIdentifier(sanitizeIdentifierName(this.namespace, this.name), sanitizeNamespace(this.namespace));
  }
  _resolve(namespace, options2) {
    const name = sanitizeIdentifierName(null, this.name);
    const unresolvedNamespaceName = this.namespace;
    const ns = namespace.assertInstalledImport(unresolvedNamespaceName);
    if (ns.hasSymbol(name)) {
      const c = ns.getClass(name);
      if (c) return c.getType();
      return new _TypeIdentifier(name, ns.namespace);
    }
    let [cb, corrected_name] = ns.findClassCallback(name);
    let resolved_name = null;
    if (!cb) {
      resolved_name = ns.resolveSymbolFromTypeName(name);
    }
    let c_resolved_name = null;
    if (!c_resolved_name) {
      c_resolved_name = ns.resolveSymbolFromTypeName(`${unresolvedNamespaceName}${name}`);
    }
    if (!c_resolved_name) {
      c_resolved_name = ns.resolveSymbolFromTypeName(`${ns.namespace}${name}`);
    }
    if (!cb && !resolved_name && !c_resolved_name) {
      if (namespace.namespace === ns.namespace) {
        this.log.reportTypeResolutionWarning(
          this.name,
          this.namespace,
          `Attempting to fall back on c:type inference for ${ns.namespace}.${name}`,
          `Fallback to c:type inference attempted`
        );
      }
      [cb, corrected_name] = ns.findClassCallback(`${ns.namespace}${name}`);
      if (cb) {
        this.log.reportTypeResolutionWarning(
          this.name,
          this.namespace,
          `Falling back on c:type inference for ${ns.namespace}.${name} and found ${ns.namespace}.${corrected_name}`,
          `Successfully resolved using c:type fallback`
        );
      }
    }
    if (cb) {
      if (options2.verbose) {
        this.log.debug(`Callback found: ${cb}.${corrected_name}`);
      }
      return new ModuleTypeIdentifier(corrected_name, cb, ns.namespace);
    } else if (resolved_name) {
      return new _TypeIdentifier(resolved_name, ns.namespace);
    } else if (c_resolved_name) {
      this.log.reportTypeResolutionWarning(
        this.name,
        this.namespace,
        `Fall back on c:type inference for ${ns.namespace}.${name} and found ${ns.namespace}.${corrected_name}`,
        `Using c:type as fallback for type resolution`
      );
      return new _TypeIdentifier(c_resolved_name, ns.namespace);
    } else if (namespace.namespace === ns.namespace) {
      this.log.reportTypeResolutionError(
        this.name,
        ns.namespace,
        `Unable to resolve type ${this.name} in same namespace ${ns.namespace}!`,
        `Type resolution failed within the same namespace`
      );
      return null;
    }
    this.log.reportTypeResolutionError(
      this.name,
      this.namespace,
      `Type ${this.name} could not be resolved in ${namespace.namespace} ${namespace.version}`,
      `Failed to resolve type during namespace processing`
    );
    return null;
  }
  resolveIdentifier(namespace, options2) {
    return this._resolve(namespace, options2);
  }
  resolve(namespace, options2) {
    const resolved = this._resolve(namespace, options2);
    return resolved ?? NeverType;
  }
  static new({ name, namespace }) {
    return new _TypeIdentifier(name, namespace);
  }
  print(namespace, _options) {
    if (namespace.hasSymbol(this.namespace) && this.namespace !== namespace.namespace) {
      return `${this.namespace}__.${this.name}`;
    }
    if (namespace.namespace === this.namespace) {
      return `${this.name}`;
    } else {
      return `${this.namespace}.${this.name}`;
    }
  }
};
var ModuleTypeIdentifier = class _ModuleTypeIdentifier extends TypeIdentifier {
  moduleName;
  constructor(name, moduleName, namespace) {
    super(name, namespace);
    this.moduleName = moduleName;
    this.namespace = namespace;
  }
  equals(type) {
    return super.equals(type) && type instanceof _ModuleTypeIdentifier && this.moduleName === type.moduleName;
  }
  is(namespace, moduleName, name) {
    return this.namespace === namespace && this.moduleName === moduleName && this.name === name && name !== void 0;
  }
  unwrap() {
    return this;
  }
  rewrap(type) {
    return type;
  }
  sanitize() {
    return new _ModuleTypeIdentifier(
      sanitizeIdentifierName(this.namespace, this.name),
      sanitizeIdentifierName(this.namespace, this.moduleName),
      sanitizeNamespace(this.namespace)
    );
  }
  _resolve(_namespace, _options) {
    return this;
  }
  print(namespace, _options) {
    if (namespace.namespace === this.namespace) {
      return `${this.moduleName}.${this.name}`;
    } else {
      return `${this.namespace}.${this.moduleName}.${this.name}`;
    }
  }
};
var ClassStructTypeIdentifier = class _ClassStructTypeIdentifier extends TypeIdentifier {
  equals(type) {
    return type instanceof _ClassStructTypeIdentifier && super.equals(type);
  }
  print(namespace, _options) {
    if (namespace.namespace === this.namespace) {
      return `typeof ${isInvalid(this.name) ? `__${this.name}` : this.name}`;
    } else {
      return `typeof ${this.namespace}.${isInvalid(this.name) ? `__${this.name}` : this.name}`;
    }
  }
};
var GenerifiedTypeIdentifier = class _GenerifiedTypeIdentifier extends TypeIdentifier {
  generics;
  constructor(name, namespace, generics = []) {
    super(name, namespace);
    this.generics = generics;
  }
  print(namespace, options2) {
    const Generics = this.generics.map((generic) => generic.print(namespace, options2)).join(", ");
    if (namespace.namespace === this.namespace) {
      return `${this.name}${this.generics.length > 0 ? `<${Generics}>` : ""}`;
    } else {
      return `${this.namespace}.${this.name}${this.generics.length > 0 ? `<${Generics}>` : ""}`;
    }
  }
  _resolve(namespace, options2) {
    const iden = super._resolve(namespace, options2);
    if (iden) {
      return new _GenerifiedTypeIdentifier(iden.name, iden.namespace, [...this.generics]);
    }
    return iden;
  }
};
var NativeType = class _NativeType extends TypeExpression {
  expression;
  constructor(expression) {
    super();
    this.expression = typeof expression === "string" ? () => expression : expression;
  }
  rewrap(type) {
    return type;
  }
  resolve() {
    return this;
  }
  print(_namespace, options2) {
    return this.expression(options2);
  }
  equals(type, options2) {
    return type instanceof _NativeType && this.expression(options2) === type.expression(options2);
  }
  unwrap() {
    return this;
  }
  static withGenerator(generator) {
    return new _NativeType(generator);
  }
  static of(nativeType) {
    return new _NativeType(nativeType);
  }
};
var OrType = class _OrType extends TypeExpression {
  types;
  constructor(type, ...types) {
    super();
    this.types = [type, ...types];
  }
  rewrap(type) {
    return type;
  }
  unwrap() {
    return this;
  }
  resolve(namespace, options2) {
    const [type, ...types] = this.types;
    return new _OrType(type.resolve(namespace, options2), ...types.map((t) => t.resolve(namespace, options2)));
  }
  print(namespace, options2) {
    return `(${this.types.map((t) => t.print(namespace, options2)).join(" | ")})`;
  }
  rootPrint(namespace, options2) {
    return `${this.types.map((t) => t.print(namespace, options2)).join(" | ")}`;
  }
  equals(type) {
    if (type instanceof _OrType) {
      return this.types.every((t) => type.types.some((type2) => type2.equals(t)));
    } else {
      return false;
    }
  }
};
var TupleType = class _TupleType extends OrType {
  print(namespace, options2) {
    return `[${this.types.map((t) => t.print(namespace, options2)).join(", ")}]`;
  }
  rootPrint(namespace, options2) {
    return this.print(namespace, options2);
  }
  resolve(namespace, options2) {
    const [type, ...types] = this.types;
    return new _TupleType(type.resolve(namespace, options2), ...types.map((t) => t.resolve(namespace, options2)));
  }
  equals(type) {
    if (type instanceof _TupleType) {
      return this.types.length === type.types.length && this.types.every((t, i) => type.types[i].equals(t));
    } else {
      return false;
    }
  }
};
var BinaryType = class _BinaryType extends OrType {
  unwrap() {
    return this;
  }
  resolve(namespace, options2) {
    return new _BinaryType(this.a.resolve(namespace, options2), this.b.resolve(namespace, options2));
  }
  is() {
    return false;
  }
  get a() {
    return this.types[0];
  }
  get b() {
    return this.types[1];
  }
};
var FunctionType = class _FunctionType extends TypeExpression {
  parameterTypes;
  returnType;
  constructor(parameters, returnType) {
    super();
    this.parameterTypes = parameters;
    this.returnType = returnType;
  }
  equals(type) {
    if (type instanceof _FunctionType) {
      return Object.values(this.parameterTypes).every(
        (t) => Object.values(type.parameterTypes).some((tp) => t.equals(tp))
      ) && Object.values(type.parameterTypes).every(
        (t) => Object.values(this.parameterTypes).some((tp) => t.equals(tp))
      ) && this.returnType.equals(type.returnType);
    }
    return false;
  }
  rewrap(type) {
    return type;
  }
  unwrap() {
    return this;
  }
  resolve(namespace, options2) {
    return new _FunctionType(
      Object.fromEntries(
        Object.entries(this.parameterTypes).map(([k, p]) => {
          return [k, p.resolve(namespace, options2)];
        })
      ),
      this.returnType.resolve(namespace, options2)
    );
  }
  rootPrint(namespace, options2) {
    const Parameters = Object.entries(this.parameterTypes).map(([k, v]) => {
      return `${k}: ${v.rootPrint(namespace, options2)}`;
    }).join(", ");
    return `(${Parameters}) => ${this.returnType.print(namespace, options2)}`;
  }
  print(namespace, options2) {
    return `(${this.rootPrint(namespace, options2)})`;
  }
};
var Generic = class {
  _deriveFrom;
  _genericType;
  _defaultType;
  _constraint;
  _propagate;
  constructor(genericType, defaultType, deriveFrom, constraint, propagate = true) {
    this._deriveFrom = deriveFrom ?? null;
    this._genericType = genericType;
    this._defaultType = defaultType ?? null;
    this._constraint = constraint ?? null;
    this._propagate = propagate;
  }
  unwrap() {
    return this._genericType;
  }
  get propagate() {
    return this._propagate;
  }
  get type() {
    return this._genericType;
  }
  get defaultType() {
    return this._defaultType;
  }
  get constraint() {
    return this._constraint;
  }
  get parent() {
    return this._deriveFrom;
  }
};
var GenerifiedType = class _GenerifiedType extends TypeExpression {
  type;
  generic;
  constructor(type, generic) {
    super();
    this.type = type;
    this.generic = generic;
  }
  resolve(namespace, options2) {
    return new _GenerifiedType(this.type.resolve(namespace, options2), this.generic);
  }
  unwrap() {
    return this.type;
  }
  rootPrint(namespace, options2) {
    return this.type.rootPrint(namespace, options2);
  }
  print(namespace, options2) {
    return `${this.type.print(namespace, options2)}<${this.generic.print()}>`;
  }
  equals(type) {
    if (type instanceof _GenerifiedType) {
      return this.type.equals(type.type) && this.generic.equals(type.generic);
    }
    return this.type.equals(type);
  }
  rewrap(type) {
    return new _GenerifiedType(this.type.rewrap(type), this.generic);
  }
};
var GenericType = class _GenericType extends TypeExpression {
  identifier;
  replacedType;
  constructor(identifier, replacedType) {
    super();
    this.identifier = identifier;
    this.replacedType = replacedType;
  }
  equals(type) {
    if (type instanceof _GenericType) {
      const genericType = type;
      return this.identifier === genericType.identifier;
    }
    return false;
  }
  unwrap() {
    return this;
  }
  rewrap(type) {
    return type;
  }
  resolve() {
    return this;
  }
  print() {
    return this.identifier;
  }
};
var NullableType = class _NullableType extends BinaryType {
  constructor(type) {
    super(type, NullType);
  }
  unwrap() {
    return this.a;
  }
  rewrap(type) {
    return new _NullableType(this.a.rewrap(type));
  }
  get type() {
    return this.a;
  }
};
var PromiseType = class _PromiseType extends TypeExpression {
  type;
  constructor(type) {
    super();
    this.type = type;
  }
  equals(type) {
    return type instanceof _PromiseType && type.type.equals(this.type);
  }
  unwrap() {
    return this;
  }
  rewrap(type) {
    return new _PromiseType(this.type.rewrap(type));
  }
  resolve(namespace, options2) {
    return new _PromiseType(this.type.resolve(namespace, options2));
  }
  print(namespace, options2) {
    if (this.type.equals(VoidType)) {
      return "globalThis.Promise<void>";
    }
    return `globalThis.Promise<${this.type.print(namespace, options2)}>`;
  }
  rootPrint(namespace, options2) {
    return this.print(namespace, options2);
  }
};
var TypeConflict = class _TypeConflict extends TypeExpression {
  conflictType;
  type;
  constructor(type, conflictType) {
    super();
    this.type = type;
    this.conflictType = conflictType;
  }
  rewrap(type) {
    return new _TypeConflict(this.type.rewrap(type), this.conflictType);
  }
  unwrap() {
    return this.type;
  }
  // TODO: This constant "true" is a remnant of the Anyified type.
  equals() {
    return true;
  }
  resolve(namespace, options2) {
    const resolvedType = this.type.resolve(namespace, options2);
    const typeString = resolvedType.print(namespace, options2);
    throw new Error(`Type conflict was not resolved for ${typeString} in ${namespace.namespace}`);
  }
  print(namespace, options2) {
    const resolvedType = this.type.resolve(namespace, options2);
    const typeString = resolvedType.print(namespace, options2);
    throw new Error(`Type conflict was not resolved for ${typeString} in ${namespace.namespace}`);
  }
};
var ClosureType = class _ClosureType extends TypeExpression {
  type;
  user_data = null;
  constructor(type) {
    super();
    this.type = type;
  }
  equals(type) {
    if (type instanceof _ClosureType) {
      const closureType = type;
      return this.type.equals(closureType.type);
    }
    return false;
  }
  deepUnwrap() {
    return this.type;
  }
  rewrap(type) {
    const closure = new _ClosureType(this.type.rewrap(type));
    closure.user_data = this.user_data;
    return closure;
  }
  unwrap() {
    return this;
  }
  resolve(namespace, options2) {
    const { user_data, type } = this;
    return _ClosureType.new({
      user_data,
      type: type.resolve(namespace, options2)
    });
  }
  print(namespace, options2) {
    return this.type.print(namespace, options2);
  }
  static new({ type, user_data = null }) {
    const vt = new _ClosureType(type);
    vt.user_data = user_data;
    return vt;
  }
};
var ArrayType = class _ArrayType extends TypeExpression {
  type;
  arrayDepth = 1;
  length = null;
  constructor(type) {
    super();
    this.type = type;
  }
  deepUnwrap() {
    return this.type;
  }
  unwrap() {
    return this;
  }
  rewrap(type) {
    const array = new _ArrayType(this.type.rewrap(type));
    array.arrayDepth = this.arrayDepth;
    array.length = this.length;
    return array;
  }
  equals(type) {
    if (type instanceof _ArrayType) {
      const arrayType = type;
      return arrayType.type.equals(this.type) && type.arrayDepth === this.arrayDepth;
    }
    return false;
  }
  resolve(namespace, options2) {
    const { type, arrayDepth, length } = this;
    return _ArrayType.new({
      type: type.resolve(namespace, options2),
      arrayDepth,
      length
    });
  }
  print(namespace, options2) {
    const depth = this.arrayDepth;
    let typeSuffix = "";
    if (depth === 0) {
      typeSuffix = "";
    } else if (depth === 1) {
      typeSuffix = "[]";
    } else {
      typeSuffix = "".padStart(2 * depth, "[]");
    }
    return `${this.type.print(namespace, options2)}${typeSuffix}`;
  }
  static new({
    type,
    arrayDepth = 1,
    length = null
  }) {
    const vt = new _ArrayType(type);
    vt.length = length;
    vt.arrayDepth = arrayDepth;
    return vt;
  }
};
var ThisType = new NativeType("this");
var ObjectType = new NativeType("object");
var AnyType = new NativeType("any");
var NeverType = new NativeType("never");
var Uint8ArrayType = new NativeType("Uint8Array");
var BooleanType = new NativeType("boolean");
var StringType = new NativeType("string");
var NumberType = new NativeType("number");
var NullType = new NativeType("null");
var VoidType = new NativeType("void");
var UnknownType = new NativeType("unknown");
var AnyFunctionType = new NativeType("(...args: any[]) => any");

// ../lib/src/utils/types.ts
function getAliasType(namespace, _ns, parameter) {
  let name = parameter.type?.[0].$.name || "unknown";
  const nameParts = name.split(" ");
  if (nameParts.length === 1) {
    name = nameParts[0];
  } else {
    name = nameParts[1];
  }
  return parseTypeExpression(namespace, name);
}
function parseTypeString(type) {
  if (type.includes(".")) {
    const parts = type.split(".");
    if (parts.length > 2) {
      throw new Error(`Invalid type string ${type} passed.`);
    }
    const [namespace, name] = parts;
    return { name, namespace };
  } else {
    return { name: type, namespace: null };
  }
}
function parseTypeIdentifier(namespace, type) {
  const baseType = parseTypeString(type);
  if (baseType.namespace) {
    return new TypeIdentifier(baseType.name, baseType.namespace);
  } else {
    return new TypeIdentifier(baseType.name, namespace);
  }
}
function parseTypeExpression(namespace, type) {
  const baseType = parseTypeString(type);
  if (baseType.namespace) {
    if (baseType.namespace === namespace) {
      return new TypeIdentifier(baseType.name, namespace);
    }
    return new TypeIdentifier(baseType.name, baseType.namespace).sanitize();
  } else {
    const primitiveType = resolvePrimitiveType(baseType.name);
    if (primitiveType !== null) {
      return primitiveType;
    } else {
      return new TypeIdentifier(baseType.name, namespace);
    }
  }
}
function resolvePrimitiveArrayType(name, arrayDepth) {
  if (arrayDepth > 0) {
    switch (name) {
      case "gint8":
      case "guint8":
        return [Uint8ArrayType, arrayDepth - 1];
      case "gunichar":
        return [StringType, arrayDepth - 1];
    }
  }
  const resolvedName = resolvePrimitiveType(name);
  if (resolvedName) {
    return [resolvedName, arrayDepth];
  } else {
    return null;
  }
}
function isPrimitiveType(name) {
  return resolvePrimitiveType(name) !== null;
}
function resolvePrimitiveType(name) {
  switch (name) {
    case "":
      console.error(`Resolving '' to any on ${name}`);
      return AnyType;
    case "filename":
      return StringType;
    // Pass this through
    case "GType":
      return new TypeIdentifier("GType", "GObject");
    case "utf8":
      return StringType;
    case "void":
    // Support TS "void"
    case "none":
      return VoidType;
    // TODO Some libraries are bad and don't use g-prefixed numerical types
    case "uint":
    case "int":
    case "uint8":
    case "int8":
    case "uint16":
    case "int16":
    case "uint32":
    case "int32":
    case "int64":
    case "uint64":
    case "double":
    case "long":
    case "float":
    // Most libraries will use these though:
    case "gshort":
    case "guint32":
    case "guint16":
    case "gint16":
    case "gint8":
    case "gint32":
    case "gushort":
    case "gfloat":
    case "gchar":
    case "guint":
    case "glong":
    case "gulong":
    case "gint":
    case "guint8":
    case "guint64":
    case "gint64":
    case "gdouble":
    case "gssize":
    case "gsize":
    case "time_t":
    // C standard library time type (seconds since Unix epoch)
    case "ulong":
      return NumberType;
    case "gboolean":
      return BooleanType;
    case "gpointer":
      return AnyType;
    case "object":
      return ObjectType;
    case "va_list":
      return AnyType;
    case "guintptr":
      return NeverType;
    case "never":
      return NeverType;
    case "unknown":
      return UnknownType;
    case "any":
      return AnyType;
    case "this":
      return ThisType;
    case "number":
      return NumberType;
    case "gunichar":
    case "string":
      return StringType;
    case "boolean":
      return BooleanType;
  }
  return null;
}
function resolveDirectedType(type, direction) {
  if (type instanceof ArrayType) {
    if ((direction === "in" /* In */ || direction === "inout" /* Inout */) && type.type.equals(Uint8ArrayType) && type.arrayDepth === 0) {
      return new BinaryType(type, StringType);
    } else {
      return type.rewrap(resolveDirectedType(type.type, direction) ?? type.type);
    }
  } else if (type instanceof TypeIdentifier) {
    if ((direction === "in" /* In */ || direction === "inout" /* Inout */) && type.is("GLib", "Bytes")) {
      return new BinaryType(type, Uint8ArrayType);
    } else if (type.is("GObject", "Value")) {
      if (direction === "in" /* In */ || direction === "inout" /* Inout */) {
        return new BinaryType(type, AnyType);
      } else {
        return UnknownType;
      }
    } else if (type.is("GLib", "HashTable")) {
      if (direction === "in" /* In */) {
        return new BinaryType(new NativeType("{ [key: string]: any }"), type);
      } else {
        return type;
      }
    }
  }
  return null;
}

// ../lib/src/utils/gir-parsing.ts
function parseDoc(element) {
  const el = element.doc?.[0]?._;
  return el ? `${el}` : null;
}
function parseDeprecatedDoc(element) {
  return element["doc-deprecated"]?.[0]?._ ?? null;
}
function parseMetadata(element) {
  const version = introducedVersion(element);
  const deprecatedIn = deprecatedVersion(element);
  const deprecated = isDeprecated(element);
  const doc2 = parseDeprecatedDoc(element);
  if (!version && !deprecated && !deprecatedIn && !doc2) {
    return void 0;
  }
  return {
    ...deprecated ? { deprecated } : {},
    ...doc2 ? { deprecatedDoc: doc2 } : {},
    ...deprecatedIn ? { deprecatedVersion: deprecatedIn } : {},
    ...version ? { introducedVersion: version } : {}
  };
}
function isPointerType(types) {
  const type = types?.[0];
  if (!type) return false;
  const ctype = type.$["c:type"];
  if (!ctype) return false;
  const typeName = type.$.name;
  if (!typeName) return false;
  if (isPrimitiveType(typeName)) return false;
  return ctype.endsWith("*");
}
function getType(ns, param) {
  const modName = ns.namespace;
  if (!param) return VoidType;
  let name = "";
  let arrayDepth = null;
  let length = null;
  let isPointer = false;
  const parameter = param;
  if (parameter.array?.[0]) {
    arrayDepth = 1;
    const [array] = parameter.array;
    if (array.$ && array.$.length != null) {
      length = array.$.length;
    }
    if (array.type?.[0].$?.name) {
      name = array.type[0].$.name;
    } else if (array.array) {
      let arr = array;
      let depth = 1;
      while (Array.isArray(arr.array)) {
        arr = arr.array[0];
        depth++;
      }
      const possibleName = arr.type?.[0].$.name;
      if (possibleName) {
        name = possibleName;
      } else {
        name = "unknown";
        console.log(
          `Failed to find array type in ${ns.packageName}: `,
          JSON.stringify(parameter.$, null, 4),
          "\nMarking as unknown!"
        );
      }
      arrayDepth = depth;
      isPointer = isPointerType(array.type);
    } else {
      name = "unknown";
    }
  } else if (parameter.type?.[0]?.$) {
    const possibleName = parameter.type[0].$.name;
    if (possibleName) {
      name = possibleName;
    } else {
      name = "unknown";
      console.log(
        `Failed to find type in ${modName}: `,
        JSON.stringify(parameter.type[0].$, null, 4),
        "\nMarking as unknown!"
      );
    }
    isPointer = isPointerType(parameter.type);
  } else if (parameter.varargs || parameter.$ && parameter.$.name === "...") {
    arrayDepth = 1;
    name = "any";
  } else {
    name = "unknown";
    console.log(`Unknown varargs type in ${modName}: `, JSON.stringify(parameter.$, null, 4), "\nMarking as unknown!");
  }
  let closure = null;
  if (parameter.$?.closure) {
    closure = parameter.$.closure;
  }
  const nullable = parameter.$ && parameter.$.nullable === "1";
  const allowNone = parameter.$ && parameter.$["allow-none"] === "1";
  const x = name.split(" ");
  if (x.length === 1) {
    name = x[0];
  } else {
    name = x[1];
  }
  let variableType = parseTypeExpression(ns.namespace, name);
  if (variableType instanceof TypeIdentifier) {
    if (variableType.is("GLib", "List") || variableType.is("GLib", "SList")) {
      const listType = parameter?.type?.[0].type?.[0]?.$?.name;
      if (listType) {
        name = listType;
        variableType = parseTypeExpression(ns.namespace, name);
        arrayDepth = 1;
      }
    } else if (variableType.is("GLib", "HashTable")) {
      const keyType = parameter?.type?.[0]?.type?.[0]?.$.name;
      const valueType = parameter?.type?.[0]?.type?.[1]?.$.name;
      if (keyType && valueType) {
        const key = parseTypeExpression(ns.namespace, keyType);
        const value = parseTypeExpression(ns.namespace, valueType);
        variableType = new GenerifiedTypeIdentifier("HashTable", "GLib", [key, value]);
      }
    }
  }
  if (arrayDepth != null) {
    const primitiveArrayType = resolvePrimitiveArrayType(name, arrayDepth);
    if (primitiveArrayType) {
      const [primitiveName, primitiveArrayDepth] = primitiveArrayType;
      variableType = ArrayType.new({
        type: primitiveName,
        arrayDepth: primitiveArrayDepth,
        length
      });
    } else {
      variableType = ArrayType.new({ type: variableType, arrayDepth, length });
    }
  } else if (closure != null) {
    variableType = ClosureType.new({ type: variableType, user_data: closure });
  }
  if (parameter.$ && (parameter.$.direction === "inout" /* Inout */ || parameter.$.direction === "out" /* Out */) && (nullable || allowNone) && !(variableType instanceof NativeType)) {
    return new NullableType(variableType);
  }
  if ((!parameter.$?.direction || parameter.$.direction === "in" /* In */) && nullable) {
    return new NullableType(variableType);
  }
  variableType.isPointer = isPointer;
  return variableType;
}
function hasShadow(obj) {
  return obj.$.shadows != null;
}

// ../lib/src/gir/introspected-base.ts
var IntrospectedBase = class {
  name;
  doc;
  metadata;
  deprecated;
  resolve_names = [];
  _emit = true;
  _commentWarning;
  _isPrivate;
  _isIntrospectable;
  _parent;
  constructor(name, parent, options2 = {}) {
    this.name = name;
    this._parent = parent;
    this._isPrivate = options2.isPrivate ?? false;
    this._isIntrospectable = options2.isIntrospectable ?? true;
    this.doc = options2.doc ?? null;
  }
  get parent() {
    return this._parent;
  }
  /**
   * Set a warning to be emitted with this node. Often used to note type
   * conflicts or potential differences from GJS code.
   *
   * @param warning
   */
  setWarning(warning) {
    this._commentWarning = warning;
  }
  getWarning() {
    return this._commentWarning;
  }
  get isIntrospectable() {
    return this._isIntrospectable;
  }
  get isPrivate() {
    return this._isPrivate;
  }
  setPrivate(priv) {
    this._isPrivate = priv;
  }
  noEmit() {
    this._emit = false;
  }
  get emit() {
    return this._emit;
  }
  _copyBaseProperties(from) {
    this.doc = from.doc;
    this.metadata = from.metadata;
    this.deprecated = from.deprecated;
    this.resolve_names = from.resolve_names;
    this._emit = from._emit;
    this._isPrivate = from._isPrivate;
    this._isIntrospectable = from.isIntrospectable;
    return this;
  }
  static fromXML(_element, _parent, _options) {
    throw new Error("GirBase cannot be instantiated");
  }
};

// ../lib/src/gir/introspected-namespace-member.ts
var IntrospectedNamespaceMember = class extends IntrospectedBase {
  constructor(name, namespace, options2 = {}) {
    super(name, namespace, options2);
  }
  get namespace() {
    return this.parent;
  }
  static fromXML(_element, _parent, _options) {
    throw new Error("GirBase cannot be instantiated");
  }
};

// ../lib/src/gir/alias.ts
var IntrospectedAlias = class _IntrospectedAlias extends IntrospectedNamespaceMember {
  type;
  generics;
  constructor({
    namespace,
    name,
    type,
    generics = [],
    ...args
  }) {
    super(name, namespace, { ...args });
    this.type = type;
    this.generics = generics;
  }
  accept(visitor) {
    const node = this.copy({
      type: visitor.visitType?.(this.type)
    });
    return visitor.visitAlias?.(node) ?? node;
  }
  copy(options2) {
    const { name, namespace, type } = this;
    return new _IntrospectedAlias({ name, namespace, type: options2?.type ?? type })._copyBaseProperties(this);
  }
  asString(generator) {
    return generator.generateAlias(this);
  }
  static fromXML(element, ns, options2) {
    if (!element.$.name) {
      console.error(`Alias in ${ns.namespace} lacks name.`);
      return null;
    }
    const alias = new _IntrospectedAlias({
      namespace: ns,
      name: sanitizeIdentifierName(ns.namespace, element.$.name),
      type: getAliasType(ns.namespace, ns, element),
      isIntrospectable: isIntrospectable(element)
    });
    if (options2.loadDocs) {
      alias.doc = parseDoc(element);
      alias.metadata = parseMetadata(element);
    }
    return alias;
  }
};

// ../lib/src/util.ts
var TwoKeyMap = class {
  baseMap = /* @__PURE__ */ new Map();
  forEach(op) {
    this.baseMap.forEach((map2) => {
      map2.forEach((v) => {
        op(v);
      });
    });
  }
  has(key1, key2) {
    const obj = this.baseMap.get(key1);
    if (!obj) {
      return false;
    }
    return obj.has(key2);
  }
  getIfOnly(key1) {
    const obj = this.baseMap.get(key1);
    if (!obj) {
      return void 0;
    }
    if (obj.size === 1) {
      const [k2] = obj.keys();
      const v = obj.get(k2);
      if (!v) {
        return void 0;
      }
      return [k2, v];
    }
    return void 0;
  }
  get(key1, key2) {
    const obj = this.baseMap.get(key1);
    if (!obj) {
      return void 0;
    }
    return obj.get(key2);
  }
  set(key1, key2, value) {
    let obj = this.baseMap.get(key1);
    if (!obj) {
      obj = /* @__PURE__ */ new Map();
      this.baseMap.set(key1, obj);
    }
    obj.set(key2, value);
  }
};
function findMap(arr, predicate) {
  for (const a of arr) {
    const val = predicate(a);
    if (val !== void 0) return val;
  }
  return void 0;
}

// ../lib/src/utils/type-resolution.ts
function resolveTypeIdentifier(namespace, type) {
  const ns = type.namespace;
  const name = type.name;
  const resolved_ns = namespace.assertInstalledImport(ns);
  const pclass = resolved_ns.getClass(name);
  if (pclass) {
    return pclass;
  } else {
    return null;
  }
}
function isTypeConflict(a, b) {
  return !a.equals(b) || !b.equals(a);
}
function isSubtypeOf(namespace, thisType, parentThisType, potentialSubtype, parentType) {
  if (!isTypeConflict(potentialSubtype, parentType)) {
    return true;
  }
  const unwrappedSubtype = potentialSubtype.unwrap();
  let unwrappedParent = parentType.unwrap();
  if (potentialSubtype.equals(ThisType) && unwrappedParent.equals(thisType) || parentType.equals(ThisType) && unwrappedSubtype.equals(parentThisType)) {
    return true;
  }
  if (unwrappedParent instanceof GenericType && unwrappedParent.identifier !== "T") {
    if (!unwrappedParent.replacedType) {
      return true;
    }
    unwrappedParent = unwrappedParent.replacedType;
  }
  if (!(unwrappedSubtype instanceof TypeIdentifier) || !(unwrappedParent instanceof TypeIdentifier)) {
    return false;
  }
  const resolutions = namespace.parent.subtypes.get(unwrappedSubtype.name, unwrappedSubtype.namespace) ?? new TwoKeyMap();
  const resolution = resolutions.get(unwrappedParent.name, unwrappedParent.namespace);
  if (typeof resolution === "boolean") {
    return resolution;
  }
  const resolved = resolveTypeIdentifier(namespace, unwrappedSubtype);
  if (!resolved) {
    return false;
  }
  const parentResolution = resolved.resolveParents();
  const isStructurallySubtype = potentialSubtype.rewrap(AnyType).equals(parentType.rewrap(AnyType));
  const isSubtype = isStructurallySubtype && parentResolution.node.someParent((t) => t.getType().equals(unwrappedParent));
  resolutions.set(unwrappedParent.name, unwrappedParent.namespace, isSubtype);
  namespace.parent.subtypes.set(unwrappedSubtype.name, unwrappedSubtype.namespace, resolutions);
  return isSubtype;
}

// ../lib/src/gir/introspected-class-member.ts
var IntrospectedClassMember = class extends IntrospectedBase {
  get namespace() {
    if (!this.parent) {
      throw new Error(`Failed to get namespace for ${this.name}`);
    }
    return this.parent.namespace;
  }
};

// ../lib/src/gir/constructor.ts
var IntrospectedConstructor = class _IntrospectedConstructor extends IntrospectedClassMember {
  parameters = [];
  return_type = UnknownType;
  generics = [];
  constructor({
    name,
    parameters = [],
    return_type,
    parent,
    ...args
  }) {
    super(name, parent, { ...args });
    this.return_type = return_type;
    this.parameters = parameters.map((p) => p.copy({ parent: this }));
  }
  copy({
    parent,
    parameters,
    return_type
  } = {}) {
    const constr = new _IntrospectedConstructor({
      name: this.name,
      parent: parent ?? this.parent ?? null,
      return_type: return_type ?? this.return_type,
      parameters: parameters ?? this.parameters
    })._copyBaseProperties(this);
    constr.generics = [...this.generics];
    return constr;
  }
  static fromXML(m, parent, options2) {
    const fn = IntrospectedClassFunction.fromXML(m, parent, options2);
    return new _IntrospectedConstructor({
      name: fn.name,
      parent,
      parameters: fn.parameters,
      return_type: parent.getType(),
      isIntrospectable: fn.isIntrospectable
    });
  }
  accept(visitor) {
    const node = this.copy({
      parameters: this.parameters.map((p) => {
        return p.accept(visitor);
      }),
      return_type: visitor.visitType?.(this.return_type)
    });
    return visitor.visitConstructor?.(node) ?? node;
  }
  return() {
    return this.return_type;
  }
  asString(generator) {
    return generator.generateConstructor(this);
  }
};

// ../lib/src/gir/generics.ts
var GenericNames = [
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z"
];
function* getGenericNames(start = "A") {
  let names = GenericNames.map((s) => `${s}`);
  const startIteration = Number.parseInt(start.slice(1) || "0", 10);
  let i = startIteration;
  names = names.map((s) => i === 0 ? s : `${s}${i}`);
  const StartLetter = start[0];
  const position = GenericNames.indexOf(StartLetter);
  while (true) {
    for (const name of names) {
      if (i === startIteration && GenericNames.indexOf(name) >= position) {
        yield name;
      }
    }
    names = names.map((s) => `${s}${i}`);
    i++;
  }
  return "ThisShouldNeverHappen";
}
function createGenericNameGenerator() {
  const genericNames = getGenericNames();
  return () => genericNames.next().value;
}
function createGenericNameGeneratorAt(start) {
  const genericNames = getGenericNames(start);
  return () => genericNames.next().value;
}

// ../lib/src/gir/property.ts
var IntrospectedField = class _IntrospectedField extends IntrospectedClassMember {
  type;
  optional = false;
  computed;
  isStatic;
  writable;
  isNative = false;
  copy(options2) {
    const { type, name, parent, optional, computed, isStatic, writable } = this;
    return new _IntrospectedField({
      name,
      parent,
      type: options2?.type ?? type,
      optional,
      computed,
      isStatic: options2?.isStatic ?? isStatic,
      writable
    })._copyBaseProperties(this);
  }
  constructor({
    name,
    parent,
    type,
    computed = false,
    optional = false,
    isStatic = false,
    writable = true,
    ...args
  }) {
    super(name, parent ?? null, { ...args });
    this.type = type;
    this.computed = computed;
    this.optional = optional;
    this.isStatic = isStatic;
    this.writable = writable;
  }
  asString(generator) {
    return generator.generateField(this);
  }
  accept(visitor) {
    const node = this.copy({
      type: visitor.visitType?.(this.type) ?? this.type
    });
    return visitor.visitField?.(node) ?? node;
  }
  static fromXML(field, parent) {
    const namespace = parent.namespace;
    const name = field.$.name;
    const _name = name.replace(/[-]/g, "_");
    const f = new _IntrospectedField({
      name: _name,
      parent,
      type: getType(namespace, field),
      isPrivate: field.$.private === "1",
      isIntrospectable: isIntrospectable(field)
    });
    return f;
  }
};
var JSField = class extends IntrospectedField {
  isNative = true;
};
var IntrospectedProperty = class _IntrospectedProperty extends IntrospectedBase {
  type;
  writable = false;
  readable = true;
  constructOnly;
  get namespace() {
    return this.parent.namespace;
  }
  copy(options2) {
    const { name, writable, readable, type, constructOnly, parent } = this;
    return new _IntrospectedProperty({
      name: options2?.name ?? name,
      writable,
      readable,
      type: options2?.type ?? type,
      constructOnly,
      parent: options2?.parent ?? parent
    })._copyBaseProperties(this);
  }
  accept(visitor) {
    const node = this.copy({
      parent: this.parent,
      type: visitor.visitType?.(this.type) ?? this.type
    });
    return visitor.visitProperty?.(node) ?? node;
  }
  constructor({
    name,
    type,
    writable,
    readable,
    constructOnly,
    parent,
    ...args
  }) {
    super(name, parent, { ...args });
    this.type = type;
    this.writable = writable;
    this.readable = readable;
    this.constructOnly = constructOnly;
  }
  asString(generator, construct) {
    return generator.generateProperty(this, construct);
  }
  toCamelCase() {
    const [part, ...parts] = this.name.split("_");
    if (parts.length === 0) {
      return this.copy({
        name: part,
        parent: this.parent
      });
    }
    const camelCase2 = `${part}${parts.map((s) => `${s[0].toUpperCase()}${s.slice(1)}`).join("")}`;
    return this.copy({
      name: camelCase2,
      parent: this.parent
    });
  }
  static fromXML(element, parent, options2) {
    const ns = parent.namespace;
    const name = element.$.name;
    const _name = name.replace(/[-]/g, "_");
    const property = new _IntrospectedProperty({
      name: _name,
      writable: element.$?.writable === "1",
      readable: element.$?.readable !== "0",
      constructOnly: element.$?.["construct-only"] === "1",
      type: getType(ns, element),
      parent,
      isIntrospectable: isIntrospectable(element)
    });
    if (options2.loadDocs) {
      property.doc = parseDoc(element);
      property.metadata = parseMetadata(element);
    }
    return property;
  }
};

// ../lib/src/gir/signal.ts
var IntrospectedSignal = class _IntrospectedSignal extends IntrospectedClassMember {
  parameters;
  return_type;
  detailed;
  constructor({
    name,
    parameters = [],
    return_type = UnknownType,
    detailed = false,
    parent,
    ...args
  }) {
    super(name, parent, { ...args });
    this.parameters = parameters.map((p) => p.copy({ parent: this }));
    this.return_type = return_type;
    this.detailed = detailed;
  }
  accept(visitor) {
    const node = this.copy({
      parameters: this.parameters.map((p) => {
        return p.accept(visitor);
      }),
      returnType: visitor.visitType?.(this.return_type)
    });
    return visitor.visitSignal?.(node) ?? node;
  }
  copy({
    parent = this.parent,
    parameters,
    returnType,
    detailed
  } = {}) {
    return new _IntrospectedSignal({
      name: this.name,
      parent,
      parameters: parameters ?? this.parameters,
      return_type: returnType ?? this.return_type,
      detailed: detailed ?? this.detailed
    })._copyBaseProperties(this);
  }
  static fromXML(element, parent, options2) {
    const ns = parent.namespace;
    const signal = new _IntrospectedSignal({
      name: element.$.name,
      parent,
      detailed: element.$.detailed === "1",
      isIntrospectable: isIntrospectable(element)
    });
    if (element.parameters?.[0].parameter) {
      signal.parameters.push(
        ...element.parameters[0].parameter.filter((p) => !!p.$.name).map((p) => IntrospectedFunctionParameter.fromXML(p, signal, options2))
      );
    }
    const length_params = [];
    signal.parameters = signal.parameters.map((p) => {
      const unwrapped_type = p.type.unwrap();
      if (unwrapped_type instanceof ArrayType && unwrapped_type.length != null) {
        length_params.push(unwrapped_type.length);
        return p;
      }
      return p;
    }).filter((_, i) => {
      return !length_params.includes(i);
    }).reverse().reduce(
      ({ allowOptions, params }, p) => {
        const { type, isOptional } = p;
        if (allowOptions) {
          if (type instanceof NullableType) {
            params.push(p.copy({ isOptional: true }));
          } else if (!isOptional) {
            params.push(p);
            return { allowOptions: false, params };
          } else {
            params.push(p);
          }
        } else {
          if (isOptional) {
            params.push(p.copy({ type: new NullableType(type), isOptional: false }));
          } else {
            params.push(p);
          }
        }
        return { allowOptions, params };
      },
      {
        allowOptions: true,
        params: []
      }
    ).params.reverse().filter((p) => p != null);
    signal.return_type = getType(ns, element["return-value"]?.[0]);
    if (options2.loadDocs) {
      signal.doc = parseDoc(element);
      signal.metadata = parseMetadata(element);
    }
    return signal;
  }
  asEmit() {
    const emit = this.copy();
    const parent = this.parent;
    const prefix_signal = emit.parameters.some((p) => {
      return p.name === "signal";
    });
    const parameters = [
      new IntrospectedFunctionParameter({
        name: prefix_signal ? "$signal" : "signal",
        type: NativeType.of(`'${this.name}'`),
        direction: "in" /* In */
      }),
      ...emit.parameters
    ];
    const return_type = VoidType;
    return new IntrospectedClassFunction({
      return_type,
      parameters,
      name: "emit",
      parent
    });
  }
  asConnect(after = false) {
    const connect = this.copy();
    const name = after ? "connect_after" : "connect";
    const parent = this.parent;
    const cb = new IntrospectedClassCallback({
      parent,
      name: "callback",
      output_parameters: [],
      parameters: [
        new IntrospectedFunctionParameter({
          name: "_source",
          type: ThisType,
          direction: "in" /* In */
        }),
        ...connect.parameters.map((p) => p.copy())
      ],
      return_type: connect.return_type
    });
    const parameters = [
      new IntrospectedFunctionParameter({
        name: "signal",
        type: NativeType.of(`'${this.name}'`),
        direction: "in" /* In */
      }),
      new IntrospectedFunctionParameter({
        name: "callback",
        type: cb.asFunctionType(),
        direction: "in" /* In */
      })
    ];
    const return_type = NumberType;
    return new IntrospectedClassFunction({
      return_type,
      parameters,
      name,
      parent: this.parent
    });
  }
  asString(generator, type) {
    return generator.generateSignal(this, type);
  }
};

// ../lib/src/gir/introspected-classes.ts
var log = new ConsoleReporter(true, "gir/introspected-classes", true);
var IntrospectedClassFunction = class _IntrospectedClassFunction extends IntrospectedBase {
  parameters;
  return_type;
  output_parameters;
  _anyify = false;
  _generify = false;
  interfaceParent = null;
  returnTypeDoc;
  generics = [];
  constructor({
    name,
    parameters = [],
    output_parameters = [],
    return_type = UnknownType,
    parent,
    doc: doc2,
    ...args
  }) {
    super(name, parent, { ...args });
    this.parameters = parameters.map((p) => p.copy({ parent: this }));
    this.output_parameters = output_parameters.map((p) => p.copy({ parent: this }));
    this.return_type = return_type;
    this.doc = doc2;
  }
  get namespace() {
    return this.parent.namespace;
  }
  getCallbackParameters() {
    const { name, parent, output_parameters, parameters, return_type } = this;
    return {
      name,
      parent,
      output_parameters,
      parameters,
      return_type
    };
  }
  copy({
    parent = this.parent,
    name,
    interfaceParent,
    parameters,
    outputParameters,
    returnType
  } = {}) {
    const fn = new _IntrospectedClassFunction({
      name: name ?? this.name,
      parent,
      output_parameters: outputParameters ?? this.output_parameters,
      parameters: parameters ?? this.parameters,
      return_type: returnType ?? this.return_type
    });
    fn.generics = [...this.generics];
    fn.returnTypeDoc = this.returnTypeDoc;
    if (interfaceParent) {
      fn.interfaceParent = interfaceParent;
    }
    return fn._copyBaseProperties(this);
  }
  accept(visitor) {
    const node = this.copy({
      parameters: this.parameters.map((p) => {
        return p.accept(visitor);
      }),
      outputParameters: this.output_parameters.map((p) => {
        return p.accept(visitor);
      }),
      returnType: visitor.visitType?.(this.return_type)
    });
    const fn = visitor.visitClassFunction?.(node);
    return fn ?? node;
  }
  static fromXML(element, parent, options2) {
    const fn = IntrospectedFunction.fromXML(element, parent.namespace, options2);
    const { raw_name: name, output_parameters, parameters, return_type, doc: doc2, isIntrospectable: isIntrospectable2 } = fn;
    const classFn = new _IntrospectedClassFunction({
      parent,
      name,
      output_parameters,
      parameters,
      return_type,
      doc: doc2,
      isIntrospectable: isIntrospectable2
    });
    classFn.returnTypeDoc = fn.returnTypeDoc;
    classFn.generics = [...fn.generics];
    return classFn;
  }
  anyify() {
    this._anyify = true;
    return this;
  }
  shouldAnyify() {
    return this._anyify;
  }
  return() {
    return this.return_type;
  }
  asString(generator) {
    return generator.generateClassFunction(this);
  }
};
var IntrospectedVirtualClassFunction = class _IntrospectedVirtualClassFunction extends IntrospectedClassFunction {
  constructor({
    name,
    parameters = [],
    output_parameters = [],
    return_type = UnknownType,
    parent,
    doc: doc2,
    ...args
  }) {
    super({
      parent,
      name: name.startsWith("vfunc_") ? name : `vfunc_${name}`,
      parameters,
      output_parameters,
      return_type,
      doc: doc2,
      ...args
    });
  }
  copy({
    parent = this.parent,
    interfaceParent,
    parameters,
    outputParameters,
    returnType
  }) {
    const fn = new _IntrospectedVirtualClassFunction({
      name: this.name,
      parent,
      output_parameters: outputParameters ?? this.output_parameters,
      parameters: parameters ?? this.parameters,
      return_type: returnType ?? this.return_type
    });
    fn.generics = [...this.generics];
    fn.returnTypeDoc = this.returnTypeDoc;
    if (interfaceParent) {
      fn.interfaceParent = interfaceParent;
    }
    return fn._copyBaseProperties(this);
  }
  accept(visitor) {
    const node = this.copy({
      parameters: this.parameters.map((p) => {
        return p.accept(visitor);
      }),
      outputParameters: this.output_parameters.map((p) => {
        return p.accept(visitor);
      }),
      returnType: visitor.visitType?.(this.return_type)
    });
    return visitor.visitVirtualClassFunction?.(node) ?? node;
  }
  static fromXML(m, parent, options2) {
    const fn = IntrospectedFunction.fromXML(m, parent.namespace, options2);
    const { raw_name: name, output_parameters, parameters, return_type, doc: doc2, isIntrospectable: isIntrospectable2 } = fn;
    return new _IntrospectedVirtualClassFunction({
      parent,
      name,
      output_parameters,
      parameters,
      return_type,
      doc: doc2,
      isIntrospectable: isIntrospectable2
    });
  }
  asString(generator) {
    return generator.generateVirtualClassFunction(this);
  }
};
var IntrospectedStaticClassFunction = class _IntrospectedStaticClassFunction extends IntrospectedClassFunction {
  asString(generator) {
    return generator.generateStaticClassFunction(this);
  }
  copy({
    parent = this.parent,
    interfaceParent,
    parameters,
    outputParameters,
    returnType
  } = {}) {
    const fn = new _IntrospectedStaticClassFunction({
      name: this.name,
      parent,
      output_parameters: outputParameters ?? this.output_parameters,
      parameters: parameters ?? this.parameters,
      return_type: returnType ?? this.return_type
    });
    fn.generics = [...this.generics];
    fn.returnTypeDoc = this.returnTypeDoc;
    if (interfaceParent) {
      fn.interfaceParent = interfaceParent;
    }
    return fn._copyBaseProperties(this);
  }
  accept(visitor) {
    const node = this.copy({
      parent: this.parent,
      parameters: this.parameters.map((p) => {
        return p.accept(visitor);
      }),
      outputParameters: this.output_parameters.map((p) => {
        return p.accept(visitor);
      }),
      returnType: visitor.visitType?.(this.return_type)
    });
    return visitor.visitStaticClassFunction?.(node) ?? node;
  }
  asClassFunction(parent) {
    const { name, output_parameters, parameters, return_type, doc: doc2, isIntrospectable: isIntrospectable2 } = this;
    const fn = new IntrospectedClassFunction({
      parent,
      name,
      output_parameters,
      parameters,
      return_type,
      doc: doc2,
      isIntrospectable: isIntrospectable2
    });
    fn.returnTypeDoc = this.returnTypeDoc;
    fn.generics = [...this.generics];
    return fn;
  }
  static fromXML(m, parent, options2) {
    const fn = IntrospectedFunction.fromXML(m, parent.namespace, options2);
    const { raw_name: name, output_parameters, parameters, return_type, doc: doc2, isIntrospectable: isIntrospectable2 } = fn;
    return new _IntrospectedStaticClassFunction({
      parent,
      name,
      output_parameters,
      parameters,
      return_type,
      doc: doc2,
      isIntrospectable: isIntrospectable2
    });
  }
};
var IntrospectedClassCallback = class _IntrospectedClassCallback extends IntrospectedClassFunction {
  asFunctionType() {
    return new FunctionType(
      Object.fromEntries(this.parameters.map((p) => [p.name, p.type])),
      this.return_type
    );
  }
  copy({
    parameters,
    returnType,
    outputParameters,
    parent
  } = {}) {
    const cb = new _IntrospectedClassCallback({
      name: this.name,
      return_type: returnType ?? this.return_type,
      parameters: parameters ?? this.parameters,
      output_parameters: outputParameters ?? this.output_parameters,
      parent: parent ?? this.parent
    })._copyBaseProperties(this);
    cb.generics = [...this.generics];
    return cb;
  }
  accept(visitor) {
    const node = this.copy({
      parameters: this.parameters.map((p) => {
        return p.accept(visitor);
      }),
      outputParameters: this.output_parameters.map((p) => {
        return p.accept(visitor);
      }),
      returnType: visitor.visitType?.(this.return_type)
    });
    return visitor.visitClassCallback?.(node) ?? node;
  }
  static fromXML(element, parent, options2) {
    const ns = parent.namespace;
    const cb = new _IntrospectedClassCallback(
      IntrospectedClassFunction.fromXML(element, parent, options2).getCallbackParameters()
    );
    const glibTypeName = element.$["glib:type-name"];
    if (typeof glibTypeName === "string" && element.$["glib:type-name"]) {
      cb.resolve_names.push(glibTypeName);
      ns.registerResolveName(glibTypeName, ns.namespace, cb.name);
    }
    if (element.$["c:type"]) {
      cb.resolve_names.push(element.$["c:type"]);
      ns.registerResolveName(element.$["c:type"], ns.namespace, cb.name);
    }
    return cb;
  }
  asString(generator) {
    return generator.generateClassCallback(this);
  }
};
var IntrospectedBaseClass = class extends IntrospectedNamespaceMember {
  /**
   * Used to add a TypeScript index signature to a class
   *
   * NOTE: This should probably be migrated into the TypeScript generator itself.
   */
  __ts__indexSignature;
  superType;
  mainConstructor;
  constructors;
  members;
  props;
  fields;
  callbacks;
  // Generics support
  generics = [];
  constructor(options2) {
    const {
      name,
      namespace,
      superType = null,
      mainConstructor = null,
      constructors = [],
      members = [],
      props = [],
      fields = [],
      callbacks = [],
      ...args
    } = options2;
    super(name, namespace, { ...args });
    this.superType = superType;
    this.mainConstructor = mainConstructor?.copy({ parent: this }) ?? null;
    this.constructors = [...constructors.map((c) => c.copy({ parent: this }))];
    this.members = [...members.map((m) => m.copy({ parent: this }))];
    this.props = [...props.map((p) => p.copy({ parent: this }))];
    this.fields = [...fields.map((f) => f.copy({ parent: this }))];
    this.callbacks = [...callbacks.map((c) => c.copy({ parent: this }))];
  }
  getGenericName = createGenericNameGenerator();
  addGeneric(definition) {
    const param = new Generic(
      new GenericType(this.getGenericName(), definition.constraint),
      definition.default,
      definition.deriveFrom,
      definition.constraint,
      definition.propagate
    );
    this.generics.push(param);
  }
  getType() {
    return new TypeIdentifier(this.name, this.namespace.namespace);
  }
  static fromXML(_element, _ns, _options) {
    throw new Error("fromXML is not implemented on GirBaseClass");
  }
};
var IntrospectedClass = class _IntrospectedClass extends IntrospectedBaseClass {
  signals = [];
  interfaces = [];
  isAbstract = false;
  mainConstructor = null;
  _staticDefinition = null;
  constructor(name, namespace) {
    super({ name, namespace });
  }
  getAllSignals() {
    const allSignals = this.getBaseSignals();
    if (this.hasGObjectSupport()) {
      this.addNotifySignals(allSignals);
      this.addDetailedSignals(allSignals);
    }
    return allSignals;
  }
  getBaseSignals() {
    return this.signals.map((signal) => ({
      name: signal.name,
      signal,
      isNotifySignal: false,
      isDetailSignal: false
    }));
  }
  hasGObjectSupport() {
    const isGObjectObject = this.isGObjectObject();
    const hasNotifySignal = this.hasExplicitNotifySignal();
    const hasGObjectParent = this.hasGObjectParent();
    return isGObjectObject || hasNotifySignal || hasGObjectParent;
  }
  isGObjectObject() {
    return this.name === "Object" && this.namespace.namespace === "GObject";
  }
  hasExplicitNotifySignal() {
    return this.signals.some((signal) => signal.name === "notify");
  }
  hasGObjectParent() {
    return this.someParent(
      (p) => p.namespace.namespace === "GObject" && p.name === "Object"
    );
  }
  addNotifySignals(allSignals) {
    const propertyNames = this.getUniquePropertyNames();
    propertyNames.forEach((propertyName) => {
      allSignals.push({
        name: `notify::${propertyName}`,
        isNotifySignal: true,
        isDetailSignal: false,
        parameterTypes: ["GObject.ParamSpec"],
        returnType: "void"
      });
    });
  }
  addDetailedSignals(allSignals) {
    const propertyNames = this.getUniquePropertyNames();
    this.signals.forEach((signal) => {
      if (signal.detailed) {
        propertyNames.forEach((propertyName) => {
          allSignals.push({
            name: `${signal.name}::${propertyName}`,
            signal,
            isNotifySignal: false,
            isDetailSignal: true,
            parameterTypes: signal.parameters.map((p) => this.getPropertyTypeString(p.type)),
            returnType: this.getPropertyTypeString(signal.return_type)
          });
        });
      }
    });
  }
  getUniquePropertyNames() {
    const allProperties = this.getAllProperties();
    return new Set(
      allProperties.map(
        (prop) => prop.name.replace(/_/g, "-").replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase()
      )
    );
  }
  getPropertyTypeString(type) {
    if (typeof type === "string") return type;
    if (type?.toString) return type.toString();
    return "any";
  }
  getAllProperties() {
    const allProperties = [...this.props];
    let currentClass = this;
    while (currentClass) {
      const parentResolution = currentClass.resolveParents().extends();
      if (parentResolution && parentResolution.node instanceof _IntrospectedClass) {
        const parentClass = parentResolution.node;
        allProperties.push(...parentClass.props);
        currentClass = parentClass;
      } else {
        break;
      }
    }
    const implementedProps = this.implementedProperties();
    allProperties.push(...implementedProps);
    return allProperties;
  }
  accept(visitor) {
    const node = this.copy({
      signals: this.signals.map((s) => s.accept(visitor)),
      constructors: this.constructors.map((c) => c.accept(visitor)),
      members: this.members.map((m) => m.accept(visitor)),
      props: this.props.map((p) => p.accept(visitor)),
      fields: this.fields.map((f) => f.accept(visitor)),
      callbacks: this.callbacks.map((c) => c.accept(visitor))
    });
    return visitor.visitClass?.(node) ?? node;
  }
  hasInstanceSymbol(s) {
    return this.members.some((p) => s.name === p.name && !(p instanceof IntrospectedStaticClassFunction)) || this.props.some((p) => s.name === p.name) || this.fields.some((p) => s.name === p.name);
  }
  someParent(predicate) {
    const resolution = this.resolveParents();
    const parent = resolution.extends();
    if (parent) {
      if (predicate(parent.node)) return true;
      const some = parent.node.someParent(predicate);
      if (some) return some;
    }
    return resolution.implements().map((i) => i.node).some(
      (i) => predicate(i) || i.someParent(
        (p) => (p instanceof _IntrospectedClass || p instanceof IntrospectedInterface) && predicate(p)
      )
    );
  }
  findParent(predicate) {
    return this.findParentMap((parent) => {
      if (predicate(parent)) {
        return parent;
      }
      return void 0;
    });
  }
  findParentMap(predicate) {
    const resolution = this.resolveParents();
    const parent = resolution.extends();
    if (parent) {
      const value = predicate(parent.node);
      if (value) return value;
      const parentMap = parent.node.findParentMap(predicate);
      if (parentMap) return parentMap;
    }
    return findMap(
      resolution.implements().map((i) => i.node),
      (i) => predicate(i) || i.findParentMap(
        (p) => p instanceof _IntrospectedClass || p instanceof IntrospectedInterface ? predicate(p) : void 0
      )
    );
  }
  implementedProperties(potentialConflicts = []) {
    const resolution = this.resolveParents();
    const implementedOnParent = [...resolution.extends() ?? []].flatMap((r) => r.implements());
    const properties = /* @__PURE__ */ new Map();
    const validateProp = (prop) => !this.hasInstanceSymbol(prop) && !properties.has(prop.name) && potentialConflicts.every((p) => prop.name !== p.name);
    for (const implemented of resolution.implements()) {
      if (implemented.node instanceof _IntrospectedClass) continue;
      if (implementedOnParent.find((p) => p.identifier.equals(implemented.identifier))?.node?.generics?.length === 0)
        continue;
      for (const prop of implemented.node.props) {
        if (!validateProp(prop)) continue;
        properties.set(prop.name, prop);
      }
    }
    for (const implemented of resolution.implements()) {
      [...implemented].forEach((e) => {
        if (e.node instanceof _IntrospectedClass) return;
        if (implementedOnParent.find((p) => p.identifier.equals(e.identifier))?.node.generics.length === 0) return;
        for (const prop of e.node.props) {
          if (!validateProp(prop)) continue;
          properties.set(prop.name, prop);
        }
      });
    }
    for (const implemented of resolution.implements()) {
      const extended = implemented.extends();
      if (extended?.node instanceof _IntrospectedClass) {
        for (const prop of extended.node.props) {
          if (!validateProp(prop)) continue;
          properties.set(prop.name, prop);
        }
      }
    }
    return [...properties.values()];
  }
  implementedMethods(potentialConflicts = []) {
    const resolution = this.resolveParents();
    const implementedOnParent = [...resolution.extends() ?? []].flatMap((r) => r.implements());
    const methods = /* @__PURE__ */ new Map();
    const validateMethod = (method) => !(method instanceof IntrospectedStaticClassFunction) && !this.hasInstanceSymbol(method) && !methods.has(method.name) && potentialConflicts.every((m) => method.name !== m.name);
    for (const implemented of resolution.implements()) {
      if (implemented.node instanceof _IntrospectedClass) continue;
      if (implementedOnParent.find((p) => p.identifier.equals(implemented.identifier))?.node?.generics?.length === 0)
        continue;
      for (const member of implemented.node.members) {
        if (!validateMethod(member)) continue;
        methods.set(member.name, member);
      }
    }
    for (const implemented of resolution.implements()) {
      [...implemented].forEach((e) => {
        if (e.node instanceof _IntrospectedClass) return;
        if (implementedOnParent.find((p) => p.identifier.equals(e.identifier))?.node.generics.length === 0) return;
        for (const member of e.node.members) {
          if (!validateMethod(member)) continue;
          methods.set(member.name, member);
        }
      });
    }
    for (const implemented of resolution.implements()) {
      const extended = implemented.extends();
      if (extended?.node instanceof _IntrospectedClass) {
        for (const member of extended.node.members) {
          if (!validateMethod(member)) continue;
          methods.set(member.name, member);
        }
      }
    }
    return [...methods.values()].map((f) => {
      const mapping = /* @__PURE__ */ new Map();
      if (f.parent instanceof IntrospectedBaseClass) {
        const inter = this.interfaces.find((i) => i.equals(f.parent.getType()));
        if (inter instanceof GenerifiedTypeIdentifier) {
          f.parent.generics.forEach((g, i) => {
            if (inter.generics.length > i) {
              mapping.set(g.type.identifier, inter.generics[i]);
            }
          });
        }
      }
      const unwrapped = f.return().deepUnwrap();
      let modifiedReturn = f.return();
      if (unwrapped instanceof GenericType && mapping.has(unwrapped.identifier)) {
        const mapped = mapping.get(unwrapped.identifier);
        if (mapped) {
          modifiedReturn = f.return().rewrap(mapped);
        }
      } else if (unwrapped.equals(this.getType())) {
        modifiedReturn = f.return().rewrap(this.getType());
      }
      return f.copy({
        parent: this,
        interfaceParent: f.parent,
        parameters: f.parameters.map((p) => {
          const t = p.type.deepUnwrap();
          if (t instanceof GenericType && mapping.has(t.identifier)) {
            const iden = mapping.get(t.identifier);
            if (iden) {
              return p.copy({ type: p.type.rewrap(iden) });
            }
          }
          return p;
        }),
        outputParameters: f.output_parameters.map((p) => {
          const t = p.type.deepUnwrap();
          if (t instanceof GenericType && mapping.has(t.identifier)) {
            const iden = mapping.get(t.identifier);
            if (iden) {
              return p.copy({ type: p.type.rewrap(iden) });
            }
          }
          return p;
        }),
        returnType: modifiedReturn
      });
    });
  }
  resolveParents() {
    const self2 = this;
    return {
      *[Symbol.iterator]() {
        let current = this.extends();
        while (current !== void 0) {
          yield current;
          current = current.extends();
        }
      },
      extends() {
        const resolved_parent = self2.superType ? resolveTypeIdentifier(self2.namespace, self2.superType) : void 0;
        if (resolved_parent instanceof _IntrospectedClass) {
          return resolved_parent.resolveParents();
        }
        return void 0;
      },
      implements() {
        return self2.interfaces.map((iface) => {
          const resolved = resolveTypeIdentifier(self2.namespace, iface);
          if (resolved instanceof IntrospectedInterface) {
            return resolved.resolveParents();
          }
          throw new Error(`Interface ${iface.name} not found`);
        }).filter((res) => res !== void 0);
      },
      node: self2,
      identifier: self2.getType()
    };
  }
  copy(options2 = {}) {
    const klass = new _IntrospectedClass(this.name, this.namespace);
    klass.interfaces = [...this.interfaces];
    klass.superType = this.superType;
    klass.isAbstract = this.isAbstract;
    klass.doc = this.doc;
    klass.generics = [...this.generics];
    klass._staticDefinition = this._staticDefinition;
    const {
      signals = this.signals,
      constructors = this.constructors,
      members = this.members,
      props = this.props,
      fields = this.fields,
      callbacks = this.callbacks
    } = options2;
    klass.signals = [...signals.map((s) => s.copy({ parent: klass }))];
    klass.constructors = [...constructors.map((c) => c.copy({ parent: klass }))];
    klass.members = [...members.map((m) => m.copy({ parent: klass }))];
    klass.props = [...props.map((p) => p.copy({ parent: klass }))];
    klass.fields = [...fields.map((f) => f.copy({ parent: klass }))];
    klass.callbacks = [...callbacks.map((c) => c.copy({ parent: klass }))];
    if (this.mainConstructor) {
      klass.mainConstructor = this.mainConstructor.copy({ parent: klass });
    }
    klass.getGenericName = createGenericNameGeneratorAt(this.getGenericName());
    return klass._copyBaseProperties(this);
  }
  get staticDefinition() {
    return this._staticDefinition;
  }
  static fromXML(element, ns, options2) {
    const name = sanitizeIdentifierName(ns.namespace, element.$.name);
    if (options2.verbose) {
      log.debug(`  >> GirClass: Parsing definition ${element.$.name} (${name})...`);
    }
    const clazz = new _IntrospectedClass(name, ns);
    _IntrospectedClass.parseBasicProperties(element, clazz, ns, options2);
    _IntrospectedClass.parseResolveNames(element, clazz, ns, name);
    _IntrospectedClass.parseInheritanceAndMembers(element, clazz, ns, options2);
    return clazz;
  }
  static parseBasicProperties(element, clazz, ns, options2) {
    if (options2.loadDocs) {
      clazz.doc = parseDoc(element);
      clazz.metadata = parseMetadata(element);
    }
    if (element.$.parent) {
      clazz.superType = parseTypeIdentifier(ns.namespace, element.$.parent);
    }
    if (element.$.abstract) {
      clazz.isAbstract = true;
    }
  }
  static parseResolveNames(element, clazz, ns, name) {
    if (element.$["glib:type-name"]) {
      clazz.resolve_names.push(element.$["glib:type-name"]);
      ns.registerResolveName(element.$["glib:type-name"], ns.namespace, name);
    }
    if (element.$["c:type"]) {
      clazz.resolve_names.push(element.$["c:type"]);
      ns.registerResolveName(element.$["c:type"], ns.namespace, name);
    }
    const typeStruct = element.$["glib:type-struct"];
    if (typeStruct) {
      clazz.registerStaticDefinition(typeStruct);
      clazz.resolve_names.push(typeStruct);
      ns.registerResolveName(typeStruct, ns.namespace, name);
    }
  }
  static parseInheritanceAndMembers(element, clazz, ns, options2) {
    try {
      _IntrospectedClass.parseConstructors(element, clazz, options2);
      _IntrospectedClass.parseSignals(element, clazz, options2);
      _IntrospectedClass.parseProperties(element, clazz, options2);
      _IntrospectedClass.parseMethods(element, clazz, options2);
      _IntrospectedClass.parseFields(element, clazz);
      _IntrospectedClass.parseInterfaces(element, clazz, ns);
      _IntrospectedClass.parseCallbacks(element, clazz, ns, options2);
      _IntrospectedClass.parseVirtualMethods(element, clazz, options2);
      _IntrospectedClass.parseStaticFunctions(element, clazz, options2);
    } catch (e) {
      log.reportParsingFailure(clazz.name, "class", ns.namespace, e);
    }
  }
  static parseConstructors(element, clazz, options2) {
    if (Array.isArray(element.constructor)) {
      clazz.constructors.push(
        ...element.constructor.map(
          (constructorElement) => IntrospectedConstructor.fromXML(constructorElement, clazz, options2)
        )
      );
    }
  }
  static parseSignals(element, clazz, options2) {
    if (element["glib:signal"]) {
      clazz.signals.push(...element["glib:signal"].map((signal) => IntrospectedSignal.fromXML(signal, clazz, options2)));
    }
  }
  static parseProperties(element, clazz, options2) {
    if (!element.property) return;
    element.property.forEach((prop) => {
      const property = IntrospectedProperty.fromXML(prop, clazz, options2);
      switch (options2.propertyCase) {
        case "both": {
          clazz.props.push(property);
          const camelCase2 = property.toCamelCase();
          if (property.name !== camelCase2.name) {
            clazz.props.push(camelCase2);
          }
          break;
        }
        case "camel":
          clazz.props.push(property.toCamelCase());
          break;
        case "underscore":
          clazz.props.push(property);
          break;
      }
    });
  }
  static parseMethods(element, clazz, options2) {
    if (element.method) {
      clazz.members.push(...element.method.map((method) => IntrospectedClassFunction.fromXML(method, clazz, options2)));
    }
  }
  static parseFields(element, clazz) {
    if (element.field) {
      element.field.filter((field) => !("callback" in field)).forEach((field) => {
        const f = IntrospectedField.fromXML(field, clazz);
        clazz.fields.push(f);
      });
    }
  }
  static parseInterfaces(element, clazz, ns) {
    if (element.implements) {
      element.implements.forEach((implementee) => {
        const name = implementee.$.name;
        const type = parseTypeIdentifier(ns.namespace, name);
        if (type) {
          clazz.interfaces.push(type);
        }
      });
    }
  }
  static parseCallbacks(element, clazz, ns, options2) {
    if (element.callback) {
      if (options2.verbose) {
        element.callback.forEach((callback) => {
          log.debug(`Adding callback ${callback.$.name} for ${ns.namespace}`);
        });
      }
      clazz.callbacks.push(
        ...element.callback.map((callback) => IntrospectedClassCallback.fromXML(callback, clazz, options2))
      );
    }
  }
  static parseVirtualMethods(element, clazz, options2) {
    if (element["virtual-method"]) {
      clazz.members.push(
        ...element["virtual-method"].map((method) => IntrospectedVirtualClassFunction.fromXML(method, clazz, options2))
      );
    }
  }
  static parseStaticFunctions(element, clazz, options2) {
    if (element.function) {
      clazz.members.push(
        ...element.function.map((func) => IntrospectedStaticClassFunction.fromXML(func, clazz, options2))
      );
    }
  }
  registerStaticDefinition(typeStruct) {
    this._staticDefinition = typeStruct;
  }
  asString(generator) {
    return generator.generateClass(this);
  }
};
var IntrospectedInterface = class _IntrospectedInterface extends IntrospectedBaseClass {
  interfaces = [];
  noParent = false;
  accept(visitor) {
    const node = this.copy({
      constructors: this.constructors.map((c) => c.accept(visitor)),
      members: this.members.map((m) => m.accept(visitor)),
      props: this.props.map((p) => p.accept(visitor)),
      fields: this.fields.map((f) => f.accept(visitor)),
      callbacks: this.callbacks.map((c) => c.accept(visitor))
    });
    return visitor.visitInterface?.(node) ?? node;
  }
  someParent(predicate) {
    const resolution = this.resolveParents();
    const parent = resolution.extends();
    return !!parent && (predicate(parent.node) || parent.node.someParent(predicate));
  }
  findParent(predicate) {
    return this.findParentMap((parent) => {
      if (predicate(parent)) {
        return parent;
      }
      return void 0;
    });
  }
  findParentMap(predicate) {
    const resolution = this.resolveParents();
    const parent = resolution.extends();
    if (parent) {
      const result = predicate(parent.node);
      if (result !== void 0) return result;
      return parent.node.findParentMap(predicate);
    }
    return void 0;
  }
  resolveParents() {
    const self2 = this;
    return {
      *[Symbol.iterator]() {
        const parentResolution = this.extends();
        if (parentResolution) {
          yield parentResolution;
          yield* parentResolution;
        }
      },
      extends() {
        const resolved_parent = self2.superType ? resolveTypeIdentifier(self2.namespace, self2.superType) : void 0;
        if (resolved_parent instanceof _IntrospectedInterface) {
          return resolved_parent.resolveParents();
        }
        if (resolved_parent instanceof IntrospectedClass) {
          return resolved_parent.resolveParents();
        }
        return void 0;
      },
      node: self2,
      identifier: self2.getType()
    };
  }
  copy(options2 = {}) {
    const iface = new _IntrospectedInterface({ name: this.name, namespace: this.namespace });
    iface.interfaces = [...this.interfaces];
    iface.superType = this.superType;
    iface.doc = this.doc;
    iface.generics = [...this.generics];
    const {
      constructors = this.constructors,
      members = this.members,
      props = this.props,
      fields = this.fields,
      callbacks = this.callbacks
    } = options2;
    iface.constructors = [...constructors.map((c) => c.copy({ parent: iface }))];
    iface.members = [...members.map((m) => m.copy({ parent: iface }))];
    iface.props = [...props.map((p) => p.copy({ parent: iface }))];
    iface.fields = [...fields.map((f) => f.copy({ parent: iface }))];
    iface.callbacks = [...callbacks.map((c) => c.copy({ parent: iface }))];
    if (this.mainConstructor) {
      iface.mainConstructor = this.mainConstructor.copy({ parent: iface });
    }
    return iface._copyBaseProperties(this);
  }
  static fromXML(element, namespace, options2) {
    const name = sanitizeIdentifierName(namespace.namespace, element.$.name);
    if (options2.verbose) {
      log.debug(`  >> GirInterface: Parsing definition ${element.$.name} (${name})...`);
    }
    const iface = new _IntrospectedInterface({ name, namespace });
    _IntrospectedInterface.parseInterfaceBasicProperties(element, iface, namespace, options2);
    _IntrospectedInterface.parseInterfaceResolveNames(element, iface, namespace, name);
    _IntrospectedInterface.parseInterfaceMembers(element, iface, namespace, options2);
    return iface;
  }
  static parseInterfaceBasicProperties(element, iface, namespace, options2) {
    if (options2.loadDocs) {
      iface.doc = parseDoc(element);
      iface.metadata = parseMetadata(element);
    }
    if (element.prerequisite?.[0]) {
      const [prerequisite] = element.prerequisite;
      if (prerequisite.$.name) {
        iface.superType = parseTypeIdentifier(namespace.namespace, prerequisite.$.name);
      }
    }
  }
  static parseInterfaceResolveNames(element, iface, namespace, name) {
    if (element.$["glib:type-name"]) {
      iface.resolve_names.push(element.$["glib:type-name"]);
      namespace.registerResolveName(element.$["glib:type-name"], namespace.namespace, name);
    }
    if (element.$["c:type"]) {
      iface.resolve_names.push(element.$["c:type"]);
      namespace.registerResolveName(element.$["c:type"], namespace.namespace, name);
    }
  }
  static parseInterfaceMembers(element, iface, namespace, options2) {
    try {
      _IntrospectedInterface.parseInterfaceConstructors(element, iface, options2);
      _IntrospectedInterface.parseInterfaceProperties(element, iface, options2);
      _IntrospectedInterface.parseInterfaceMethods(element, iface, options2);
      _IntrospectedInterface.parseInterfaceFields(element, iface);
      _IntrospectedInterface.parseInterfaceCallbacks(element, iface, namespace, options2);
      _IntrospectedInterface.parseInterfaceVirtualMethods(element, iface, options2);
      _IntrospectedInterface.parseInterfaceStaticFunctions(element, iface, options2);
    } catch (e) {
      log.reportParsingFailure(iface.name, "interface", namespace.namespace, e);
    }
  }
  static parseInterfaceConstructors(element, iface, options2) {
    if (Array.isArray(element.constructor)) {
      iface.constructors.push(
        ...element.constructor.map(
          (constructorElement) => IntrospectedConstructor.fromXML(constructorElement, iface, options2)
        )
      );
    }
  }
  static parseInterfaceProperties(element, iface, options2) {
    if (!element.property) return;
    element.property.forEach((prop) => {
      const property = IntrospectedProperty.fromXML(prop, iface, options2);
      switch (options2.propertyCase) {
        case "both": {
          iface.props.push(property);
          const camelCase2 = property.toCamelCase();
          if (property.name !== camelCase2.name) {
            iface.props.push(camelCase2);
          }
          break;
        }
        case "camel":
          iface.props.push(property.toCamelCase());
          break;
        case "underscore":
          iface.props.push(property);
          break;
      }
    });
  }
  static parseInterfaceMethods(element, iface, options2) {
    if (element.method) {
      iface.members.push(...element.method.map((method) => IntrospectedClassFunction.fromXML(method, iface, options2)));
    }
  }
  static parseInterfaceFields(element, iface) {
    if (element.field) {
      element.field.filter((field) => !("callback" in field)).forEach((field) => {
        const f = IntrospectedField.fromXML(field, iface);
        iface.fields.push(f);
      });
    }
  }
  static parseInterfaceCallbacks(element, iface, namespace, options2) {
    if (element.callback) {
      if (options2.verbose) {
        element.callback.forEach((callback) => {
          log.debug(`Adding callback ${callback.$.name} for ${namespace.namespace}`);
        });
      }
      iface.callbacks.push(
        ...element.callback.map((callback) => IntrospectedClassCallback.fromXML(callback, iface, options2))
      );
    }
  }
  static parseInterfaceVirtualMethods(element, iface, options2) {
    if (element["virtual-method"]) {
      iface.members.push(
        ...element["virtual-method"].map((method) => IntrospectedVirtualClassFunction.fromXML(method, iface, options2))
      );
    }
  }
  static parseInterfaceStaticFunctions(element, iface, options2) {
    if (element.function) {
      iface.members.push(
        ...element.function.map((func) => IntrospectedStaticClassFunction.fromXML(func, iface, options2))
      );
    }
  }
  asString(generator) {
    return generator.generateInterface(this);
  }
};

// ../lib/src/gir/parameter.ts
var IntrospectedFunctionParameter = class _IntrospectedFunctionParameter extends IntrospectedBase {
  type;
  direction;
  isVarArgs = false;
  isOptional = false;
  isNullable = false;
  constructor({
    name,
    direction,
    type,
    parent,
    doc: doc2,
    isVarArgs = false,
    isOptional = false,
    isNullable = false,
    ...args
  }) {
    super(name, parent ?? null, { ...args });
    this.type = type;
    this.direction = direction;
    this.doc = doc2;
    this.isVarArgs = isVarArgs;
    this.isOptional = isOptional;
    this.isNullable = isNullable;
  }
  get namespace() {
    if (!this.parent) throw new Error(`Failed to get namespace for ${this.name}`);
    return this.parent.namespace;
  }
  asField() {
    const { name, parent, isOptional: optional, type } = this;
    if (!(parent?.parent instanceof IntrospectedBaseClass)) {
      throw new Error("Can't convert parameter of non-class function to field");
    }
    return new IntrospectedField({ name, parent: parent.parent, optional, type });
  }
  copy(options2 = {
    parent: this.parent
  }) {
    const { type, parent, direction, isVarArgs, isOptional, isNullable, name, doc: doc2 } = this;
    return new _IntrospectedFunctionParameter({
      parent: options2.parent ?? parent,
      name,
      direction,
      isVarArgs,
      isOptional: options2.isOptional ?? isOptional,
      isNullable: options2.isNullable ?? isNullable,
      type: options2.type ?? type,
      doc: doc2
    })._copyBaseProperties(this);
  }
  accept(visitor) {
    const node = this.copy({
      type: visitor.visitType?.(this.type)
    });
    return visitor.visitParameter?.(node) ?? node;
  }
  asString(generator) {
    return generator.generateParameter(this);
  }
  static fromXML(parameter, parent, options2) {
    const ns = parent.namespace;
    let name = sanitizeMemberName(parameter.$.name);
    if (isInvalid(name)) {
      name = `_${name}`;
    }
    let isVarArgs = false;
    let isOptional = false;
    let isNullable = false;
    let type;
    let direction;
    if (!parameter.$.direction || parameter.$.direction === "in" /* In */ || parameter.$.direction === "inout" /* Inout */ || parameter.$.direction === "in-out" /* InOut */) {
      if (name === "...") {
        isVarArgs = true;
        name = "args";
      }
      direction = parameter.$.direction || "in" /* In */;
      const optional = parameter.$.optional === "1";
      const nullable = parameter.$.nullable === "1";
      if (optional) {
        isOptional = true;
      }
      if (nullable) {
        isNullable = true;
      }
      type = getType(ns, parameter);
    } else if (parameter.$.direction === "out" /* Out */) {
      direction = parameter.$.direction;
      type = getType(ns, parameter);
    } else {
      throw new Error(`Unknown parameter direction: ${parameter.$.direction}`);
    }
    const fp = new _IntrospectedFunctionParameter({
      isVarArgs,
      type: isVarArgs ? new ArrayType(type) : type,
      direction,
      parent: parent ?? void 0,
      isOptional,
      isNullable,
      name,
      isIntrospectable: isIntrospectable(parameter)
    });
    if (options2.loadDocs) {
      fp.doc = parseDoc(parameter);
      fp.metadata = parseMetadata(parameter);
    }
    return fp;
  }
};

// ../lib/src/gir/function.ts
var IntrospectedFunction = class _IntrospectedFunction extends IntrospectedNamespaceMember {
  parameters;
  output_parameters;
  return_type;
  raw_name;
  generics = [];
  returnTypeDoc;
  constructor({
    name,
    raw_name,
    return_type = UnknownType,
    parameters = [],
    output_parameters = [],
    namespace,
    ...args
  }) {
    super(name, namespace, { ...args });
    this.raw_name = raw_name;
    this.parameters = parameters.map((p) => p.copy({ parent: this }));
    this.output_parameters = output_parameters.map((p) => p.copy({ parent: this }));
    this.return_type = return_type;
    this.returnTypeDoc = null;
  }
  copy({
    parent = this.parent,
    outputParameters,
    parameters,
    return_type
  } = { parent: this.parent }) {
    const fn = new _IntrospectedFunction({
      namespace: parent ?? this.namespace,
      raw_name: this.raw_name,
      name: this.name,
      return_type: return_type ?? this.return_type,
      output_parameters: outputParameters ?? this.output_parameters,
      parameters: parameters ?? this.parameters
    });
    fn.returnTypeDoc = this.returnTypeDoc;
    fn.generics = [...this.generics];
    return fn._copyBaseProperties(this);
  }
  accept(visitor) {
    const node = this.copy({
      parent: this.parent,
      parameters: this.parameters.map((p) => {
        return p.accept(visitor);
      }),
      outputParameters: this.output_parameters.map((p) => {
        return p.accept(visitor);
      }),
      return_type: visitor.visitType?.(this.return_type)
    });
    return visitor.visitFunction?.(node) ?? node;
  }
  static fromXML(element, ns, options2) {
    let raw_name = element.$.name;
    let name = sanitizeIdentifierName(null, raw_name);
    if (hasShadow(element)) {
      raw_name = element.$.shadows;
      name = sanitizeIdentifierName(null, element.$.shadows);
    }
    const return_type = _IntrospectedFunction.parseReturnType(element, ns);
    const { input_parameters, output_parameters, returnTypeDoc } = _IntrospectedFunction.parseParameters(
      element,
      ns,
      return_type,
      options2
    );
    const fn = new _IntrospectedFunction({
      name,
      raw_name,
      namespace: ns,
      parameters: input_parameters,
      output_parameters,
      return_type,
      isIntrospectable: isIntrospectable(element)
    });
    fn.returnTypeDoc = returnTypeDoc;
    if (options2.loadDocs) {
      fn.doc = parseDoc(element);
      fn.metadata = parseMetadata(element);
    }
    return fn;
  }
  static parseReturnType(element, ns) {
    if ("return-value" in element && element["return-value"] && element["return-value"].length > 0) {
      const value = element["return-value"][0];
      return getType(ns, value);
    }
    return VoidType;
  }
  static parseParameters(element, ns, return_type, options2) {
    let returnTypeDoc = null;
    if ("return-value" in element && element["return-value"] && element["return-value"].length > 0) {
      const value = element["return-value"][0];
      returnTypeDoc = parseDoc(value);
    }
    if (!element.parameters) {
      return { input_parameters: [], output_parameters: [], returnTypeDoc };
    }
    const param = element.parameters[0].parameter;
    if (!param) {
      return { input_parameters: [], output_parameters: [], returnTypeDoc };
    }
    const tempFn = new _IntrospectedFunction({
      name: "temp",
      raw_name: "temp",
      namespace: ns,
      isIntrospectable: isIntrospectable(element)
    });
    const inputs = param.filter((p) => !!p.$.name);
    let parameters = inputs.map((i) => IntrospectedFunctionParameter.fromXML(i, tempFn, options2));
    const unwrapped = return_type.unwrap();
    const length_params = unwrapped instanceof ArrayType && unwrapped.length != null ? [unwrapped.length] : [];
    const user_data_params = [];
    parameters = _IntrospectedFunction.processParameterTypes(parameters, length_params, user_data_params);
    parameters = _IntrospectedFunction.filterParameters(parameters, length_params, user_data_params);
    parameters = _IntrospectedFunction.processOptionalParameters(parameters);
    const input_parameters = parameters.filter(
      (param2) => param2.direction === "in" /* In */ || param2.direction === "inout" /* Inout */
    );
    const output_parameters = parameters.filter(
      (param2) => param2.direction && (param2.direction === "out" /* Out */ || param2.direction === "inout" /* Inout */)
    ).map((parameter) => parameter.copy({ isOptional: false }));
    return { input_parameters, output_parameters, returnTypeDoc };
  }
  static processParameterTypes(parameters, length_params, user_data_params) {
    return parameters.map((p) => {
      const unwrapped_type = p.type.unwrap();
      if (unwrapped_type instanceof ArrayType && unwrapped_type.length != null) {
        length_params.push(unwrapped_type.length);
      }
      if (unwrapped_type instanceof ClosureType && unwrapped_type.user_data != null) {
        user_data_params.push(unwrapped_type.user_data);
      }
      return p;
    });
  }
  static filterParameters(parameters, length_params, user_data_params) {
    return parameters.filter((_, i) => !length_params.includes(i) && !user_data_params.includes(i)).filter((v) => !(v.type instanceof TypeIdentifier && v.type.is("GLib", "DestroyNotify")));
  }
  static processOptionalParameters(parameters) {
    return parameters.reverse().reduce(
      ({ allowOptions, params }, p) => {
        const { type, isOptional } = p;
        if (allowOptions) {
          if (type instanceof NullableType) {
            params.push(p.copy({ isOptional: true }));
          } else if (!isOptional) {
            params.push(p);
            return { allowOptions: false, params };
          } else {
            params.push(p);
          }
        } else {
          if (isOptional) {
            params.push(p.copy({ type: new NullableType(type), isOptional: false }));
          } else {
            params.push(p);
          }
        }
        return { allowOptions, params };
      },
      {
        allowOptions: true,
        params: []
      }
    ).params.reverse().filter((p) => p != null);
  }
  return() {
    return this.return_type;
  }
  getCallbackParameters() {
    return {
      name: this.name,
      raw_name: this.raw_name,
      namespace: this.namespace,
      output_parameters: this.output_parameters,
      parameters: this.parameters,
      return_type: this.return_type
    };
  }
  asString(generator) {
    return generator.generateFunction(this);
  }
};

// ../lib/src/gir/callback.ts
var IntrospectedCallback = class _IntrospectedCallback extends IntrospectedFunction {
  asFunctionType() {
    return new FunctionType(
      Object.fromEntries(this.parameters.map((p) => [p.name, p.type])),
      this.return_type
    );
  }
  copy({
    parameters,
    returnType,
    outputParameters,
    parent
  } = {}) {
    const cb = new _IntrospectedCallback({
      name: this.name,
      raw_name: this.raw_name,
      return_type: returnType ?? this.return_type,
      parameters: parameters ?? this.parameters,
      output_parameters: outputParameters ?? this.output_parameters,
      namespace: parent ?? this.parent
    })._copyBaseProperties(this);
    cb.generics = [...this.generics];
    return cb;
  }
  accept(visitor) {
    const node = this.copy({
      parameters: this.parameters.map((p) => {
        return p.accept(visitor);
      }),
      outputParameters: this.output_parameters.map((p) => {
        return p.accept(visitor);
      }),
      returnType: visitor.visitType?.(this.return_type)
    });
    return visitor.visitCallback?.(node) ?? node;
  }
  static fromXML(element, namespace, options2) {
    const ns = namespace;
    const cb = new _IntrospectedCallback(IntrospectedFunction.fromXML(element, ns, options2).getCallbackParameters());
    const glibTypeName = element.$["glib:type-name"];
    if (typeof glibTypeName === "string" && element.$["glib:type-name"]) {
      cb.resolve_names.push(glibTypeName);
      ns.registerResolveName(glibTypeName, ns.namespace, cb.name);
    }
    if (element.$["c:type"]) {
      cb.resolve_names.push(element.$["c:type"]);
      ns.registerResolveName(element.$["c:type"], ns.namespace, cb.name);
    }
    return cb;
  }
  asString(generator) {
    return generator.generateCallback(this);
  }
};

// ../lib/src/gir/const.ts
var IntrospectedConstant = class _IntrospectedConstant extends IntrospectedNamespaceMember {
  type;
  value;
  constructor({
    name,
    type,
    namespace,
    value,
    ...options2
  }) {
    super(name, namespace, options2);
    this.type = type;
    this.value = value;
  }
  accept(visitor) {
    const node = this.copy({
      type: visitor.visitType?.(this.type)
    });
    return visitor.visitConst?.(node) ?? node;
  }
  copy(options2 = {}) {
    const { type, name, value } = this;
    return new _IntrospectedConstant({
      name,
      namespace: options2.parent ?? this.namespace,
      type: options2.type ?? type,
      value
    })._copyBaseProperties(this);
  }
  static fromXML(element, ns, options2) {
    const c = new _IntrospectedConstant({
      name: sanitizeIdentifierName(ns.namespace, element.$.name),
      namespace: ns,
      type: getType(ns, element),
      value: element.$.value ?? null
    });
    if (options2.loadDocs) {
      c.doc = parseDoc(element);
      c.metadata = parseMetadata(element);
    }
    return c;
  }
  asString(generator) {
    return generator.generateConst(this);
  }
};

// ../lib/src/gir/direct-allocation-constructor.ts
var IntrospectedDirectAllocationConstructor = class _IntrospectedDirectAllocationConstructor extends IntrospectedClassMember {
  parameters;
  constructor(parameters, parent) {
    super("new", parent, { isPrivate: false, isIntrospectable: true });
    this.parameters = parameters.map((parameter) => parameter.copy({ parent: this }));
  }
  static fromFields(fields, parent) {
    const building = new _IntrospectedDirectAllocationConstructor([], parent);
    building.parameters = fields.filter((field) => {
      return !field.isStatic && !field.isPrivate && !field.type.isPointer;
    }).map(
      (field) => new IntrospectedFunctionParameter({
        parent: building,
        type: field.type,
        name: field.name,
        direction: "in" /* In */
      })
    );
    return building;
  }
  asString(generator) {
    return generator.generateDirectAllocationConstructor(this);
  }
  copy(options2) {
    const copy2 = new _IntrospectedDirectAllocationConstructor(
      options2?.parameters ?? this.parameters,
      options2?.parent ?? this.parent
    );
    copy2._copyBaseProperties(this);
    return copy2;
  }
  accept(visitor) {
    const node = this.copy({
      parameters: this.parameters.map((parameters) => {
        return parameters.accept(visitor);
      })
    });
    return visitor.visitDirectAllocationConstructor?.(node) ?? node;
  }
};

// ../lib/src/gir/enum-member.ts
var GirEnumMember = class _GirEnumMember extends IntrospectedBase {
  value;
  c_identifier;
  constructor(name, value, parent, c_identifier) {
    super(name, parent);
    this.value = value;
    this.c_identifier = c_identifier;
  }
  get namespace() {
    return this.parent.namespace;
  }
  accept(visitor) {
    const node = this.copy();
    return visitor.visitEnumMember?.(node) ?? node;
  }
  copy() {
    const { value, name, parent, c_identifier } = this;
    return new _GirEnumMember(name, value, parent, c_identifier)._copyBaseProperties(this);
  }
  static fromXML(element, parent, options2) {
    const upper = element.$.name.toUpperCase();
    const c_identifier = element.$["c:identifier"];
    const enumMember = new _GirEnumMember(upper, element.$.value, parent, c_identifier);
    if (options2.loadDocs) {
      enumMember.doc = parseDoc(element);
      enumMember.metadata = parseMetadata(element);
    }
    return enumMember;
  }
  asString(generator) {
    return generator.generateEnumMember(this);
  }
};

// ../lib/src/gir/record.ts
var log2 = new ConsoleReporter(true, "gir/class", true);
var IntrospectedRecord = class _IntrospectedRecord extends IntrospectedBaseClass {
  _isForeign = false;
  _structFor = null;
  _isSimple = null;
  _isSimpleWithoutPointers = null;
  /**
   * Returns all signals for this record (records typically don't have signals)
   */
  getAllSignals() {
    return [];
  }
  isForeign() {
    return this._isForeign;
  }
  get structFor() {
    return this._structFor;
  }
  getType() {
    if (this._structFor) {
      return this._structFor;
    }
    return new TypeIdentifier(this.name, this.namespace.namespace);
  }
  someParent(predicate) {
    const resolution = this.resolveParents();
    const parent = resolution.extends();
    return !!parent && (predicate(parent.node) || parent.node.someParent(predicate));
  }
  findParent(predicate) {
    const resolution = this.resolveParents();
    const parent = resolution.extends();
    if (parent) {
      if (predicate(parent.node)) return parent.node;
      const found = parent.node.findParent(predicate);
      if (found) return found;
    }
    return void 0;
  }
  findParentMap(predicate) {
    const resolution = this.resolveParents();
    const parent = resolution.extends();
    if (parent) {
      const result = predicate(parent.node);
      if (result !== void 0) return result;
      return parent.node.findParentMap(predicate);
    }
    return void 0;
  }
  accept(visitor) {
    const node = this.copy({
      constructors: this.constructors.map((c) => c.accept(visitor)),
      members: this.members.map((m) => m.accept(visitor)),
      props: this.props.map((p) => p.accept(visitor)),
      fields: this.fields.map((f) => f.accept(visitor)),
      callbacks: this.callbacks.map((c) => c.accept(visitor))
    });
    return visitor.visitRecord?.(node) ?? node;
  }
  resolveParents() {
    const { namespace, superType } = this;
    return {
      *[Symbol.iterator]() {
        let current = this.extends();
        while (current !== void 0) {
          yield current;
          current = current.extends();
        }
      },
      extends() {
        const resolved_parent = superType ? resolveTypeIdentifier(namespace, superType) : void 0;
        if (resolved_parent instanceof _IntrospectedRecord) return resolved_parent.resolveParents();
        return void 0;
      },
      node: this,
      identifier: this.getType()
    };
  }
  copy(options2 = {}) {
    const {
      name,
      namespace,
      superType,
      members,
      constructors,
      _isForeign,
      _structFor,
      props,
      fields,
      callbacks,
      generics,
      mainConstructor
    } = this;
    const clazz = new _IntrospectedRecord({ name, namespace });
    clazz._copyBaseProperties(this);
    if (superType) {
      clazz.superType = superType;
    }
    clazz._structFor = _structFor;
    clazz._isForeign = _isForeign;
    clazz.props = (options2.props ?? props).map((p) => p.copy({ parent: clazz }));
    clazz.fields = (options2.fields ?? fields).map((f) => f.copy({ parent: clazz }));
    clazz.callbacks = (options2.callbacks ?? callbacks).map((c) => c.copy({ parent: clazz }));
    clazz.mainConstructor = mainConstructor?.copy({ parent: clazz }) ?? null;
    clazz.constructors = (options2.constructors ?? constructors).map((c) => c.copy({ parent: clazz }));
    clazz.members = (options2.members ?? members).map((m) => m.copy({ parent: clazz }));
    clazz.generics = [...generics];
    return clazz;
  }
  static foreign(name, namespace) {
    const foreignRecord = new _IntrospectedRecord({ name, namespace });
    foreignRecord._isForeign = true;
    return foreignRecord;
  }
  static fromXML(element, namespace, options2) {
    if (!element.$.name) {
      throw new Error("Invalid GIR File: No name provided for union.");
    }
    const name = sanitizeIdentifierName(namespace.namespace, element.$.name);
    if (options2.verbose) {
      log2.debug(`  >> GirRecord: Parsing definition ${element.$.name} (${name})...`);
    }
    const clazz = new _IntrospectedRecord({ name, namespace });
    _IntrospectedRecord.configureRecordProperties(element, clazz);
    _IntrospectedRecord.setupTypeStructOrResolveNames(element, clazz, namespace, name);
    _IntrospectedRecord.parseRecordDocumentation(element, clazz, options2);
    _IntrospectedRecord.parseRecordMembers(element, clazz, options2);
    return clazz;
  }
  static configureRecordProperties(element, clazz) {
    const isPrivate = _IntrospectedRecord.isRecordPrivate(element);
    clazz.setPrivate(isPrivate);
    const isForeign = "foreign" in element.$ && element.$.foreign === "1";
    clazz._isForeign = isForeign;
  }
  static isRecordPrivate(element) {
    if (!element.$.name) {
      return false;
    }
    return element.$.name.startsWith("_") || "disguised" in element.$ && element.$.disguised === "1" || "opaque" in element.$ && element.$.opaque === "1";
  }
  static setupTypeStructOrResolveNames(element, clazz, namespace, name) {
    const gtypeStructFor = element.$["glib:is-gtype-struct-for"];
    if (typeof gtypeStructFor === "string" && gtypeStructFor) {
      const structFor = parseTypeIdentifier(namespace.namespace, gtypeStructFor);
      clazz._structFor = new ClassStructTypeIdentifier(structFor.name, structFor.namespace);
    } else {
      _IntrospectedRecord.registerResolveNames(element, clazz, namespace, name);
    }
  }
  static registerResolveNames(element, clazz, namespace, name) {
    if (element.$["glib:type-name"]) {
      clazz.resolve_names.push(element.$["glib:type-name"]);
      namespace.registerResolveName(element.$["glib:type-name"], namespace.namespace, name);
    }
    if (element.$["c:type"]) {
      clazz.resolve_names.push(element.$["c:type"]);
      namespace.registerResolveName(element.$["c:type"], namespace.namespace, name);
    }
  }
  static parseRecordDocumentation(element, clazz, options2) {
    if (options2.loadDocs) {
      clazz.doc = parseDoc(element);
      clazz.metadata = parseMetadata(element);
    }
  }
  static parseRecordMembers(element, clazz, options2) {
    try {
      _IntrospectedRecord.parseRecordMethods(element, clazz, options2);
      _IntrospectedRecord.parseRecordConstructors(element, clazz, options2);
      _IntrospectedRecord.parseRecordStaticMethods(element, clazz, options2);
      _IntrospectedRecord.parseRecordFields(element, clazz);
    } catch (e) {
      log2.reportParsingFailure(clazz.name, "record", clazz.namespace.namespace, e);
    }
  }
  static parseRecordMethods(element, clazz, options2) {
    if (element.method) {
      clazz.members.push(...element.method.map((method) => IntrospectedClassFunction.fromXML(method, clazz, options2)));
    }
  }
  static parseRecordConstructors(element, clazz, options2) {
    if (Array.isArray(element.constructor)) {
      element.constructor.forEach((ctor) => {
        const c = IntrospectedConstructor.fromXML(ctor, clazz, options2);
        clazz.constructors.push(c);
      });
    }
  }
  static parseRecordStaticMethods(element, clazz, options2) {
    if (element.function) {
      clazz.members.push(
        ...element.function.map((func) => IntrospectedStaticClassFunction.fromXML(func, clazz, options2))
      );
    }
  }
  static parseRecordFields(element, clazz) {
    if (element.field) {
      clazz.fields.push(
        ...element.field.filter((field) => !("callback" in field)).map((field) => IntrospectedField.fromXML(field, clazz))
      );
    }
  }
  /**
   * Calculate if a type expression is "simple" without pointers
   */
  isSimpleTypeWithoutPointers(typeContainer) {
    if (!this.isSimpleType(typeContainer)) {
      return false;
    }
    if (typeContainer.isPointer) {
      return false;
    }
    if (typeContainer instanceof NativeType) {
      return true;
    }
    if (typeContainer instanceof ArrayType) {
      if (typeContainer.type.equals(this.getType())) {
        return true;
      }
      return this.isSimpleTypeWithoutPointers(typeContainer.type);
    }
    if (typeContainer instanceof TypeIdentifier) {
      const type = typeContainer;
      const child_ns = this.namespace.assertInstalledImport(type.namespace);
      const alias = child_ns.getAlias(type.name);
      if (alias) {
        return this.isSimpleTypeWithoutPointers(alias.type);
      }
      const child = child_ns.getClass(type.name);
      if (child === this) {
        return false;
      }
      if (child instanceof _IntrospectedRecord) {
        return child.isSimpleWithoutPointers() !== null;
      }
    }
    return false;
  }
  /**
   * Calculate if a type expression is "simple"
   */
  isSimpleType(typeContainer) {
    if (typeContainer instanceof NativeType) {
      return true;
    }
    if (typeContainer instanceof ArrayType) {
      if (typeContainer.type.equals(this.getType())) {
        return true;
      }
      return this.isSimpleType(typeContainer.type);
    }
    if (typeContainer instanceof TypeIdentifier) {
      const type = typeContainer;
      const child_ns = this.namespace.assertInstalledImport(type.namespace);
      const alias = child_ns.getAlias(type.name);
      if (alias) {
        return this.isSimpleType(alias.type);
      }
      const child = child_ns.getClass(type.name);
      if (child === this) {
        return false;
      }
      if (child instanceof _IntrospectedRecord) {
        return child.isSimple();
      }
    }
    return false;
  }
  /**
   * Check if a record is "simple" and can be constructed by GJS
   */
  isSimple() {
    if (this.fields.length === 0) {
      return false;
    }
    if (this._isSimple !== null) {
      return this._isSimple;
    }
    const isSimple = this.fields.every((f) => this.isSimpleType(f.type));
    this._isSimple = isSimple;
    return isSimple;
  }
  isSimpleWithoutPointers() {
    if (!this.isSimple()) {
      return null;
    }
    if (this._isSimpleWithoutPointers !== null) {
      return this._isSimpleWithoutPointers;
    }
    const isSimpleWithoutPointers = this.fields.find((f) => {
      return !this.isSimpleTypeWithoutPointers(f.type);
    });
    if (!isSimpleWithoutPointers) this._isSimpleWithoutPointers = "all fields good";
    else this._isSimpleWithoutPointers = null;
    return this._isSimpleWithoutPointers;
  }
  asString(generator) {
    return generator.generateRecord(this);
  }
};

// ../lib/src/gir/gir-complex-record.ts
var GirComplexRecord = class extends IntrospectedRecord {
  isSimple() {
    return false;
  }
};

// ../lib/src/gir/enum.ts
var IntrospectedEnum = class _IntrospectedEnum extends IntrospectedNamespaceMember {
  members = /* @__PURE__ */ new Map();
  flags = false;
  ns;
  constructor(name, namespace, options2 = {}) {
    super(sanitizeIdentifierName(namespace.namespace, name), namespace, options2);
    this.ns = namespace;
  }
  copy({ members } = {}) {
    const { namespace, name, flags } = this;
    const en = new _IntrospectedEnum(name, namespace);
    for (const [key, member] of (members ?? this.members).entries()) {
      en.members.set(key, member.copy());
    }
    en.flags = flags;
    en._copyBaseProperties(this);
    return en;
  }
  accept(visitor) {
    const node = this.copy({
      members: new Map(
        Array.from(this.members.entries()).map(([name, m]) => {
          return [name, m.accept(visitor)];
        })
      )
    });
    return visitor.visitEnum?.(node) ?? node;
  }
  getType() {
    return new TypeIdentifier(this.name, this.ns.namespace);
  }
  asString(generator) {
    return generator.generateEnum(this);
  }
  asClass() {
    const { name, namespace, doc: doc2 } = this;
    const clazz = new GirComplexRecord({ name, namespace, doc: doc2 });
    clazz.fields.push(
      ...Array.from(this.members.values()).map((m) => {
        const field = new IntrospectedField({
          name: m.name,
          parent: clazz,
          type: NumberType,
          writable: true,
          isStatic: true
        });
        field.doc = m.doc;
        field.metadata = m.metadata;
        return field;
      })
    );
    clazz.members = [];
    return clazz;
  }
  static fromXML(element, ns, options2, flags = false) {
    const em = new _IntrospectedEnum(sanitizeMemberName(element.$.name), ns);
    if (element.$["glib:type-name"]) {
      em.resolve_names.push(element.$["glib:type-name"]);
      ns.registerResolveName(element.$["glib:type-name"], ns.namespace, em.name);
    }
    if (element.$["c:type"]) {
      em.resolve_names.push(element.$["c:type"]);
      ns.registerResolveName(element.$["c:type"], ns.namespace, em.name);
    }
    if (options2.loadDocs) {
      em.doc = parseDoc(element);
      em.metadata = parseMetadata(element);
    }
    if (!element.member) {
      return em;
    }
    element.member.forEach((m) => {
      const member = GirEnumMember.fromXML(m, em, options2);
      em.members.set(member.name, member);
    });
    em.flags = flags;
    return em;
  }
};

// ../lib/src/gir/error.ts
function isEnumElement(e) {
  return typeof e === "object" && e != null && "function" in e;
}
var IntrospectedError = class _IntrospectedError extends IntrospectedEnum {
  functions = /* @__PURE__ */ new Map();
  asString(generator) {
    return generator.generateError(this);
  }
  copy({ members } = {}) {
    const { namespace, name, flags } = this;
    const en = new _IntrospectedError(name, namespace);
    for (const [key, member] of (members ?? this.members).entries()) {
      en.members.set(key, member.copy());
    }
    for (const [key, func] of this.functions.entries()) {
      en.functions.set(key, func.copy({ parent: en }));
    }
    en.flags = flags;
    return en._copyBaseProperties(this);
  }
  static fromXML(element, ns, options2) {
    const err = new _IntrospectedError(sanitizeMemberName(element.$.name), ns);
    if (element.$["glib:type-name"]) {
      err.resolve_names.push(element.$["glib:type-name"]);
      ns.registerResolveName(element.$["glib:type-name"], ns.namespace, err.name);
    }
    if (element.$["c:type"]) {
      err.resolve_names.push(element.$["c:type"]);
      ns.registerResolveName(element.$["c:type"], ns.namespace, err.name);
    }
    if (options2.loadDocs) {
      err.doc = parseDoc(element);
      err.metadata = parseMetadata(element);
    }
    if (element.member) {
      element.member.forEach((m) => {
        const member = GirEnumMember.fromXML(m, err, options2);
        err.members.set(member.name, member);
      });
    }
    if (isEnumElement(element) && element.function) {
      element.function.forEach((f) => {
        const func = IntrospectedStaticClassFunction.fromXML(f, err, options2);
        err.functions.set(func.name, func);
      });
    }
    return err;
  }
};

// ../lib/src/utils/documentation.ts
function transformGirDocText(text) {
  text = transformGirDocHighlights(text);
  text = transformGirDocCodeBlocks(text);
  return text;
}
function transformGirDocTagText(text) {
  return text.replace(NEW_LINE_REG_EXP, " ");
}
function transformGirDocHighlights(description7) {
  const highlights = description7.match(/@[A-Za-z_-]*[^\s.]/gm);
  if (highlights) {
    for (const highlight of highlights) {
      description7 = description7.replace(highlight, `\`${highlight.slice(1)}\``);
    }
  }
  return description7;
}
function transformGirDocCodeBlocks(description7) {
  description7 = description7.replaceAll(/\|\[<!-- language="C" -->/gm, "\n```c").replaceAll(/\|\[/gm, "\n```").replaceAll(/\]\|/gm, "```\n");
  return description7;
}

// ../lib/src/utils/objects.ts
var import_lodash = __toESM(require_lodash(), 1);
var isEqual = import_lodash.default.isEqual;
var map = import_lodash.default.map;
var find = import_lodash.default.find;
var merge = import_lodash.default.merge;
var clone = import_lodash.default.clone;
var cloneDeep = import_lodash.default.cloneDeep;
var isIterable = (obj) => {
  return obj != null && typeof obj[Symbol.iterator] === "function";
};
var union = (target, source) => {
  return /* @__PURE__ */ new Set([...target, ...source]);
};

// ../lib/src/gir-module.ts
var logger = new ConsoleReporter(false, "GirModule", false);
var GirModule = class _GirModule {
  /**
   * E.g. 'Gtk'
   */
  get namespace() {
    return this.dependency.namespace;
  }
  /**
   * E.g. '4.0'
   */
  get version() {
    return this.dependency.version;
  }
  /**
   * E.g. 'Gtk-4.0'
   */
  get packageName() {
    return this.dependency.packageName;
  }
  /**
   * E.g. 'Gtk40'
   * Is used in the generated index.d.ts, for example: `import * as Gtk40 from "./Gtk-4.0.ts";`
   */
  get importNamespace() {
    return this.dependency.importNamespace;
  }
  /**
   * The NPM package name E.g. 'gtk-4.0'
   */
  get importName() {
    return this.dependency.importName;
  }
  /**
   * Import path for the package E.g. './Gtk-4.0.ts' or '@girs/Gtk-4.0'
   */
  get importPath() {
    return this.dependency.importPath;
  }
  prefixes = [];
  /**
   * The version of the library as an object.
   * E.g. `{ major: 4, minor: 0, patch: 0 }` or as string `4.0.0`'
   */
  get libraryVersion() {
    if (this.namespace === "GObject" || this.namespace === "Gio") {
      const dep = this.allDependencies.find((girModule) => girModule.namespace === "GLib");
      if (dep) {
        return dep.libraryVersion;
      }
    }
    return this.dependency.libraryVersion;
  }
  _dependencies = null;
  _transitiveDependencies = null;
  get dependencies() {
    if (!this._dependencies) {
      throw new Error("dependencies is not initialized, run initDependencies() first");
    }
    return this._dependencies;
  }
  get transitiveDependencies() {
    if (!this._transitiveDependencies) {
      throw new Error("transitiveDependencies is not initialized, run initTransitiveDependencies() first");
    }
    return this._transitiveDependencies;
  }
  get allDependencies() {
    if (!this.dependencies) {
      throw new Error("dependencies is not initialized, run init() first");
    }
    return [.../* @__PURE__ */ new Set([...this.dependencies, ...this.transitiveDependencies])];
  }
  dependencyManager;
  log;
  extends;
  /**
   * To prevent constants from being exported twice, the names already exported are saved here for comparison.
   * Please note: Such a case is only known for Zeitgeist-2.0 with the constant "ATTACHMENT"
   */
  constNames = {};
  c_prefixes;
  dependency;
  _members;
  _enum_constants;
  _resolve_names = /* @__PURE__ */ new Map();
  __dts__references;
  package_version;
  parent;
  config;
  constructor(dependency, prefixes, config) {
    this.dependency = dependency;
    this.c_prefixes = [...prefixes];
    this.package_version = ["0", "0"];
    this.config = config;
    this.dependencyManager = DependencyManager.getInstance(this.config);
  }
  async initDependencies() {
    this._dependencies = await this.dependencyManager.fromGirIncludes(
      this.dependency.girXML?.repository[0]?.include || []
    );
  }
  async initTransitiveDependencies(transitiveDependencies) {
    this._transitiveDependencies = await this.checkTransitiveDependencies(transitiveDependencies);
  }
  get ns() {
    return this;
  }
  async checkTransitiveDependencies(transitiveDependencies) {
    if (this.packageName !== "GObject-2.0") {
      if (!find(transitiveDependencies, (x) => x.packageName === "GObject-2.0")) {
        transitiveDependencies.push(await this.dependencyManager.get("GObject", "2.0"));
      }
    }
    if (this.packageName === "UnityExtras-7.0") {
      if (!find(transitiveDependencies, (x) => x.packageName === "Unity-7.0")) {
        transitiveDependencies.push(await this.dependencyManager.get("Unity", "7.0"));
      }
    }
    if (this.packageName === "UnityExtras-6.0") {
      if (!find(transitiveDependencies, (x) => x.packageName === "Unity-6.0")) {
        transitiveDependencies.push(await this.dependencyManager.get("Unity", "6.0"));
      }
    }
    if (this.packageName === "GTop-2.0") {
      if (!find(transitiveDependencies, (x) => x.packageName === "GLib-2.0")) {
        transitiveDependencies.push(await this.dependencyManager.get("GLib", "2.0"));
      }
    }
    if (this.packageName === "GioUnix-2.0") {
      if (!find(transitiveDependencies, (x) => x.packageName === "Gio-2.0")) {
        transitiveDependencies.push(await this.dependencyManager.get("Gio", "2.0"));
      }
      if (!find(transitiveDependencies, (x) => x.packageName === "GLib-2.0")) {
        transitiveDependencies.push(await this.dependencyManager.get("GLib", "2.0"));
      }
    }
    transitiveDependencies = transitiveDependencies.filter((dep, index, self2) => {
      const samePackage = self2.findIndex((t) => t.namespace === dep.namespace);
      this.log.debug(`Filtering out dependency with same namespace: ${dep.namespace} ${index} ${samePackage}`);
      return index === samePackage;
    });
    return transitiveDependencies;
  }
  getTsDocReturnTags(girElement) {
    const girReturnValue = girElement?.returnTypeDoc;
    if (!girReturnValue) {
      return [];
    }
    const returnTag = {
      tagName: "returns",
      paramName: "",
      text: transformGirDocTagText(girReturnValue)
    };
    return [returnTag];
  }
  getTsDocInParamTags(inParams) {
    const tags = [];
    if (!inParams?.length) {
      return tags;
    }
    for (const inParam of inParams) {
      if (inParam.name) {
        tags.push({
          paramName: inParam.name,
          tagName: "param",
          text: typeof inParam.doc === "string" ? transformGirDocTagText(inParam.doc) : ""
        });
      }
    }
    return tags;
  }
  registerResolveName(resolveName, namespace, name) {
    this._resolve_names.set(resolveName, new TypeIdentifier(name, namespace));
  }
  get members() {
    if (!this._members) {
      this._members = /* @__PURE__ */ new Map();
    }
    return this._members;
  }
  get enum_constants() {
    if (!this._enum_constants) {
      this._enum_constants = /* @__PURE__ */ new Map();
    }
    return this._enum_constants;
  }
  accept(visitor) {
    for (const key of [...this.members.keys()]) {
      const member = this.members.get(key);
      if (!member) continue;
      if (Array.isArray(member)) {
        this.members.set(
          key,
          member.map((m) => {
            return m.accept(visitor);
          })
        );
      } else {
        this.members.set(key, member.accept(visitor));
      }
    }
    return this;
  }
  getImportsForCPrefix(c_prefix) {
    return this.parent.namespacesForPrefix(c_prefix);
  }
  // TODO: Move this into the generator
  hasImport(name) {
    return this.dependencies.some((dep) => dep.importName === name);
  }
  _getImport(namespace) {
    if (namespace === this.namespace) {
      return this;
    }
    const dep = this.dependencies?.find((dep2) => dep2.namespace === namespace) ?? this.transitiveDependencies.find((dep2) => dep2.namespace === namespace);
    if (!dep) {
      this.log.info(`Failed to find namespace ${namespace} in dependencies, resolving via c:prefixes`);
      const resolvedNamespaces = this.parent.namespacesForPrefix(namespace);
      if (resolvedNamespaces.length > 0) {
        this.log.info(
          `Found namespaces for prefix ${namespace}: ${resolvedNamespaces.map((r) => `${r.namespace} (${r.version})`).join(", ")}`
        );
      }
      for (const resolvedNamespace of resolvedNamespaces) {
        if (resolvedNamespace.namespace === this.namespace && resolvedNamespace.version === this.version) {
          return this;
        }
        const dep2 = this.dependencies?.find(
          (dep3) => dep3.namespace === resolvedNamespace.namespace && dep3.version === resolvedNamespace.version
        ) ?? this.transitiveDependencies.find(
          (dep3) => dep3.namespace === resolvedNamespace.namespace && dep3.version === resolvedNamespace.version
        );
        if (dep2) {
          return this.parent.namespace(resolvedNamespace.namespace, dep2.version);
        }
      }
    }
    let version = dep?.version;
    if (!version) {
      version = this.parent.assertDefaultVersionOf(namespace);
    }
    return this.parent.namespace(namespace, version);
  }
  getInstalledImport(_namespace) {
    if (_namespace === this.namespace) {
      return this;
    }
    const dep = this.dependencies?.find((dep2) => dep2.namespace === _namespace) ?? this.transitiveDependencies.find((dep2) => dep2.namespace === _namespace);
    let version = dep?.version;
    if (!version) {
      version = this.parent.defaultVersionOf(_namespace) ?? void 0;
    }
    if (!version) {
      return null;
    }
    const namespace = this.parent.namespace(_namespace, version);
    return namespace;
  }
  assertInstalledImport(_namespace) {
    const namespace = this._getImport(_namespace);
    if (!namespace) {
      throw new Error(`Failed to import ${_namespace} in ${this.namespace}, not installed or accessible.`);
    }
    return namespace;
  }
  getMembers(name) {
    const members = this.members.get(name);
    if (Array.isArray(members)) {
      return [...members];
    }
    return members ? [members] : [];
  }
  getMemberWithoutOverrides(name) {
    if (this.members.has(name)) {
      const member = this.members.get(name);
      if (!Array.isArray(member)) {
        return member;
      }
      return null;
    }
    const resolvedName = this._resolve_names.get(name);
    if (resolvedName) {
      const member = this.members.get(resolvedName.name);
      if (!Array.isArray(member)) {
        return member;
      }
    }
    return null;
  }
  assertClass(name) {
    const clazz = this.getClass(name);
    if (!clazz) {
      throw new Error(`[${this.packageName}] Class ${name} does not exist in namespace ${this.namespace}.`);
    }
    return clazz;
  }
  getClass(name) {
    const member = this.getMemberWithoutOverrides(name);
    if (member instanceof IntrospectedBaseClass) {
      return member;
    }
    return null;
  }
  getEnum(name) {
    const member = this.getMemberWithoutOverrides(name);
    if (member instanceof IntrospectedEnum) {
      return member;
    }
    return null;
  }
  getAlias(name) {
    const member = this.getMemberWithoutOverrides(name);
    if (member instanceof IntrospectedAlias) {
      return member;
    }
    return null;
  }
  hasSymbol(name) {
    return this.members.has(name);
  }
  resolveSymbolFromTypeName(name) {
    const resolvedName = this._resolve_names.get(name);
    if (!resolvedName) {
      return null;
    }
    const member = this.members.get(resolvedName.name);
    if (member instanceof IntrospectedBase) {
      return member.name;
    }
    return null;
  }
  findClassCallback(name) {
    const clazzes = Array.from(this.members.values()).filter(
      (m) => m instanceof IntrospectedBaseClass
    );
    const res = clazzes.map((m) => [
      m,
      m.callbacks.find((c) => c.name === name || c.resolve_names.includes(name))
    ]).find((r) => r[1] != null);
    if (res) {
      return [res[0].name, res[1].name];
    } else {
      return [null, name];
    }
  }
  /**
   * This is an internal method to add TypeScript <reference>
   * comments when overrides use parts of the TypeScript standard
   * libraries that are newer than default.
   */
  ___dts___addReference(reference) {
    this.__dts__references ??= [];
    this.__dts__references.push(reference);
  }
  static async load(dependency, config, registry) {
    const girXML = dependency.girXML;
    const ns = girXML?.repository[0]?.namespace?.[0];
    if (!girXML) {
      throw new Error(`Failed to load gir xml of ${dependency.packageName}`);
    }
    if (!ns) {
      const packageName = girXML.repository[0].package?.[0]?.$.name || "unknown package";
      throw new Error(`Missing namespace in ${packageName}`);
    }
    const modName = ns.$.name;
    const version = ns.$.version;
    if (!modName) {
      throw new Error("Invalid GIR file: no namespace name specified.");
    }
    if (!version) {
      throw new Error("Invalid GIR file: no version name specified.");
    }
    const c_prefix = ns.$?.["c:identifier-prefixes"]?.split(",") ?? [];
    const building = new _GirModule(dependency, c_prefix, config);
    await building.initDependencies();
    building.parent = registry;
    registry.register(building);
    const prefixes = girXML.repository[0]?.$?.["c:identifier-prefixes"]?.split(",");
    const unknownPrefixes = prefixes?.filter((pre) => pre !== modName);
    if (unknownPrefixes && unknownPrefixes.length > 0) {
      logger.log(`Found additional prefixes for ${modName}: ${unknownPrefixes.join(", ")}`);
      building.prefixes.push(...unknownPrefixes);
    }
    building.log = new ConsoleReporter(
      config.verbose,
      `GirModule(${building.packageName})`,
      config.reporter,
      config.reporterOutput
    );
    if (config.reporter) {
      const reporterService = ReporterService.getInstance();
      reporterService.registerReporter(`GirModule(${building.packageName})`, building.log);
    }
    return building;
  }
  /** Start to parse all the data from the XML we need for the typescript generation */
  parse() {
    this.log.debug(`Parsing ${this.dependency.packageName}...`);
    const girXML = this.dependency.girXML;
    const ns = girXML?.repository[0]?.namespace?.[0];
    const options2 = {
      loadDocs: !this.config.noComments,
      propertyCase: "both",
      verbose: this.config.verbose,
      reporter: this.config.reporter,
      reporterOutput: this.config.reporterOutput
    };
    if (!girXML) {
      throw new Error(`Failed to load gir xml of ${this.dependency.packageName}`);
    }
    if (!ns) {
      const packageName = girXML.repository[0].package?.[0]?.$.name || "unknown package";
      throw new Error(`Missing namespace in ${packageName}`);
    }
    const importConflicts = (el) => {
      return !this.hasImport(el.name);
    };
    if (ns.enumeration) {
      const enumerations = ns.enumeration?.map((enumeration) => {
        if (enumeration.$["glib:error-domain"]) {
          return IntrospectedError.fromXML(enumeration, this, options2);
        } else {
          return IntrospectedEnum.fromXML(enumeration, this, options2);
        }
      }).filter(importConflicts);
      for (const c of enumerations) {
        this.members.set(c.name, c);
      }
    }
    if (ns.constant) {
      const constants2 = ns.constant?.filter(isIntrospectable).map((constant) => IntrospectedConstant.fromXML(constant, this, options2)).filter(importConflicts);
      for (const c of constants2) {
        this.members.set(c.name, c);
      }
    }
    if (ns.function) {
      const functions = ns.function?.filter(isIntrospectable).map((func) => IntrospectedFunction.fromXML(func, this, options2)).filter(importConflicts);
      for (const c of functions) {
        this.members.set(c.name, c);
      }
    }
    if (ns.callback) {
      const callbacks = ns.callback?.filter(isIntrospectable).map((callback) => IntrospectedCallback.fromXML(callback, this, options2)).filter(importConflicts);
      for (const c of callbacks) {
        this.members.set(c.name, c);
      }
    }
    if (ns["glib:boxed"]) {
      const boxed = ns["glib:boxed"]?.filter(isIntrospectable).map(
        (boxed2) => new IntrospectedAlias({
          name: boxed2.$["glib:name"],
          namespace: this,
          type: new NullableType(ObjectType)
        })
      );
      for (const c of boxed) {
        this.members.set(c.name, c);
      }
    }
    if (ns.bitfield) {
      const bitfields = ns.bitfield?.filter(isIntrospectable).map((field) => IntrospectedEnum.fromXML(field, this, options2, true));
      for (const c of bitfields) {
        this.members.set(c.name, c);
      }
    }
    Array.from(this.members.values()).filter((m) => m instanceof IntrospectedEnum).forEach((m) => {
      m.members.forEach((member) => {
        this.enum_constants.set(member.c_identifier, [m.name, member.name]);
      });
    });
    if (ns.class) {
      const classes = ns.class?.filter(isIntrospectable).map((klass) => IntrospectedClass.fromXML(klass, this, options2)).filter(importConflicts);
      for (const c of classes) {
        this.members.set(c.name, c);
      }
    }
    if (ns.record) {
      const records = ns.record?.filter(isIntrospectable).map((record) => IntrospectedRecord.fromXML(record, this, options2)).filter(importConflicts);
      for (const c of records) {
        this.members.set(c.name, c);
      }
    }
    if (ns.union) {
      const unions = ns.union?.filter(isIntrospectable).map((union2) => IntrospectedRecord.fromXML(union2, this, options2)).filter(importConflicts);
      for (const c of unions) {
        this.members.set(c.name, c);
      }
    }
    if (ns.interface) {
      const interfaces = ns.interface?.map((inter) => IntrospectedInterface.fromXML(inter, this, options2)).filter(importConflicts);
      for (const c of interfaces) {
        this.members.set(c.name, c);
      }
    }
    if (ns.alias) {
      const aliases = ns.alias?.filter(isIntrospectable).map((b) => {
        b.type = b.type?.filter((t) => !!t?.$.name).map((t) => {
          if (t.$.name && !this.hasSymbol(t.$.name) && !isPrimitiveType(t.$.name) && !t.$.name.includes(".")) {
            return { $: { name: "unknown", "c:type": "unknown" } };
          }
          return t;
        });
        return b;
      }).map((alias) => IntrospectedAlias.fromXML(alias, this, options2)).filter((alias) => alias != null);
      for (const c of aliases) {
        this.members.set(c.name, c);
      }
    }
  }
};

// ../lib/src/gir/namespace.ts
function promisifyNamespaceFunctions(namespace) {
  return namespace.members.forEach((node) => {
    if (!(node instanceof IntrospectedFunction)) return;
    if (node.parameters.length < 1) return;
    const last_param = node.parameters[node.parameters.length - 1];
    if (!last_param) return;
    const last_param_unwrapped = last_param.type.unwrap();
    if (!(last_param_unwrapped instanceof ClosureType)) return;
    const internal = last_param_unwrapped.type;
    if (internal instanceof TypeIdentifier && internal.is("Gio", "AsyncReadyCallback")) {
      const async_res = [
        ...Array.from(namespace.members.values()).filter(
          (m) => m instanceof IntrospectedFunction
        )
      ].find((m) => m.name === `${node.name.replace(/_async$/, "")}_finish` || m.name === `${node.name}_finish`);
      if (async_res) {
        const async_parameters = node.parameters.slice(0, -1).map((p) => p.copy());
        const sync_parameters = node.parameters.map((p) => p.copy({ isOptional: false }));
        const output_parameters = async_res.output_parameters;
        let async_return = new PromiseType(async_res.return());
        if (output_parameters.length > 0) {
          const raw_return = async_res.return();
          if (raw_return.equals(VoidType) || raw_return.equals(BooleanType)) {
            const [output_type, ...output_types] = output_parameters.map((op) => op.type);
            async_return = new PromiseType(new TupleType(output_type, ...output_types));
          } else {
            const [...output_types] = output_parameters.map((op) => op.type);
            async_return = new PromiseType(new TupleType(raw_return, ...output_types));
          }
        }
        namespace.members.set(node.name, [
          node.copy({
            parameters: async_parameters,
            return_type: async_return
          }),
          node.copy({
            parameters: sync_parameters
          }),
          node.copy({
            return_type: new BinaryType(async_return, node.return())
          })
        ]);
      }
    }
  });
}

// ../lib/src/gir/promisify.ts
function generatePromisifyOverloadedSignatures(node, async_parameters, sync_parameters, async_return) {
  const promiseOverload = node.copy({
    parameters: async_parameters,
    returnType: async_return
  });
  const callbackOverload = node.copy({
    parameters: sync_parameters,
    returnType: VoidType
  });
  const unionOverload = node.copy({
    parameters: [...async_parameters, sync_parameters[sync_parameters.length - 1].copy({ isOptional: true })],
    returnType: new BinaryType(async_return, VoidType)
  });
  return [promiseOverload, callbackOverload, unionOverload];
}
function findFinishMethodInClass(cls, node) {
  const members = node instanceof IntrospectedStaticClassFunction ? [...cls.constructors, ...cls.members.filter((m) => m instanceof IntrospectedStaticClassFunction)] : [...cls.members.filter((m) => !(m instanceof IntrospectedStaticClassFunction))];
  return members.find(
    (m) => m.name === `${node.name.replace(/_async$/, "")}_finish` || m.name === `${node.name}_finish`
  );
}
function findFinishMethod(node, parent, interfaceParent) {
  let async_res = findFinishMethodInClass(parent, node);
  if (!async_res && interfaceParent) {
    async_res = findFinishMethodInClass(interfaceParent, node);
  }
  if (!async_res) {
    async_res = parent.findParentMap((parentClass) => findFinishMethodInClass(parentClass, node));
  }
  return async_res;
}
function createAsyncReturn(async_res) {
  const output_parameters = async_res instanceof IntrospectedConstructor ? [] : async_res.output_parameters;
  const return_type = async_res.return();
  if (output_parameters.length > 0) {
    if (output_parameters.length === 1 && (return_type.equals(VoidType) || return_type.equals(BooleanType))) {
      return new PromiseType(output_parameters[0].type);
    }
    if (return_type.equals(BooleanType) && output_parameters.length > 0) {
      const [firstParam, ...restParams] = output_parameters;
      return new PromiseType(new TupleType(firstParam.type, ...restParams.map((p) => p.type)));
    }
    return new PromiseType(new TupleType(return_type, ...output_parameters.map((p) => p.type)));
  }
  return new PromiseType(return_type);
}
function isAsyncReadyCallback(param) {
  const unwrapped = param.type.unwrap();
  return unwrapped instanceof ClosureType && unwrapped.type instanceof TypeIdentifier && unwrapped.type.is("Gio", "AsyncReadyCallback");
}
function isPromisifiable(node) {
  if (node instanceof IntrospectedVirtualClassFunction) return false;
  if (node.parameters.length === 0) return false;
  const last_param = node.parameters[node.parameters.length - 1];
  if (!last_param || !isAsyncReadyCallback(last_param)) return false;
  const parent = node.parent;
  if (!(parent instanceof IntrospectedBaseClass)) return false;
  const async_res = findFinishMethod(
    node,
    parent,
    node.interfaceParent instanceof IntrospectedInterface ? node.interfaceParent : void 0
  );
  return async_res !== void 0;
}
function promisifyFunctions(functions) {
  return functions.flatMap((node) => {
    if (!isPromisifiable(node)) return node;
    const parent = node.parent;
    const async_res = findFinishMethod(
      node,
      parent,
      node.interfaceParent instanceof IntrospectedInterface ? node.interfaceParent : void 0
    );
    if (!async_res) return node;
    const async_parameters = node.parameters.slice(0, -1).map((p) => p.copy({ parent: node }));
    const sync_parameters = node.parameters.map((p) => p.copy({ isOptional: false }));
    const async_return = createAsyncReturn(async_res);
    return generatePromisifyOverloadedSignatures(node, async_parameters, sync_parameters, async_return);
  });
}

// ../lib/src/generics/clutter.ts
function createClutterTemplate(version) {
  return {
    namespace: "Clutter",
    version,
    modifier: (namespace, inferGenerics) => {
      if (!inferGenerics) {
        return;
      }
      applyClutterGenerics(namespace);
    }
  };
}
function applyClutterGenerics(namespace) {
  const Actor = namespace.assertClass("Actor");
  const Content = namespace.assertClass("Content");
  const LayoutManager = namespace.assertClass("LayoutManager");
  Actor.addGeneric({
    default: LayoutManager.getType(),
    constraint: LayoutManager.getType()
  });
  Actor.addGeneric({
    default: Content.getType(),
    constraint: Content.getType()
  });
  updatePropertyType(Actor, ["layout_manager", "layoutManager"], new GenericType("A", Content.getType()));
  updatePropertyType(Actor, ["content"], new GenericType("B", Content.getType()));
  const Clone = namespace.assertClass("Clone");
  Clone.addGeneric({
    default: Actor.getType(),
    constraint: Actor.getType()
  });
  updatePropertyType(Clone, ["source"], new GenericType("A", Content.getType()));
}
function updatePropertyType(cls, propertyNames, newType) {
  cls.props.filter((p) => propertyNames.includes(p.name)).forEach((prop) => {
    prop.type = newType;
  });
}
var clutter10 = createClutterTemplate("10");
var clutter11 = createClutterTemplate("11");
var clutter12 = createClutterTemplate("12");
var clutter13 = createClutterTemplate("13");
var clutter14 = createClutterTemplate("14");
var clutter15 = createClutterTemplate("15");
var clutter16 = createClutterTemplate("16");

// ../lib/src/generics/gio.ts
function createGioConfig() {
  return {
    namespace: "Gio",
    version: "2.0",
    modifier: (namespace) => {
      applyGioGenerics(namespace);
    }
  };
}
function applyGioGenerics(namespace) {
  const GObject = namespace.assertInstalledImport("GObject").assertClass("Object");
  setupAsyncInitable(namespace, GObject);
  setupListModel(namespace, GObject);
  setupListStore(namespace, GObject);
  setupSettingsValueMethods(namespace);
}
function setupAsyncInitable(namespace, GObject) {
  const AsyncInitable = namespace.getClass("AsyncInitable");
  if (!AsyncInitable) {
    throw new Error("Gio.AsyncInitable not found.");
  }
  AsyncInitable.addGeneric({
    constraint: GObject.getType(),
    default: GObject.getType(),
    propagate: false
  });
}
function setupListModel(namespace, GObject) {
  const ListModel = namespace.getClass("ListModel");
  if (!ListModel) {
    throw new Error("Gio.ListModel not found.");
  }
  ListModel.addGeneric({
    default: GObject.getType(),
    constraint: GObject.getType()
  });
}
function setupListStore(namespace, GObject) {
  const ListModel = namespace.getClass("ListModel");
  const ListStore = namespace.getClass("ListStore");
  if (!ListStore) {
    throw new Error("Gio.ListStore not found.");
  }
  ListStore.addGeneric({
    deriveFrom: ListModel?.getType(),
    default: GObject.getType(),
    constraint: GObject.getType()
  });
}
function setupSettingsValueMethods(namespace) {
  const Settings = namespace.assertClass("Settings");
  const methodNames = ["get_value", "get_default_value", "get_user_value"];
  Settings.members = Settings.members.map((member) => {
    if (!methodNames.includes(member.name)) {
      return member;
    }
    return updateSettingsMethod(member);
  });
}
function updateSettingsMethod(method) {
  method.generics.push(new Generic(new GenericType("T"), AnyType, void 0, StringType));
  const returnType = method.return().deepUnwrap();
  if (returnType instanceof TypeIdentifier && returnType.is("GLib", "Variant")) {
    return method.copy({
      returnType: method.return().rewrap(new GenerifiedTypeIdentifier("Variant", "GLib", [new GenericType("T")]))
    });
  }
  return method;
}
var gio_default = createGioConfig();

// ../lib/src/generics/glib.ts
function createGlibConfig() {
  return {
    namespace: "GLib",
    version: "2.0",
    modifier: (namespace) => {
      applyGlibGenerics(namespace);
    }
  };
}
function applyGlibGenerics(namespace) {
  const HashTable = namespace.getClass("HashTable");
  if (!HashTable) {
    throw new Error("GLib.HashTable not found.");
  }
  HashTable.addGeneric({
    default: StringType
  });
  HashTable.addGeneric({
    default: AnyType
  });
}
var glib_default = createGlibConfig();

// ../lib/src/generics/gtk.ts
function createGtkConfig() {
  return {
    namespace: "Gtk",
    version: "4.0",
    modifier: (namespace) => {
      applyGtkGenerics(namespace);
    }
  };
}
function applyGtkGenerics(namespace) {
  const classes = getGtkClasses(namespace);
  const GObject = namespace.assertInstalledImport("GObject").assertClass("Object");
  setupStringListGenerics(classes, GObject);
  updateBindModelMethods(classes, GObject);
}
function getGtkClasses(namespace) {
  const requiredClasses = {
    FlowBox: namespace.getClass("FlowBox"),
    ListBox: namespace.getClass("ListBox"),
    StringList: namespace.getClass("StringList"),
    StringObject: namespace.getClass("StringObject")
  };
  for (const [name, cls] of Object.entries(requiredClasses)) {
    if (!cls) {
      throw new Error(`Gtk.${name} not found.`);
    }
  }
  return requiredClasses;
}
function setupStringListGenerics(classes, GObject) {
  const { StringList, StringObject } = classes;
  StringList.addGeneric({
    default: StringObject.getType(),
    constraint: GObject.getType()
  });
}
function updateBindModelMethods(classes, GObject) {
  const { FlowBox, ListBox } = classes;
  const bindModelConfigs = [
    { cls: FlowBox, widgetFuncName: "FlowBoxCreateWidgetFunc" },
    { cls: ListBox, widgetFuncName: "ListBoxCreateWidgetFunc" }
  ];
  for (const config of bindModelConfigs) {
    updateBindModelMethod(config.cls, config.widgetFuncName, GObject);
  }
}
function updateBindModelMethod(cls, widgetFuncName, GObject) {
  cls.members = cls.members.map((member) => {
    if (member.name !== "bind_model") {
      return member;
    }
    member.generics.push(new Generic(new GenericType("A"), GObject.getType(), void 0, GObject.getType()));
    return member.copy({
      parameters: member.parameters.map((param) => {
        if (param.name === "model") {
          return param.copy({
            type: new GenerifiedTypeIdentifier("ListModel", "Gio", [new GenericType("A")])
          });
        }
        if (param.name === "create_widget_func") {
          return param.copy({
            type: new GenerifiedTypeIdentifier(widgetFuncName, "Gtk", [new GenericType("A")])
          });
        }
        return param;
      })
    });
  });
}
var gtk_default = createGtkConfig();

// ../lib/src/generics/meta.ts
function createMetaTemplate(version) {
  return {
    namespace: "Meta",
    version,
    modifier: (namespace, inferGenerics) => {
      if (!inferGenerics) {
        return;
      }
      applyMetaGenerics(namespace);
    }
  };
}
function applyMetaGenerics(namespace) {
  const LayoutManager = namespace.assertInstalledImport("Clutter").assertClass("LayoutManager");
  const BackgroundContent = namespace.assertClass("BackgroundContent");
  const BackgroundActor = namespace.assertClass("BackgroundActor");
  const parent = BackgroundActor.superType;
  if (parent) {
    BackgroundActor.superType = new GenerifiedTypeIdentifier(parent.name, parent.namespace, [
      LayoutManager.getType(),
      BackgroundContent.getType()
    ]);
  }
}
var meta10 = createMetaTemplate("10");
var meta11 = createMetaTemplate("11");
var meta12 = createMetaTemplate("12");
var meta13 = createMetaTemplate("13");
var meta14 = createMetaTemplate("14");
var meta15 = createMetaTemplate("15");
var meta16 = createMetaTemplate("16");

// ../lib/src/generics/st.ts
function createStTemplate(version) {
  return {
    namespace: "St",
    version,
    modifier: (namespace, inferGenerics) => {
      if (!inferGenerics) {
        return;
      }
      applyStGenerics(namespace, version);
    }
  };
}
function applyStGenerics(namespace, version) {
  const clutterImport = namespace.assertInstalledImport("Clutter");
  const classes = getStClasses(namespace);
  const clutterClasses = getClutterClasses(clutterImport, version);
  setupWidgetGenerics(classes, clutterClasses);
  setupViewportGenerics(classes, clutterClasses);
  setupContainerGenerics(classes, clutterClasses, version);
  setupBoxLayout(classes, clutterClasses);
  setupBinGenerics(classes, clutterClasses);
  setupScrollViewMethods(classes);
}
function getStClasses(namespace) {
  return {
    Bin: namespace.assertClass("Bin"),
    Button: namespace.assertClass("Button"),
    ScrollView: namespace.assertClass("ScrollView"),
    ScrollBar: namespace.assertClass("ScrollBar"),
    Widget: namespace.assertClass("Widget"),
    Viewport: namespace.assertClass("Viewport"),
    StBoxLayout: namespace.assertClass("BoxLayout")
  };
}
function getClutterClasses(clutterImport, version) {
  return {
    Actor: clutterImport.assertClass("Actor"),
    Content: clutterImport.assertClass("Content"),
    Container: Number(version) < 14 ? clutterImport.assertClass("Container") : null,
    LayoutManager: clutterImport.assertClass("LayoutManager"),
    ClutterBoxLayout: clutterImport.assertClass("BoxLayout")
  };
}
function setupWidgetGenerics(stClasses, clutterClasses) {
  const { Widget } = stClasses;
  const { Actor, Content, LayoutManager } = clutterClasses;
  Widget.addGeneric({
    deriveFrom: Actor.getType(),
    default: LayoutManager.getType(),
    constraint: LayoutManager.getType()
  });
  Widget.addGeneric({
    deriveFrom: Actor.getType(),
    default: Content.getType(),
    constraint: Content.getType()
  });
}
function setupViewportGenerics(stClasses, clutterClasses) {
  const { Viewport, Widget } = stClasses;
  const { Content, LayoutManager } = clutterClasses;
  Viewport.addGeneric({
    deriveFrom: Widget.getType(),
    default: LayoutManager.getType(),
    constraint: LayoutManager.getType()
  });
  Viewport.addGeneric({
    deriveFrom: Widget.getType(),
    default: Content.getType(),
    constraint: Content.getType()
  });
}
function setupContainerGenerics(stClasses, clutterClasses, _version) {
  const { StBoxLayout } = stClasses;
  const { Actor, Container } = clutterClasses;
  if (!Container) {
    return;
  }
  Container.addGeneric({
    default: Actor.getType(),
    constraint: Actor.getType()
  });
  StBoxLayout.addGeneric({
    deriveFrom: Container.getType(),
    default: Actor.getType(),
    constraint: Actor.getType()
  });
}
function setupBoxLayout(stClasses, clutterClasses) {
  const { StBoxLayout } = stClasses;
  const { ClutterBoxLayout } = clutterClasses;
  if (StBoxLayout.superType) {
    StBoxLayout.superType = new GenerifiedTypeIdentifier(StBoxLayout.superType.name, StBoxLayout.superType.namespace, [
      ClutterBoxLayout.getType()
    ]);
  }
}
function setupBinGenerics(stClasses, clutterClasses) {
  const { Bin, Button, ScrollView } = stClasses;
  const { Actor } = clutterClasses;
  Bin.addGeneric({
    default: Actor.getType(),
    constraint: Actor.getType()
  });
  Button.addGeneric({
    deriveFrom: Bin.getType(),
    default: Actor.getType(),
    constraint: Actor.getType()
  });
  ScrollView.addGeneric({
    deriveFrom: Bin.getType(),
    default: Actor.getType(),
    constraint: Actor.getType()
  });
  updatePropertyType2(Bin, ["child"], new GenericType("A", Actor.getType()));
}
function setupScrollViewMethods(stClasses) {
  const { ScrollView, ScrollBar } = stClasses;
  const methodConfigs = [
    { name: "get_hscroll_bar", returnType: ScrollBar.getType() },
    { name: "get_vscroll_bar", returnType: ScrollBar.getType() }
  ];
  for (const config of methodConfigs) {
    const method = ScrollView.members.find((member) => member.name === config.name);
    if (method) {
      const fixedMethod = method.copy({ returnType: config.returnType });
      const index = ScrollView.members.indexOf(method);
      ScrollView.members.splice(index, 1, fixedMethod);
    }
  }
}
function updatePropertyType2(cls, propertyNames, newType) {
  cls.props.filter((p) => propertyNames.includes(p.name)).forEach((prop) => {
    prop.type = newType;
  });
}
var st1 = createStTemplate("1.0");
var st12 = createStTemplate("12");
var st13 = createStTemplate("13");
var st14 = createStTemplate("14");
var st15 = createStTemplate("15");
var st16 = createStTemplate("16");

// ../lib/src/visitor.ts
var GirVisitor = class {
  visitType;
  visitCallback;
  visitClassCallback;
  visitAlias;
  visitConstructor;
  visitDirectAllocationConstructor;
  visitConstructorFunction;
  visitRecord;
  visitInterface;
  visitEnumMember;
  visitError;
  visitEnum;
  visitConst;
  visitClass;
  visitParameter;
  visitProperty;
  visitField;
  visitSignal;
  visitFunction;
  visitClassFunction;
  visitStaticClassFunction;
  visitVirtualClassFunction;
  visitNamespace;
};

// ../lib/src/generics/visitor.ts
var GenericVisitor = class extends GirVisitor {
  inferGenerics;
  constructor(inferGenerics) {
    super();
    this.inferGenerics = inferGenerics;
  }
  visitCallback = (node) => {
    if (!this.inferGenerics) {
      return node;
    }
    const shouldGenerify = this.shouldGenerifyCallback(node);
    if (!shouldGenerify) {
      return node;
    }
    return this.createGenerifiedCallback(node);
  };
  visitClass = (node) => {
    return this.visitBaseClass(node);
  };
  visitInterface = (node) => {
    return this.visitBaseClass(node);
  };
  visitParameter = (node) => {
    if (!this.inferGenerics) {
      return node;
    }
    const unwrapped = node.type.unwrap();
    if (!(unwrapped instanceof ClosureType)) {
      return node;
    }
    return this.processAsyncReadyCallback(node) ?? node;
  };
  visitFunction = (node) => {
    if (!this.inferGenerics) {
      return node;
    }
    const unwrapped = node.return_type.unwrap();
    const shouldGenerify = unwrapped instanceof TypeIdentifier && unwrapped.is("GObject", "Object");
    if (!shouldGenerify) {
      return node;
    }
    return this.createGenerifiedFunction(node, unwrapped);
  };
  visitStaticClassFunction = (node) => {
    if (this.inferGenerics) {
      return this.generifyStandaloneClassFunction(node);
    }
    return node;
  };
  visitClassFunction = (node) => {
    if (node.parent instanceof IntrospectedBaseClass) {
      const processedNode = this.processClassFunctionWithGenerics(node);
      if (processedNode) {
        return processedNode;
      }
    }
    if (this.inferGenerics) {
      return this.generifyStandaloneClassFunction(node);
    }
    return node;
  };
  visitVirtualClassFunction = (node) => {
    return this.visitClassFunction(node);
  };
  // Private helper methods
  visitBaseClass(node) {
    const copiedNode = node.copy();
    const derivatives = copiedNode.generics.filter((generic) => generic.parent != null);
    this.processInterfaces(copiedNode, derivatives);
    this.processSuperType(copiedNode, derivatives);
    return copiedNode;
  }
  shouldGenerifyCallback(node) {
    return node.parameters.some((parameter) => this.isGObjectType(parameter.type.unwrap()));
  }
  isGObjectType(type) {
    return type instanceof TypeIdentifier && type.is("GObject", "Object");
  }
  createGenerifiedCallback(node) {
    const generateName = createGenericNameGenerator();
    const generics = [];
    const generifiedParameters = node.parameters.map((parameter) => {
      const type = parameter.type.unwrap();
      if (this.isGObjectType(type)) {
        const { identifier, generic } = this.createGeneric(generateName(), type);
        generics.push(generic);
        return parameter.copy({
          type: parameter.type.rewrap(identifier)
        });
      }
      return parameter;
    });
    const generifiedCallback = node.copy({
      parameters: generifiedParameters
    });
    generifiedCallback.generics = generics;
    return generifiedCallback;
  }
  createGeneric(identifier, baseType) {
    const genericType = new GenericType(identifier, baseType);
    const generic = new Generic(genericType, baseType);
    return { identifier: genericType, generic };
  }
  processInterfaces(node, derivatives) {
    if (!(node instanceof IntrospectedClass)) {
      return;
    }
    const resolvedInterfaces = this.resolveInterfaces(node);
    node.interfaces = node.interfaces.map(
      (iface) => this.processInterface(node, iface, derivatives, resolvedInterfaces)
    );
  }
  resolveInterfaces(node) {
    return node.interfaces.map((i) => resolveTypeIdentifier(node.namespace, i)).filter((c) => c != null);
  }
  processInterface(node, iface, derivatives, resolvedInterfaces) {
    const matchingGenerics = derivatives.filter((d) => d.parent?.is(iface.namespace, iface.name));
    if (matchingGenerics.length > 0) {
      return new GenerifiedTypeIdentifier(
        iface.name,
        iface.namespace,
        matchingGenerics.map((g) => g.type)
      );
    }
    const resolved = resolvedInterfaces.find((i) => i.getType().equals(iface));
    if (resolved) {
      return this.processResolvedInterface(node, iface, resolved);
    }
    return iface;
  }
  processResolvedInterface(node, iface, resolved) {
    if (resolved.generics.length !== 1) {
      return iface;
    }
    const [generic] = resolved.generics;
    if (generic.propagate) {
      return this.handlePropagatingInterfaceGeneric(node, iface, resolved, generic);
    }
    return new GenerifiedTypeIdentifier(iface.name, iface.namespace, [node.getType()]);
  }
  handlePropagatingInterfaceGeneric(node, iface, resolved, generic) {
    const constrainedGeneric = this.findConstrainedGeneric(node, generic);
    if (constrainedGeneric) {
      return new GenerifiedTypeIdentifier(iface.name, iface.namespace, [constrainedGeneric.type]);
    }
    if (this.shouldAddNewGeneric(node, generic)) {
      this.addGenericToNode(node, resolved, generic);
      const firstGeneric = node.generics[node.generics.length - 1];
      return new GenerifiedTypeIdentifier(resolved.name, resolved.namespace.namespace, [firstGeneric.type]);
    }
    return new GenerifiedTypeIdentifier(iface.name, iface.namespace, [node.getType()]);
  }
  findConstrainedGeneric(node, generic) {
    return node.generics.find((d) => generic.constraint && d.constraint?.equals(generic.constraint));
  }
  shouldAddNewGeneric(node, generic) {
    return !generic.defaultType?.equals(node.getType()) && !generic.constraint?.equals(node.getType());
  }
  addGenericToNode(node, resolved, generic) {
    node.addGeneric({
      constraint: generic.constraint ?? void 0,
      default: generic.defaultType ?? void 0,
      deriveFrom: resolved.getType()
    });
  }
  processSuperType(node, derivatives) {
    if (!node.superType) {
      return;
    }
    const parentType = node.superType;
    const matchingGenerics = derivatives.filter((d) => d.parent?.is(parentType.namespace, parentType.name));
    if (node.superType instanceof GenerifiedTypeIdentifier) {
      return;
    }
    if (matchingGenerics.length > 0) {
      node.superType = new GenerifiedTypeIdentifier(
        parentType.name,
        parentType.namespace,
        matchingGenerics.map((g) => g.type)
      );
      return;
    }
    const resolvedParent = resolveTypeIdentifier(node.namespace, node.superType);
    this.processResolvedParent(node, resolvedParent);
  }
  processResolvedParent(node, resolved) {
    if (!resolved || resolved.generics.length !== 1) {
      return;
    }
    const [generic] = resolved.generics;
    if (generic.propagate) {
      this.handlePropagatingGeneric(node, resolved, generic);
    } else if (this.shouldUseNodeType(node, generic)) {
      node.superType = new GenerifiedTypeIdentifier(resolved.name, resolved.namespace.namespace, [node.getType()]);
    }
  }
  handlePropagatingGeneric(node, resolved, generic) {
    const constrainedGeneric = this.findConstrainedGeneric(node, generic);
    if (constrainedGeneric) {
      node.superType = new GenerifiedTypeIdentifier(resolved.name, resolved.namespace.namespace, [
        constrainedGeneric.type
      ]);
      return;
    }
    if (this.shouldAddNewGeneric(node, generic)) {
      this.addGenericToNode(node, resolved, generic);
      const firstGeneric = node.generics[node.generics.length - 1];
      node.superType = new GenerifiedTypeIdentifier(resolved.name, resolved.namespace.namespace, [firstGeneric.type]);
    } else if (this.shouldUseNodeType(node, generic)) {
      node.superType = new GenerifiedTypeIdentifier(resolved.name, resolved.namespace.namespace, [node.getType()]);
    }
  }
  shouldUseNodeType(node, generic) {
    return [...node.resolveParents()].some((c) => generic.defaultType && c.identifier.equals(generic.defaultType));
  }
  processAsyncReadyCallback(node) {
    const unwrapped = node.type.unwrap();
    if (!(unwrapped instanceof ClosureType)) {
      return null;
    }
    const internal = unwrapped.type.unwrap();
    if (!(internal instanceof TypeIdentifier) || !internal.is("Gio", "AsyncReadyCallback")) {
      return null;
    }
    const member = node.parent;
    if (!member) {
      return null;
    }
    const generifiedType = this.createAsyncReadyCallbackType(member, internal);
    if (generifiedType) {
      return node.copy({
        type: node.type.rewrap(generifiedType)
      });
    }
    return null;
  }
  createAsyncReadyCallbackType(member, internal) {
    if (member instanceof IntrospectedFunction && member.parameters.length >= 2) {
      return new GenerifiedTypeIdentifier(internal.name, internal.namespace, [member.parameters[0].type]);
    }
    if (member instanceof IntrospectedStaticClassFunction) {
      return new GenerifiedTypeIdentifier(internal.name, internal.namespace, [member.parent.getType()]);
    }
    if (member instanceof IntrospectedClassFunction) {
      return new GenerifiedTypeIdentifier(internal.name, internal.namespace, [ThisType]);
    }
    return null;
  }
  createGenerifiedFunction(node, unwrapped) {
    const genericReturnType = new GenericType("T", unwrapped);
    const copied = node.copy({
      return_type: genericReturnType
    });
    copied.generics.push(new Generic(genericReturnType, unwrapped));
    return copied;
  }
  generifyStandaloneClassFunction(node) {
    if (this.shouldSkipFunctionGenerification(node)) {
      return node;
    }
    const unwrapped = node.return().unwrap();
    if (this.isGObjectType(unwrapped)) {
      const genericReturnType = new GenericType("T", unwrapped);
      const copied = node.copy({
        returnType: genericReturnType
      });
      copied.generics.push(new Generic(genericReturnType, unwrapped, unwrapped));
      return copied;
    }
    return node;
  }
  shouldSkipFunctionGenerification(node) {
    return node.parent.getType().is("GObject", "Object");
  }
  processClassFunctionWithGenerics(node) {
    const clazz = node.parent;
    if (clazz.generics.length === 0) {
      return null;
    }
    const returnType = this.processReturnTypeWithGenerics(node.return(), clazz.generics);
    return node.copy({
      parameters: this.processParametersWithGenerics(node.parameters, clazz.generics),
      outputParameters: this.processOutputParametersWithGenerics(node.output_parameters, clazz.generics),
      returnType
    });
  }
  processReturnTypeWithGenerics(returnType, generics) {
    for (const generic of generics) {
      if (generic.defaultType?.equals(returnType.deepUnwrap())) {
        return returnType.rewrap(generic.type);
      }
    }
    return returnType;
  }
  processParametersWithGenerics(parameters, generics) {
    return parameters.map((parameter) => this.processParameterWithGenerics(parameter, generics));
  }
  processParameterWithGenerics(parameter, generics) {
    for (const generic of generics) {
      if (generic.defaultType?.equals(parameter.type.deepUnwrap())) {
        return parameter.copy({
          type: parameter.type.rewrap(generic.type)
        });
      }
    }
    return parameter;
  }
  processOutputParametersWithGenerics(outputParameters, generics) {
    return outputParameters.map((parameter) => {
      for (const generic of generics) {
        if (generic.defaultType?.equals(parameter.type.unwrap())) {
          return parameter.copy({
            type: parameter.type.rewrap(generic.type)
          });
        }
      }
      return parameter;
    });
  }
};

// ../lib/src/generics/generify.ts
var CORE_DEFINITIONS = [gio_default, glib_default];
var OPTIONAL_DEFINITIONS = [
  gtk_default,
  clutter10,
  clutter11,
  clutter12,
  clutter13,
  clutter14,
  clutter15,
  st1,
  st12,
  st13,
  st14,
  st15,
  meta10,
  meta11,
  meta12,
  meta13,
  meta14,
  meta15
];
function createDefinitionProcessor(registry, inferGenerics, required = true) {
  return (definition) => {
    const { namespace: namespaceName, version, modifier } = definition;
    const namespace = registry.namespace(namespaceName, version);
    if (namespace) {
      modifier(namespace, inferGenerics);
      return;
    }
    if (required) {
      throw new Error(`Could not generify ${namespaceName} ${version}`);
    }
  };
}
function applyDefinitions(definitions, processor) {
  for (const definition of definitions) {
    processor(definition);
  }
}
function generify(registry, inferGenerics) {
  const processCoreDefinition = createDefinitionProcessor(registry, inferGenerics, true);
  const processOptionalDefinition = createDefinitionProcessor(registry, inferGenerics, false);
  applyDefinitions(CORE_DEFINITIONS, processCoreDefinition);
  applyDefinitions(OPTIONAL_DEFINITIONS, processOptionalDefinition);
  const visitor = new GenericVisitor(inferGenerics);
  registry.registerTransformation(visitor);
}

// ../lib/src/injections/gee1.ts
var gee1_default = {
  namespace: "Gee",
  version: "1.0",
  modifier(namespace) {
    const AbstractList = namespace.assertClass("AbstractList");
    const LinkedList = namespace.assertClass("LinkedList");
    if (AbstractList.props.some((prop) => prop.name === "readOnlyView"))
      LinkedList.props.push(
        new IntrospectedProperty({
          name: "readOnlyView",
          type: LinkedList.getType(),
          readable: true,
          writable: false,
          constructOnly: false,
          parent: LinkedList
        })
      );
    if (AbstractList.props.some((prop) => prop.name === "read_only_view"))
      LinkedList.props.push(
        new IntrospectedProperty({
          name: "read_only_view",
          type: LinkedList.getType(),
          readable: true,
          writable: false,
          constructOnly: false,
          parent: LinkedList
        })
      );
  }
};

// ../lib/src/injections/gee08.ts
var gee08_default = {
  namespace: "Gee",
  version: "0.8",
  modifier(namespace) {
    const SortedMap = namespace.assertClass("SortedMap");
    const AbstractSortedMap = namespace.assertClass("AbstractSortedMap");
    if (SortedMap.props.some((prop) => prop.name === "readOnlyView"))
      AbstractSortedMap.props.push(
        new IntrospectedProperty({
          name: "readOnlyView",
          type: AbstractSortedMap.getType(),
          readable: true,
          writable: false,
          constructOnly: false,
          parent: AbstractSortedMap
        })
      );
    if (SortedMap.props.some((prop) => prop.name === "read_only_view"))
      AbstractSortedMap.props.push(
        new IntrospectedProperty({
          name: "read_only_view",
          type: AbstractSortedMap.getType(),
          readable: true,
          writable: false,
          constructOnly: false,
          parent: AbstractSortedMap
        })
      );
    const AbstractList = namespace.assertClass("AbstractList");
    const LinkedList = namespace.assertClass("LinkedList");
    if (AbstractList.props.some((prop) => prop.name === "readOnlyView"))
      LinkedList.props.push(
        new IntrospectedProperty({
          name: "readOnlyView",
          type: LinkedList.getType(),
          readable: true,
          writable: false,
          constructOnly: false,
          parent: LinkedList
        })
      );
    if (AbstractList.props.some((prop) => prop.name === "read_only_view"))
      LinkedList.props.push(
        new IntrospectedProperty({
          name: "read_only_view",
          type: LinkedList.getType(),
          readable: true,
          writable: false,
          constructOnly: false,
          parent: LinkedList
        })
      );
    const AbstractBidirList = namespace.assertClass("AbstractBidirList");
    const UnrolledLinkedList = namespace.assertClass("UnrolledLinkedList");
    if (AbstractBidirList.props.some((prop) => prop.name === "readOnlyView"))
      UnrolledLinkedList.props.push(
        new IntrospectedProperty({
          name: "readOnlyView",
          type: UnrolledLinkedList.getType(),
          readable: true,
          writable: false,
          constructOnly: false,
          parent: UnrolledLinkedList
        })
      );
    if (AbstractBidirList.props.some((prop) => prop.name === "read_only_view"))
      UnrolledLinkedList.props.push(
        new IntrospectedProperty({
          name: "read_only_view",
          type: UnrolledLinkedList.getType(),
          readable: true,
          writable: false,
          constructOnly: false,
          parent: UnrolledLinkedList
        })
      );
  }
};

// ../lib/src/injections/gio.ts
var gio_default2 = {
  namespace: "Gio",
  version: "2.0",
  modifier(namespace) {
    namespace.___dts___addReference('/// <reference lib="es2015.iterable" />');
    namespace.___dts___addReference('/// <reference lib="es2018.asynciterable" />');
    {
      const DBusNodeInfo = namespace.assertClass("DBusNodeInfo");
      DBusNodeInfo.constructors.push(
        new IntrospectedConstructor({
          name: "new_for_xml",
          parent: DBusNodeInfo,
          parameters: [
            new IntrospectedFunctionParameter({
              name: "info",
              type: StringType,
              direction: "in" /* In */
            })
          ],
          return_type: DBusNodeInfo.getType()
        })
      );
    }
    {
      const DBusInterfaceInfo = namespace.assertClass("DBusInterfaceInfo");
      DBusInterfaceInfo.constructors.push(
        new IntrospectedConstructor({
          name: "new_for_xml",
          parent: DBusInterfaceInfo,
          parameters: [
            new IntrospectedFunctionParameter({
              name: "info",
              type: StringType,
              direction: "in" /* In */
            })
          ],
          return_type: DBusInterfaceInfo.getType()
        })
      );
    }
    {
      const ListStore = namespace.assertClass("ListStore");
      ListStore.fields.push(
        new IntrospectedField({
          name: "Symbol.iterator",
          parent: ListStore,
          computed: true,
          type: new FunctionType({}, new GenerifiedType(new NativeType("IterableIterator"), new GenericType("A")))
        })
      );
    }
    {
      const FileEnumerator = namespace.assertClass("FileEnumerator");
      FileEnumerator.fields.push(
        // Implementation of the override [Gio.FileEnumerator[Symbol.iterator](https://gjs-docs.gnome.org/gjs/overrides.md#gio-fileenumerator-symbol-iterator)
        new JSField({
          name: "Symbol.iterator",
          parent: FileEnumerator,
          computed: true,
          doc: 'Gio.FileEnumerator are sync iterators.\nEach iteration returns a Gio.FileInfo:\n\n```js\nimport Gio from "gi://Gio";\n\nconst dir = Gio.File.new_for_path("/");\nconst enumerator = dir.enumerate_children(\n  "standard::name",\n  Gio.FileQueryInfoFlags.NOFOLLOW_SYMLINKS,\n  null\n);\n\nfor (const file_info of enumerator) {\n  console.log(file_info.get_name());\n}\n```\n',
          type: new FunctionType(
            {},
            new GenerifiedType(new NativeType("IterableIterator"), new GenericType("FileInfo"))
          )
        }),
        // Implementation of the override [Gio.FileEnumerator[Symbol.asyncIterator]](https://gjs-docs.gnome.org/gjs/overrides.md#gio-fileenumerator-symbol-asynciterator)
        new JSField({
          name: "Symbol.asyncIterator",
          parent: FileEnumerator,
          computed: true,
          doc: 'Gio.FileEnumerator are async iterators.\nEach iteration returns a Gio.FileInfo:\n\n```js\nimport Gio from "gi://Gio";\n\nconst dir = Gio.File.new_for_path("/");\nconst enumerator = dir.enumerate_children(\n  "standard::name",\n  Gio.FileQueryInfoFlags.NOFOLLOW_SYMLINKS,\n  null\n);\n\nfor await (const file_info of enumerator) {\n  console.log(file_info.get_name());\n}\n```\n',
          type: new FunctionType(
            {},
            new GenerifiedType(new NativeType("AsyncIterableIterator"), new GenericType("FileInfo"))
          )
        })
      );
    }
    {
      const SettingsSchema = namespace.assertClass("SettingsSchema");
      SettingsSchema.fields.push(
        new JSField({
          name: "_realGetKey",
          parent: SettingsSchema,
          type: new NativeType("typeof SettingsSchema.prototype.get_key")
        })
      );
    }
    {
      const Settings = namespace.assertClass("Settings");
      Settings.fields.push(
        new JSField({
          name: "_realInit",
          parent: Settings,
          type: AnyFunctionType
        }),
        new JSField({
          name: "_realMethods",
          parent: Settings,
          type: new NativeType("typeof Settings.prototype")
        }),
        new JSField({
          name: "_keys",
          parent: Settings,
          type: new ArrayType(StringType)
        }),
        new JSField({
          name: "_children",
          parent: Settings,
          type: new ArrayType(StringType)
        })
      );
    }
    {
      const DBusProxy = namespace.assertClass("DBusProxy");
      DBusProxy.__ts__indexSignature = "[key: string]: any;";
      const makeProxyWrapper = new IntrospectedStaticClassFunction({
        name: "makeProxyWrapper",
        parent: DBusProxy,
        parameters: [
          new IntrospectedFunctionParameter({
            name: "args",
            type: new ArrayType(AnyType),
            isVarArgs: true,
            direction: "in" /* In */
          })
        ],
        return_type: new NativeType(
          "(bus: DBusConnection, name: string, object: string, asyncCallback?: (initable: (T & DBusProxy) | null, error: unknown | null) => void, cancellable?: Cancellable | null, flags?: DBusProxyFlags) => T & DBusProxy"
        )
      });
      makeProxyWrapper.generics.push(new Generic(new GenericType("T")));
      DBusProxy.members.push(
        makeProxyWrapper,
        new IntrospectedClassFunction({
          name: "connectSignal",
          parent: DBusProxy,
          parameters: [
            new IntrospectedFunctionParameter({
              name: "proxy",
              type: ThisType,
              direction: "in" /* In */
            }),
            new IntrospectedFunctionParameter({
              name: "name",
              type: StringType,
              direction: "in" /* In */
            }),
            new IntrospectedFunctionParameter({
              name: "args",
              type: new ArrayType(AnyType),
              direction: "in" /* In */
            })
          ],
          return_type: AnyType
        }),
        new IntrospectedClassFunction({
          name: "disconnectSignal",
          parent: DBusProxy,
          parameters: [
            new IntrospectedFunctionParameter({
              name: "args",
              type: new ArrayType(AnyType),
              isVarArgs: true,
              direction: "in" /* In */
            })
          ],
          return_type: AnyType
        })
      );
    }
    {
      const [bus_get] = namespace.getMembers("bus_get");
      const [bus_get_finish] = namespace.getMembers("bus_get_finish");
      const [bus_get_sync] = namespace.getMembers("bus_get_sync");
      const [bus_own_name] = namespace.getMembers("bus_own_name");
      const [bus_own_name_on_connection] = namespace.getMembers("bus_own_name_on_connection");
      const [bus_unown_name] = namespace.getMembers("bus_unown_name");
      const [bus_watch_name] = namespace.getMembers("bus_watch_name");
      const [bus_unwatch_name] = namespace.getMembers("bus_unwatch_name");
      const [bus_watch_name_on_connection] = namespace.getMembers("bus_watch_name_on_connection");
      if (!(bus_get instanceof IntrospectedFunction && bus_get_finish instanceof IntrospectedFunction && bus_get_sync instanceof IntrospectedFunction && bus_own_name instanceof IntrospectedFunction && bus_own_name_on_connection instanceof IntrospectedFunction && bus_unown_name instanceof IntrospectedFunction && bus_watch_name instanceof IntrospectedFunction && bus_unwatch_name instanceof IntrospectedFunction && bus_watch_name_on_connection instanceof IntrospectedFunction)) {
        throw new Error("Invalid dbus functions found in Gio!");
      }
      const DBus = new IntrospectedInterface({
        name: "DBus",
        namespace
      });
      DBus.members.push(
        ...[
          bus_get,
          bus_get_finish,
          bus_get_sync,
          bus_own_name,
          bus_own_name_on_connection,
          bus_unown_name,
          bus_watch_name,
          bus_unwatch_name,
          bus_watch_name_on_connection
        ].map((fn) => {
          const { raw_name: name, output_parameters, parameters, return_type, doc: doc2, isIntrospectable: isIntrospectable2 } = fn;
          return new IntrospectedStaticClassFunction({
            parent: DBus,
            name,
            output_parameters,
            parameters,
            return_type,
            doc: doc2,
            isIntrospectable: isIntrospectable2
          });
        }).map((fn) => {
          const member = fn.copy();
          member.name = member.name.substring(4);
          return member;
        })
      );
      const DBusConnection = namespace.assertClass("DBusConnection");
      const call = DBusConnection.members.find((m) => m.name === "call");
      const callFinish = DBusConnection.members.find((m) => m.name === "call_finish");
      if (!call || !callFinish) {
        throw new Error("Missing call or call_finish in Gio.DBusConnection.");
      }
      const call_generic = new Generic(new GenericType("T"), AnyType, void 0, StringType);
      call.generics.push(call_generic);
      callFinish.generics.push(call_generic);
      const replacement = call.copy({
        parameters: call.parameters.map((p) => {
          if (p.name === "reply_type") {
            return p.copy({
              type: p.type.rewrap(new GenerifiedTypeIdentifier("VariantType", "GLib", [new GenericType("T")]))
            });
          }
          return p;
        })
      });
      const finishReplacement = callFinish.copy({
        returnType: callFinish.return().rewrap(new GenerifiedTypeIdentifier("Variant", "GLib", [new GenericType("T")]))
      });
      DBusConnection.members.splice(DBusConnection.members.indexOf(call), 1, replacement);
      DBusConnection.members.splice(DBusConnection.members.indexOf(callFinish), 1, finishReplacement);
      DBusConnection.members.push(
        new IntrospectedClassFunction({
          name: "watch_name",
          parameters: bus_watch_name_on_connection.parameters.slice(1),
          return_type: bus_watch_name_on_connection.return_type,
          parent: DBusConnection
        }),
        new IntrospectedClassFunction({
          name: "unwatch_name",
          parameters: bus_unwatch_name.parameters.slice(),
          return_type: bus_unwatch_name.return_type,
          parent: DBusConnection
        }),
        new IntrospectedClassFunction({
          name: "own_name",
          parameters: bus_own_name_on_connection.parameters.slice(1),
          return_type: bus_own_name_on_connection.return_type,
          parent: DBusConnection
        }),
        new IntrospectedClassFunction({
          name: "unown_name",
          parameters: bus_unown_name.parameters.slice(),
          return_type: bus_unown_name.return_type,
          parent: DBusConnection
        })
      );
      DBus.fields.push(
        new JSField({
          isStatic: true,
          name: "session",
          parent: DBus,
          type: DBusConnection.getType(),
          writable: false
        }),
        new JSField({
          isStatic: true,
          name: "system",
          parent: DBus,
          type: DBusConnection.getType(),
          writable: false
        })
      );
      namespace.members.set("DBus", DBus);
    }
    {
      const Variant2 = namespace.assertInstalledImport("GLib").assertClass("Variant");
      const DBusConnection = namespace.assertClass("DBusConnection");
      const DBusInterfaceInfo = namespace.assertClass("DBusInterfaceInfo");
      const DBusExportedObject = new IntrospectedClass("DBusExportedObject", namespace);
      DBusExportedObject.members.push(
        new IntrospectedStaticClassFunction({
          name: "wrapJSObject",
          parent: DBusExportedObject,
          parameters: [
            new IntrospectedFunctionParameter({
              name: "info",
              type: StringType,
              direction: "in" /* In */
            }),
            new IntrospectedFunctionParameter({
              name: "obj",
              type: AnyType,
              direction: "in" /* In */
            })
          ],
          return_type: DBusExportedObject.getType()
        }),
        new IntrospectedClassFunction({
          name: "get_info",
          parent: DBusExportedObject,
          parameters: [],
          return_type: DBusInterfaceInfo.getType()
        }),
        new IntrospectedClassFunction({
          name: "get_connection",
          parent: DBusExportedObject,
          parameters: [],
          return_type: DBusConnection.getType()
        }),
        new IntrospectedClassFunction({
          name: "get_object_path",
          parent: DBusExportedObject,
          parameters: [],
          return_type: StringType
        }),
        new IntrospectedClassFunction({
          name: "unexport_from_connection",
          parent: DBusExportedObject,
          parameters: [
            new IntrospectedFunctionParameter({
              name: "connection",
              type: DBusConnection.getType(),
              direction: "in" /* In */
            })
          ],
          return_type: VoidType
        }),
        // export(busConnection, objectPath)
        new IntrospectedClassFunction({
          name: "export",
          parent: DBusExportedObject,
          parameters: [
            new IntrospectedFunctionParameter({
              name: "busConnection",
              type: DBusConnection.getType(),
              direction: "in" /* In */
            }),
            new IntrospectedFunctionParameter({
              name: "objectPath",
              type: StringType,
              direction: "in" /* In */
            })
          ],
          return_type: VoidType
        }),
        // unexport()
        new IntrospectedClassFunction({
          name: "unexport",
          parent: DBusExportedObject,
          return_type: VoidType
        }),
        // flush()
        new IntrospectedClassFunction({
          name: "flush",
          parent: DBusExportedObject,
          return_type: VoidType
        }),
        // emit_signal(name, variant)
        new IntrospectedClassFunction({
          name: "emit_signal",
          parent: DBusExportedObject,
          parameters: [
            new IntrospectedFunctionParameter({
              name: "name",
              type: StringType,
              direction: "in" /* In */
            }),
            new IntrospectedFunctionParameter({
              name: "variant",
              type: Variant2.getType(),
              direction: "in" /* In */
            })
          ],
          return_type: VoidType
        }),
        // emit_property_changed(name, variant)
        new IntrospectedClassFunction({
          name: "emit_property_changed",
          parent: DBusExportedObject,
          parameters: [
            new IntrospectedFunctionParameter({
              name: "name",
              type: StringType,
              direction: "in" /* In */
            }),
            new IntrospectedFunctionParameter({
              name: "variant",
              type: Variant2.getType(),
              direction: "in" /* In */
            })
          ],
          return_type: VoidType
        })
      );
      namespace.members.set("DBusExportedObject", DBusExportedObject);
    }
    {
      const Application = namespace.assertClass("Application");
      Application.members.push(
        new IntrospectedClassFunction({
          parent: Application,
          name: "runAsync",
          parameters: [
            new IntrospectedFunctionParameter({
              direction: "in" /* In */,
              name: "argv",
              isOptional: true,
              type: new ArrayType(StringType),
              doc: "Commandline arguments"
            })
          ],
          return_type: new NativeType("Promise<number>"),
          doc: "Similar to `Gio.Application.run` but return a Promise which resolves when the main loop ends, instead of blocking while the main loop runs.\nThis helps avoid the situation where Promises never resolved if you didn't run the application inside a callback."
        })
      );
    }
    {
      const File = namespace.assertClass("File");
      const Flags = namespace.getEnum("FileCreateFlags");
      if (!Flags) throw new Error("Missing FileCreateFlags");
      File.members.push(
        new IntrospectedClassFunction({
          parent: File,
          name: "replace_contents_async",
          return_type: VoidType,
          // contents: Uint8Array, etag: string | null, make_backup: boolean, flags: FileCreateFlags, cancellable: Cancellable | null, callback: AsyncReadyCallback | null
          parameters: [
            new IntrospectedFunctionParameter({
              direction: "in" /* In */,
              name: "contents",
              type: Uint8ArrayType
            }),
            new IntrospectedFunctionParameter({
              direction: "in" /* In */,
              name: "etag",
              isNullable: true,
              type: StringType
            }),
            new IntrospectedFunctionParameter({
              direction: "in" /* In */,
              name: "make_backup",
              type: BooleanType
            }),
            new IntrospectedFunctionParameter({
              direction: "in" /* In */,
              name: "flags",
              type: Flags.getType()
            }),
            new IntrospectedFunctionParameter({
              direction: "in" /* In */,
              name: "cancellable",
              isNullable: true,
              type: namespace.assertClass("Cancellable").getType()
            }),
            new IntrospectedFunctionParameter({
              direction: "in" /* In */,
              name: "callback",
              isNullable: true,
              type: new TypeIdentifier("AsyncReadyCallback", "Gio")
            })
          ]
        })
      );
    }
    {
      const InputStream = namespace.assertClass("InputStream");
      const Bytes = namespace.assertInstalledImport("GLib").assertClass("Bytes");
      InputStream.members.push(
        // Implementation of the override [Gio.InputStream.prototype.createAsyncIterator](https://gjs-docs.gnome.org/gjs/overrides.md#gio-inputstream-createasynciterator)
        new IntrospectedClassFunction({
          name: "createAsyncIterator",
          parent: InputStream,
          doc: 'Creates an asynchronous iterator for a Gio.InputStream that reads the stream in chunks.\n\nEach iteration will return a GLib.Bytes object containing at most `count` bytes (default 4096). The iterator will end when the stream is exhausted.\n\nExample:\n```js\nimport Gio from "gi://Gio";\n\nconst textDecoder = new TextDecoder("utf-8");\n\nconst file = Gio.File.new_for_path("/etc/os-release");\nconst inputStream = file.read(null);\n\nfor await (const bytes of inputStream.createAsyncIterator(4)) {\n  log(textDecoder.decode(bytes.toArray()));\n}\n```\n\n@returns An async iterator yielding GLib.Bytes objects',
          parameters: [
            new IntrospectedFunctionParameter({
              name: "count",
              type: new NativeType("number"),
              isOptional: true,
              direction: "in" /* In */,
              doc: "Maximum number of bytes to read per chunk (default: 4096)"
            }),
            new IntrospectedFunctionParameter({
              name: "priority",
              type: new NativeType("number"),
              isOptional: true,
              direction: "in" /* In */,
              doc: "I/O priority of the request (default: GLib.PRIORITY_DEFAULT)"
            })
          ],
          return_type: new GenerifiedType(
            new NativeType("AsyncIterableIterator"),
            new GenericType(`${Bytes.namespace.namespace}.${Bytes.name}`)
          )
        }),
        // Implementation of the override [Gio.InputStream.prototype.createSyncIterator](https://gjs-docs.gnome.org/gjs/overrides.md#gio-inputstream-createsynciterator)
        new IntrospectedClassFunction({
          name: "createSyncIterator",
          parent: InputStream,
          doc: 'Creates a synchronous iterator for a Gio.InputStream that reads the stream in chunks.\n\nEach iteration will return a GLib.Bytes object containing at most `count` bytes (default 4096). The iterator will end when the stream is exhausted.\n\nExample:\n```js\nimport Gio from "gi://Gio";\n\nconst textDecoder = new TextDecoder("utf-8");\n\nconst file = Gio.File.new_for_path("/etc/os-release");\nconst inputStream = file.read(null);\n\nfor (const bytes of inputStream.createSyncIterator(4)) {\n  log(textDecoder.decode(bytes.toArray()));\n}\n```\n\n@returns An iterable yielding GLib.Bytes objects',
          parameters: [
            new IntrospectedFunctionParameter({
              name: "count",
              type: new NativeType("number"),
              isOptional: true,
              direction: "in" /* In */,
              doc: "Maximum number of bytes to read per chunk (default: 4096)"
            }),
            new IntrospectedFunctionParameter({
              name: "priority",
              type: new NativeType("number"),
              isOptional: true,
              direction: "in" /* In */,
              doc: "I/O priority of the request (default: GLib.PRIORITY_DEFAULT)"
            })
          ],
          return_type: new GenerifiedType(
            new NativeType("IterableIterator"),
            new GenericType(`${Bytes.namespace.namespace}.${Bytes.name}`)
          )
        })
      );
    }
    const SimpleAction = namespace.assertClass("SimpleAction");
    const GLib = namespace.assertInstalledImport("GLib");
    const Variant = GLib.assertClass("Variant");
    const ActionEntryObj = new IntrospectedAlias({
      name: "ActionEntryObj",
      namespace,
      type: new NativeType(`{
                /** The name of the action */
                name: string;
                /** The type of the parameter that must match the parameter_type specified in the entry */
                parameter_type?: string;
                /** The initial state of the action */
                state?: string;
                /** The callback to connect to the "activate" signal of the action */
                activate?: (_source: ${SimpleAction.name}, parameter: ${Variant.namespace.namespace}.${Variant.name} | null) => void;
                /** The callback to connect to the "change-state" signal of the action */
                change_state?: (_source: ${SimpleAction.name}, value: ${Variant.namespace.namespace}.${Variant.name} | null) => void;
            }`),
      doc: "Type for action entries used in the overridden {@link ActionMap.add_action_entries}"
    });
    namespace.members.set("ActionEntryObj", ActionEntryObj);
    const ActionMap = namespace.assertClass("ActionMap");
    const newMethod = new IntrospectedClassFunction({
      name: "add_action_entries",
      parent: ActionMap,
      parameters: [
        new IntrospectedFunctionParameter({
          name: "entries",
          type: new ArrayType(new TypeIdentifier("ActionEntryObj", "Gio")),
          direction: "in" /* In */,
          doc: "Array of action entries to add"
        })
      ],
      return_type: VoidType,
      doc: "A convenience function for creating multiple simple actions. \nSee Gio.ActionEntryObj for the structure of the action entry."
    });
    const existingMethodIndex = ActionMap.members.findIndex((member) => member.name === "add_action_entries");
    if (existingMethodIndex !== -1) {
      ActionMap.members[existingMethodIndex] = newMethod;
    } else {
      console.warn("Could not find existing add_action_entries method to override");
      ActionMap.members.push(newMethod);
    }
  }
};

// ../lib/src/injections/glib.ts
var glib_default2 = {
  namespace: "GLib",
  version: "2.0",
  modifier(namespace) {
    namespace.members.set(
      "log_structured",
      new IntrospectedFunction({
        name: "log_structured",
        raw_name: "log_structured",
        namespace,
        parameters: [
          new IntrospectedFunctionParameter({
            name: "logDomain",
            type: AnyType,
            direction: "in" /* In */
          }),
          new IntrospectedFunctionParameter({
            name: "logLevel",
            type: AnyType,
            direction: "in" /* In */
          }),
          new IntrospectedFunctionParameter({
            name: "stringFields",
            type: AnyType,
            direction: "in" /* In */
          })
        ],
        return_type: AnyType
      })
    );
    namespace.members.set(
      "strstrip",
      new IntrospectedFunction({
        name: "strstrip",
        raw_name: "strstrip",
        namespace,
        parameters: [
          new IntrospectedFunctionParameter({
            name: "str",
            type: StringType,
            direction: "in" /* In */
          })
        ],
        return_type: StringType
      })
    );
    {
      const GLibError = namespace.assertClass("Error");
      const fixQuark = (c) => {
        return c.copy({
          parameters: c.parameters.map((p) => {
            if (p.type instanceof TypeIdentifier && p.type.is("GLib", "Quark")) {
              return p.copy({
                type: new BinaryType(new NativeType("({ new(...args: any[] ): Error })"), p.type)
              });
            }
            return p;
          })
        });
      };
      if (GLibError.mainConstructor && !(GLibError.mainConstructor instanceof IntrospectedDirectAllocationConstructor))
        GLibError.mainConstructor = fixQuark(GLibError.mainConstructor);
      GLibError.constructors = GLibError.constructors.map((c) => fixQuark(c));
      GLibError.members = GLibError.members.map((m) => fixQuark(m));
      GLibError.fields.push(
        new JSField({
          name: "stack",
          parent: GLibError,
          type: StringType
        })
      );
    }
    {
      const HashTable = namespace.assertClass("HashTable");
      HashTable.__ts__indexSignature = "[key: string]: B;";
    }
    {
      const Variant = namespace.assertClass("Variant");
      const VariantType = namespace.assertClass("VariantType");
      Variant.addGeneric({
        default: new NativeType("any"),
        constraint: StringType
      });
      VariantType.addGeneric({
        default: new NativeType("any"),
        constraint: StringType
      });
      const VariantParams = [
        new IntrospectedFunctionParameter({
          name: "sig",
          type: new GenericType("A"),
          direction: "in" /* In */
        }),
        new IntrospectedFunctionParameter({
          name: "value",
          type: AnyType,
          direction: "in" /* In */
        })
      ];
      const VariantConstructor = new IntrospectedConstructor({
        name: "new",
        parent: Variant,
        parameters: VariantParams.map((vp) => vp.copy()),
        return_type: new NativeType("Variant<A>")
      });
      VariantConstructor.generics = [new Generic(new GenericType("A"), void 0, void 0, StringType)];
      Variant.mainConstructor = VariantConstructor.copy();
      if (!(Variant instanceof IntrospectedRecord)) {
        throw new Error("GLib.Variant is not a record");
      }
      Variant.setPrivate(false);
      const internalConstructor = new IntrospectedConstructor({
        name: "_new_internal",
        parent: Variant,
        parameters: VariantParams.map((vp) => vp.copy()),
        return_type: AnyType
      });
      internalConstructor.generics = [new Generic(new GenericType("A"), void 0, void 0, StringType)];
      Variant.constructors.unshift(VariantConstructor.copy(), internalConstructor);
      const genericAnyReturnType = new GenericType("T", new NativeType("any"));
      const unpack = new IntrospectedClassFunction({
        name: "unpack",
        return_type: genericAnyReturnType,
        parent: Variant
      });
      unpack.generics.push(new Generic(genericAnyReturnType));
      const deepUnpack = new IntrospectedClassFunction({
        name: "deepUnpack",
        return_type: genericAnyReturnType,
        parent: Variant
      });
      deepUnpack.generics.push(new Generic(genericAnyReturnType));
      const recursiveUnpack = new IntrospectedClassFunction({
        name: "recursiveUnpack",
        return_type: genericAnyReturnType,
        parent: Variant
      });
      recursiveUnpack.generics.push(new Generic(genericAnyReturnType));
      Variant.members.push(
        unpack,
        deepUnpack,
        // deep_unpack<T = any>(): T;
        deepUnpack.copy({ name: "deep_unpack" }),
        recursiveUnpack,
        // _init(sig: any, value: any): Variant;
        new IntrospectedClassFunction({
          name: "_init",
          return_type: Variant.getType(),
          parent: Variant,
          parameters: VariantParams.map((vp) => vp.copy())
        })
      );
    }
    {
      const VariantDict = namespace.assertClass("VariantDict");
      VariantDict.members.push(
        // lookup(key: any, variantType?: any, deep?: any): any;
        new IntrospectedClassFunction({
          name: "lookup",
          return_type: AnyType,
          parent: VariantDict,
          parameters: [
            new IntrospectedFunctionParameter({
              name: "key",
              direction: "in" /* In */,
              type: AnyType
            }),
            new IntrospectedFunctionParameter({
              name: "variantType",
              direction: "in" /* In */,
              type: AnyType,
              isOptional: true
            }),
            new IntrospectedFunctionParameter({
              name: "deep",
              direction: "in" /* In */,
              type: BooleanType,
              isOptional: true
            })
          ]
        })
      );
    }
    {
      const Bytes = namespace.assertClass("Bytes");
      Bytes.members.push(
        // toArray(): Uint8Array;
        new IntrospectedClassFunction({
          name: "toArray",
          return_type: Uint8ArrayType,
          parent: Bytes,
          parameters: []
        })
      );
    }
    {
      const MainLoop = namespace.assertClass("MainLoop");
      MainLoop.members.push(
        new IntrospectedClassFunction({
          parent: MainLoop,
          name: "runAsync",
          parameters: [],
          return_type: new NativeType("Promise<void>"),
          doc: "Similar to `GLib.MainLoop.run` but return a Promise which resolves when the main loop ends, instead of blocking while the main loop runs.\nThis helps avoid the situation where Promises never resolved if you didn't run the main loop inside a callback."
        })
      );
    }
  }
};

// ../lib/src/injections/gobject.ts
function typeParam(name, type, options2 = {}) {
  return new IntrospectedFunctionParameter({
    name,
    direction: "in" /* In */,
    type,
    ...options2
  });
}
function stringParam(name, options2 = {}) {
  return typeParam(name, StringType, options2);
}
function optionalParam(name, type, options2 = {}) {
  return typeParam(name, type, {
    isOptional: true,
    doc: "An optional parameter",
    ...options2
  });
}
var gobject_default = {
  namespace: "GObject",
  version: "2.0",
  modifier(namespace) {
    {
      let generateParamSpec2 = function(name, returnType = ParamSpec.getType(), minMax = false, type = null, defaultValue = false, defaultValueType = AnyType, addGeneric = false, doc2) {
        const params = [
          stringParam("name", {
            doc: "The name of the property"
          }),
          typeParam("nick", new NullableType(StringType), {
            doc: "A human readable name for the property (can be null)"
          }),
          typeParam("blurb", new NullableType(StringType), {
            doc: "A longer description of the property (can be null)"
          }),
          typeParam("flags", new BinaryType(ParamFlags?.getType() ?? AnyType, NumberType), {
            doc: "The flags for this property (e.g. READABLE, WRITABLE)"
          })
        ];
        if (minMax) {
          params.push(
            typeParam("minimum", NumberType, {
              doc: "The minimum value for this property"
            }),
            typeParam("maximum", NumberType, {
              doc: "The maximum value for this property"
            })
          );
        }
        if (type) {
          if (!addGeneric) {
            params.push(
              typeParam(`${type}Type`, AnyType, {
                doc: "The GType for this property"
              })
            );
          } else {
            params.push(
              typeParam(`${type}Type`, new NativeType("GType<T> | { $gtype: GType<T> }"), {
                doc: "The GType for this property"
              })
            );
          }
        }
        if (defaultValue) {
          params.push(
            optionalParam("defaultValue", defaultValueType, {
              doc: "The default value for this property (optional)"
            })
          );
        }
        const fn = new IntrospectedStaticClassFunction({
          name,
          parameters: params,
          parent: ParamSpec,
          return_type: returnType
        });
        if (addGeneric) {
          fn.generics.push(new Generic(new GenericType("T")));
        }
        fn.doc = doc2;
        return fn;
      }, ParamSpecWithGenerics2 = function(type) {
        return new GenerifiedTypeIdentifier("ParamSpec", "GObject", [type]);
      };
      var generateParamSpec = generateParamSpec2, ParamSpecWithGenerics = ParamSpecWithGenerics2;
      const SignalMatch = new IntrospectedInterface({
        name: "SignalMatch",
        namespace,
        fields: [
          new IntrospectedField({
            name: "signalId",
            type: StringType,
            isStatic: false,
            writable: true
          }),
          new IntrospectedField({
            name: "detail",
            type: StringType,
            isStatic: false,
            writable: true
          }),
          new IntrospectedField({
            name: "func",
            type: AnyFunctionType,
            isStatic: false,
            writable: true
          })
        ]
      });
      SignalMatch.noParent = true;
      namespace.members.set("SignalMatch", SignalMatch);
      const GType = new IntrospectedAlias({
        name: "GType",
        namespace,
        type: new NativeType("any")
      });
      namespace.members.set("GType", GType);
      GType.noEmit();
      const ParamSpec = namespace.assertClass("ParamSpec");
      ParamSpec.doc = `A GObject parameter specification that defines property characteristics.
See https://gjs.guide/guides/gobject/basics.html#properties for more details.`;
      const ParamFlags = namespace.getEnum("ParamFlags");
      namespace.assertClass("ParamSpecBoolean").noEmit();
      namespace.assertClass("ParamSpecBoxed").noEmit();
      namespace.assertClass("ParamSpecChar").noEmit();
      namespace.assertClass("ParamSpecDouble").noEmit();
      namespace.assertClass("ParamSpecEnum").noEmit();
      namespace.assertClass("ParamSpecFlags").noEmit();
      namespace.assertClass("ParamSpecFloat").noEmit();
      namespace.assertClass("ParamSpecInt").noEmit();
      namespace.assertClass("ParamSpecInt64").noEmit();
      namespace.assertClass("ParamSpecLong").noEmit();
      namespace.assertClass("ParamSpecObject").noEmit();
      namespace.assertClass("ParamSpecParam").noEmit();
      namespace.assertClass("ParamSpecString").noEmit();
      namespace.assertClass("ParamSpecUChar").noEmit();
      namespace.assertClass("ParamSpecUnichar").noEmit();
      namespace.assertClass("ParamSpecValueArray").noEmit();
      namespace.assertClass("ParamSpecVariant").noEmit();
      namespace.assertClass("ParamSpecUInt").noEmit();
      namespace.assertClass("ParamSpecUInt64").noEmit();
      namespace.assertClass("ParamSpecULong").noEmit();
      namespace.assertClass("ParamSpecGType").noEmit();
      namespace.assertClass("ParamSpecOverride").noEmit();
      namespace.assertClass("ParamSpecPointer").noEmit();
      ParamSpec.addGeneric({
        default: UnknownType
      });
      const object = new IntrospectedStaticClassFunction({
        name: "object",
        parameters: [
          stringParam("name", {
            doc: "The name of the property"
          }),
          typeParam("nick", new NullableType(StringType), {
            doc: "A human readable name for the property (can be null)"
          }),
          typeParam("blurb", new NullableType(StringType), {
            doc: "A longer description of the property (can be null)"
          }),
          typeParam("flags", new BinaryType(ParamFlags?.getType() ?? AnyType, NumberType), {
            doc: "The flags for this property (e.g. READABLE, WRITABLE)"
          }),
          optionalParam("objectType", new NativeType("GType<T> | { $gtype: GType<T> }"), {
            doc: "The GType of the object (optional)"
          })
        ],
        parent: ParamSpec,
        return_type: new NativeType("ParamSpec<T>")
      });
      object.generics.push(new Generic(new GenericType("T")));
      object.doc = "Creates a new GParamSpecObject instance specifying a property holding object references.";
      const jsobject = new IntrospectedStaticClassFunction({
        name: "jsobject",
        parameters: [
          stringParam("name", {
            doc: "The name of the property"
          }),
          typeParam("nick", new NullableType(StringType), {
            doc: "A human readable name for the property (can be null)"
          }),
          typeParam("blurb", new NullableType(StringType), {
            doc: "A longer description of the property (can be null)"
          }),
          typeParam("flags", new BinaryType(ParamFlags?.getType() ?? AnyType, NumberType), {
            doc: "The flags for this property (e.g. READABLE, WRITABLE)"
          })
        ],
        parent: ParamSpec,
        return_type: new NativeType("ParamSpec<T>")
      });
      jsobject.generics.push(new Generic(new GenericType("T")));
      jsobject.doc = "Creates a new ParamSpec instance for JavaScript object properties.";
      const override3 = new IntrospectedClassFunction({
        parent: ParamSpec,
        name: "override",
        return_type: VoidType,
        parameters: [
          new IntrospectedFunctionParameter({
            direction: "in" /* In */,
            name: "name",
            type: StringType,
            doc: "The name of the property to override"
          }),
          new IntrospectedFunctionParameter({
            direction: "in" /* In */,
            name: "oclass",
            type: new OrType(
              namespace.assertClass("Object").getType(),
              new NativeType("Function"),
              new TypeIdentifier("GType", "GObject")
            ),
            doc: "The object class or type that contains the property to override"
          })
        ],
        doc: "Registers a property override for a property introduced in a parent class or inherited interface."
      });
      const stringParamSpec = new IntrospectedStaticClassFunction({
        name: "string",
        parameters: [
          stringParam("name", {
            doc: "The name of the property"
          }),
          typeParam("nick", new NullableType(StringType), {
            doc: "A human readable name for the property (can be null)"
          }),
          typeParam("blurb", new NullableType(StringType), {
            doc: "A longer description of the property (can be null)"
          }),
          typeParam("flags", new BinaryType(ParamFlags?.getType() ?? AnyType, NumberType), {
            doc: "The flags for this property (e.g. READABLE, WRITABLE)"
          }),
          optionalParam("defaultValue", new NullableType(StringType), {
            doc: "The default value for this property (optional, defaults to null if not provided)"
          })
        ],
        parent: ParamSpec,
        return_type: ParamSpecWithGenerics2(StringType)
      });
      stringParamSpec.doc = "Creates a new GParamSpecString instance specifying a G_TYPE_STRING property.";
      ParamSpec.members.push(
        generateParamSpec2(
          "char",
          ParamSpecWithGenerics2(NumberType),
          true,
          null,
          true,
          NumberType,
          false,
          "Creates a new GParamSpecChar instance specifying a G_TYPE_CHAR property."
        ),
        generateParamSpec2(
          "uchar",
          ParamSpecWithGenerics2(NumberType),
          true,
          null,
          true,
          NumberType,
          false,
          "Creates a new GParamSpecUChar instance specifying a G_TYPE_UCHAR property."
        ),
        generateParamSpec2(
          "int",
          ParamSpecWithGenerics2(NumberType),
          true,
          null,
          true,
          NumberType,
          false,
          "Creates a new GParamSpecInt instance specifying a G_TYPE_INT property."
        ),
        generateParamSpec2(
          "uint",
          ParamSpecWithGenerics2(NumberType),
          true,
          null,
          true,
          NumberType,
          false,
          "Creates a new GParamSpecUInt instance specifying a G_TYPE_UINT property."
        ),
        generateParamSpec2(
          "long",
          ParamSpecWithGenerics2(NumberType),
          true,
          null,
          true,
          NumberType,
          false,
          "Creates a new GParamSpecLong instance specifying a G_TYPE_LONG property."
        ),
        generateParamSpec2(
          "ulong",
          ParamSpecWithGenerics2(NumberType),
          true,
          null,
          true,
          NumberType,
          false,
          "Creates a new GParamSpecULong instance specifying a G_TYPE_ULONG property."
        ),
        generateParamSpec2(
          "int64",
          ParamSpecWithGenerics2(NumberType),
          true,
          null,
          true,
          NumberType,
          false,
          "Creates a new GParamSpecInt64 instance specifying a G_TYPE_INT64 property."
        ),
        generateParamSpec2(
          "uint64",
          ParamSpecWithGenerics2(NumberType),
          true,
          null,
          true,
          NumberType,
          false,
          "Creates a new GParamSpecUInt64 instance specifying a G_TYPE_UINT64 property."
        ),
        generateParamSpec2(
          "float",
          ParamSpecWithGenerics2(NumberType),
          true,
          null,
          true,
          NumberType,
          false,
          "Creates a new GParamSpecFloat instance specifying a G_TYPE_FLOAT property."
        ),
        generateParamSpec2(
          "boolean",
          ParamSpecWithGenerics2(BooleanType),
          false,
          null,
          true,
          BooleanType,
          false,
          "Creates a new GParamSpecBoolean instance specifying a G_TYPE_BOOLEAN property. In many cases, it may be more appropriate to use an enum with g_param_spec_enum(), both to improve code clarity by using explicitly named values, and to allow for more values to be added in future without breaking API."
        ),
        generateParamSpec2(
          "flags",
          ParamSpecWithGenerics2(NumberType),
          false,
          "flags",
          true,
          void 0,
          false,
          "Creates a new GParamSpecFlags instance specifying a G_TYPE_FLAGS property."
        ),
        generateParamSpec2(
          "enum",
          ParamSpecWithGenerics2(new NativeType("T")),
          false,
          "enum",
          true,
          void 0,
          true,
          "Creates a new GParamSpecEnum instance specifying a G_TYPE_ENUM property."
        ),
        generateParamSpec2(
          "double",
          ParamSpecWithGenerics2(NumberType),
          true,
          null,
          true,
          NumberType,
          false,
          "Creates a new GParamSpecDouble instance specifying a G_TYPE_DOUBLE property."
        ),
        stringParamSpec,
        generateParamSpec2(
          "boxed",
          ParamSpecWithGenerics2(new NativeType("T")),
          false,
          "boxed",
          false,
          void 0,
          true,
          "Creates a new GParamSpecBoxed instance specifying a G_TYPE_BOXED derived property."
        ),
        object,
        generateParamSpec2(
          "param",
          ParamSpec.getType(),
          false,
          "param",
          false,
          void 0,
          false,
          "Creates a new GParamSpecParam instance specifying a G_TYPE_PARAM property."
        ),
        jsobject,
        override3
      );
    }
    namespace.members.delete("Closure");
    namespace.members.set(
      "Closure",
      new IntrospectedAlias({
        name: "Closure",
        namespace,
        type: NativeType.of("(...args: P[]) => R"),
        generics: [
          {
            name: "R",
            type: AnyType
          },
          {
            name: "P",
            type: AnyType
          }
        ]
      })
    );
    {
      let replaceFunction2 = function(name, ...functions) {
        namespace.members.delete(name);
        namespace.members.set(name, functions);
      }, originalFunc2 = function(name) {
        return new IntrospectedFunction({
          name,
          namespace,
          raw_name: name,
          return_type: NumberType,
          parameters: originalArgs.map((a) => a.copy())
        });
      }, func2 = function(name) {
        replaceFunction2(
          name,
          // [name](...args: [Object, SignalMatch] | [Object, SignalMatchType, number, GLib.Quark, Closure | null, object | null, object | null]): number;
          new IntrospectedFunction({
            name,
            namespace,
            raw_name: name,
            return_type: NumberType,
            parameters: [args]
          }),
          // export function [name](instance: Object, match: SignalMatch): number;
          new IntrospectedFunction({
            name,
            namespace,
            raw_name: name,
            return_type: NumberType,
            parameters: modifiedArgs.map((a) => a.copy())
          }),
          // export function [name](instance: Object, mask: SignalMatchType, signal_id: number, detail: GLib.Quark, closure: Closure | null, func: object | null, data: object | null): number
          originalFunc2(name),
          // export function [`_real_${name}`](instance: Object, mask: SignalMatchType, signal_id: number, detail: GLib.Quark, closure: Closure | null, func: object | null, data: object | null): number
          originalFunc2(`_real_${name}`)
        );
      };
      var replaceFunction = replaceFunction2, originalFunc = originalFunc2, func = func2;
      const GObject = namespace.assertClass("Object");
      const Value = namespace.assertClass("Value");
      const get_property = GObject.members.findIndex((m) => m.name === "get_property");
      const set_property = GObject.members.findIndex((m) => m.name === "set_property");
      GObject.members[get_property] = new IntrospectedClassFunction({
        name: "get_property",
        parent: GObject,
        parameters: [
          new IntrospectedFunctionParameter({
            name: "property_name",
            type: StringType,
            direction: "in" /* In */,
            doc: "The name of the property to get"
          }),
          new IntrospectedFunctionParameter({
            name: "value",
            type: Value.getType(),
            direction: "in" /* In */,
            doc: "Return location for the property value. Can be an empty GObject.Value initialized by G_VALUE_INIT (auto-initialized with expected type since GLib 2.60), a GObject.Value initialized with the expected property type, or a GObject.Value initialized with a transformable type"
          })
        ],
        return_type: AnyType,
        doc: `Gets a property of an object.

The value can be:
- an empty GObject.Value initialized by G_VALUE_INIT, which will be automatically initialized with the expected type of the property (since GLib 2.60)
- a GObject.Value initialized with the expected type of the property  
- a GObject.Value initialized with a type to which the expected type of the property can be transformed

In general, a copy is made of the property contents and the caller is responsible for freeing the memory by calling GObject.Value.unset.

Note that GObject.Object.get_property is really intended for language bindings, GObject.Object.get is much more convenient for C programming.`
      });
      GObject.members[set_property] = new IntrospectedClassFunction({
        name: "set_property",
        parent: GObject,
        parameters: [
          new IntrospectedFunctionParameter({
            name: "property_name",
            type: StringType,
            direction: "in" /* In */,
            doc: "The name of the property to set"
          }),
          new IntrospectedFunctionParameter({
            name: "value",
            type: Value.getType(),
            direction: "in" /* In */,
            doc: "The value to set the property to"
          })
        ],
        return_type: VoidType,
        doc: "Sets a property on an object."
      });
      const allBindPropertyFull = GObject.members.filter(
        (m) => m.name === "bind_property_full" && m instanceof IntrospectedClassFunction
      );
      const bindPropertyFullWithClosures = allBindPropertyFull.find((method) => {
        const hasClosureParams = method.parameters.some((param) => {
          if (param.name === "transform_to" || param.name === "transform_from") {
            const type = param.type.deepUnwrap();
            const isClosureType = type instanceof TypeIdentifier && type.name === "Closure";
            return isClosureType;
          }
          return false;
        });
        return hasClosureParams;
      });
      if (bindPropertyFullWithClosures) {
        const correctedParameters = bindPropertyFullWithClosures.parameters.map((param) => {
          if (param.name === "transform_to" || param.name === "transform_from") {
            const type = param.type.deepUnwrap();
            if (type instanceof TypeIdentifier && type.name === "Closure") {
              return param.copy({
                type: new NullableType(param.type)
              });
            }
          }
          return param;
        });
        const bindPropertyFullIndex = GObject.members.indexOf(bindPropertyFullWithClosures);
        GObject.members[bindPropertyFullIndex] = bindPropertyFullWithClosures.copy({
          parameters: correctedParameters
        });
      }
      GObject.members.push(
        new IntrospectedStaticClassFunction({
          name: "_classInit",
          parent: GObject,
          parameters: [
            new IntrospectedFunctionParameter({
              name: "klass",
              type: AnyType,
              direction: "in" /* In */
            })
          ],
          return_type: AnyType
        }),
        new IntrospectedClassFunction({
          name: "disconnect",
          parent: GObject,
          parameters: [
            new IntrospectedFunctionParameter({
              name: "id",
              type: NumberType,
              direction: "in" /* In */,
              doc: "Handler ID of the handler to be disconnected"
            })
          ],
          return_type: VoidType,
          doc: "Disconnects a handler from an instance so it will not be called during any future or currently ongoing emissions of the signal it has been connected to."
        }),
        new IntrospectedClassFunction({
          name: "set",
          parent: GObject,
          parameters: [
            new IntrospectedFunctionParameter({
              name: "properties",
              type: new NativeType("{ [key: string]: any }"),
              direction: "in" /* In */,
              doc: "Object containing the properties to set"
            })
          ],
          return_type: VoidType,
          doc: "Sets multiple properties of an object at once. The properties argument should be a dictionary mapping property names to values."
        }),
        new IntrospectedClassFunction({
          name: "block_signal_handler",
          parent: GObject,
          parameters: [
            new IntrospectedFunctionParameter({
              name: "id",
              type: NumberType,
              direction: "in" /* In */,
              doc: "Handler ID of the handler to be blocked"
            })
          ],
          return_type: VoidType,
          doc: "Blocks a handler of an instance so it will not be called during any signal emissions"
        }),
        new IntrospectedClassFunction({
          name: "unblock_signal_handler",
          parent: GObject,
          parameters: [
            new IntrospectedFunctionParameter({
              name: "id",
              type: NumberType,
              direction: "in" /* In */,
              doc: "Handler ID of the handler to be unblocked"
            })
          ],
          return_type: VoidType,
          doc: "Unblocks a handler so it will be called again during any signal emissions"
        }),
        new IntrospectedClassFunction({
          name: "stop_emission_by_name",
          parent: GObject,
          parameters: [
            new IntrospectedFunctionParameter({
              name: "detailedName",
              type: StringType,
              direction: "in" /* In */,
              doc: "Name of the signal to stop emission of"
            })
          ],
          return_type: VoidType,
          doc: "Stops a signal's emission by the given signal name. This will prevent the default handler and any subsequent signal handlers from being invoked."
        })
      );
      replaceFunction2(
        "signal_handlers_block_by_func",
        new IntrospectedFunction({
          name: "signal_handlers_block_by_func",
          namespace,
          raw_name: "signal_handlers_block_by_func",
          parameters: [
            new IntrospectedFunctionParameter({
              name: "instance",
              type: GObject.getType(),
              direction: "in" /* In */
            }),
            new IntrospectedFunctionParameter({
              name: "func",
              type: AnyFunctionType,
              direction: "in" /* In */
            })
          ],
          return_type: VoidType
        })
      );
      replaceFunction2(
        "signal_handlers_unblock_by_func",
        new IntrospectedFunction({
          name: "signal_handlers_unblock_by_func",
          namespace,
          raw_name: "signal_handlers_unblock_by_func",
          parameters: [
            new IntrospectedFunctionParameter({
              name: "instance",
              type: GObject.getType(),
              direction: "in" /* In */
            }),
            new IntrospectedFunctionParameter({
              name: "func",
              type: AnyFunctionType,
              direction: "in" /* In */
            })
          ],
          return_type: VoidType
        })
      );
      replaceFunction2(
        "signal_handlers_disconnect_by_func",
        new IntrospectedFunction({
          name: "signal_handlers_disconnect_by_func",
          namespace,
          raw_name: "signal_handlers_disconnect_by_func",
          parameters: [
            new IntrospectedFunctionParameter({
              name: "instance",
              type: GObject.getType(),
              direction: "in" /* In */
            }),
            new IntrospectedFunctionParameter({
              name: "func",
              type: AnyFunctionType,
              direction: "in" /* In */
            })
          ],
          return_type: VoidType
        })
      );
      const args = new IntrospectedFunctionParameter({
        name: "args",
        direction: "in" /* In */,
        isVarArgs: true,
        type: new BinaryType(
          new TupleType(GObject.getType(), NativeType.of("SignalMatch")),
          new TupleType(
            GObject.getType(),
            new TypeIdentifier("SignalMatchType", "GObject"),
            NumberType,
            new TypeIdentifier("Quark", "GLib"),
            new NullableType(new TypeIdentifier("Closure", "GObject")),
            new NullableType(ObjectType),
            new NullableType(ObjectType)
          )
        )
      });
      const modifiedArgs = [
        new IntrospectedFunctionParameter({
          name: "instance",
          direction: "in" /* In */,
          type: GObject.getType()
        }),
        new IntrospectedFunctionParameter({
          name: "match",
          direction: "in" /* In */,
          type: NativeType.of("SignalMatch")
        })
      ];
      const originalArgs = [
        new IntrospectedFunctionParameter({
          name: "instance",
          direction: "in" /* In */,
          type: GObject.getType()
        }),
        new IntrospectedFunctionParameter({
          name: "match",
          direction: "in" /* In */,
          type: new TypeIdentifier("SignalMatchType", "GObject")
        }),
        new IntrospectedFunctionParameter({
          name: "signal_id",
          direction: "in" /* In */,
          type: NumberType
        }),
        new IntrospectedFunctionParameter({
          name: "detail",
          type: new TypeIdentifier("Quark", "GLib"),
          direction: "in" /* In */
        }),
        new IntrospectedFunctionParameter({
          name: "closure",
          type: new NullableType(new TypeIdentifier("Closure", "GObject")),
          direction: "in" /* In */
        }),
        new IntrospectedFunctionParameter({
          name: "func",
          type: new NullableType(ObjectType),
          direction: "in" /* In */
        }),
        new IntrospectedFunctionParameter({
          name: "object",
          type: new NullableType(ObjectType),
          direction: "in" /* In */
        })
      ];
      func2("signal_handler_find");
      func2("signal_handler_block_matched");
      func2("signal_handler_block_disconnect_matched");
      func2("signal_handler_block_unblock_matched");
    }
  }
};

// ../lib/src/injections/gtk4.ts
var gtk4_default = {
  namespace: "Gtk",
  version: "4.0",
  modifier(namespace) {
    {
      const Widget = namespace.assertClass("Widget");
      Widget.fields.push(
        new JSField({
          name: "Symbol.iterator",
          parent: Widget,
          computed: true,
          doc: "Gtk.Widget is an iterable of its children.",
          type: new FunctionType({}, new GenerifiedType(new NativeType("IterableIterator"), new GenericType("Widget")))
        })
      );
    }
  }
};

// ../lib/src/injections/shell.ts
var shellTemplate = (version) => ({
  namespace: "Shell",
  version,
  modifier(namespace, _registry) {
    const GLSLEffect = namespace.assertClass("GLSLEffect");
    const addGlslSnippet = GLSLEffect.members.find((m) => m.name === "add_glsl_snippet");
    if (addGlslSnippet) {
      const updatedParameter = addGlslSnippet.parameters[0].copy({
        type: new NullableType(
          new OrType(new TypeIdentifier("SnippetHook", "Shell"), new TypeIdentifier("SnippetHook", "Cogl"))
        )
      });
      addGlslSnippet.parameters[0] = updatedParameter;
    }
  }
});
var shell14 = shellTemplate("14");
var shell15 = shellTemplate("15");
var shell16 = shellTemplate("16");

// ../lib/src/injections/tracker1.ts
var tracker1_default = {
  namespace: "Tracker",
  version: "1.0",
  modifier(namespace) {
    const SparqlError = namespace.getEnum("Error");
    if (!SparqlError) throw new Error("Error enum not found in Tracker.");
    namespace.members.delete("Error");
    SparqlError.name = "SparqlError";
    namespace.members.set("SparqlError", SparqlError);
    const CursorClass = namespace.members.get("SparqlCursorClass");
    if (CursorClass instanceof IntrospectedRecord) {
      CursorClass._structFor = new ClassStructTypeIdentifier("SparqlCursor", "Tracker");
    }
    const ConnectionClass = namespace.members.get("SparqlConnectionClass");
    if (ConnectionClass instanceof IntrospectedRecord) {
      ConnectionClass._structFor = new ClassStructTypeIdentifier("SparqlConnection", "Tracker");
    }
    const BuilderClass = namespace.members.get("SparqlBuilderClass");
    if (BuilderClass instanceof IntrospectedRecord) {
      BuilderClass._structFor = new ClassStructTypeIdentifier("SparqlBuilder", "Tracker");
    }
  }
};

// ../lib/src/injections/inject.ts
function injectDefinitions(registry, required = true) {
  return (definition) => {
    const ns = registry.namespace(definition.namespace, definition.version);
    if (required && !ns) {
      throw new Error(`Namespace '${definition.namespace}' not found.`);
    }
    if (ns) {
      definition.modifier(ns, registry);
    }
  };
}
function inject(registry) {
  const $ = injectDefinitions(registry);
  $(glib_default2);
  $(gobject_default);
  $(gio_default2);
  const $_ = injectDefinitions(registry, false);
  $_(tracker1_default);
  $_(gee08_default);
  $_(gee1_default);
  $_(gtk4_default);
  $_(shell14);
  $_(shell15);
}

// ../lib/src/validators/class.ts
var filterIntrospectableClassMembers = (node) => {
  node.fields = node.fields.filter((field) => field.isIntrospectable);
  node.props = node.props.filter((prop) => prop.isIntrospectable);
  node.callbacks = node.callbacks.filter((prop) => prop.isIntrospectable);
  node.constructors = node.constructors.filter((prop) => prop.isIntrospectable);
  node.members = node.members.filter((prop) => prop.isIntrospectable);
  return node;
};
var PROTECTED_FIELD_NAMES = ["parent_instance", "parent", "parent_class", "object_class"];
var filterProtectedFields = (node) => {
  const set = new Set(PROTECTED_FIELD_NAMES);
  node.fields = node.fields.filter((f) => {
    return !set.has(f.name);
  });
  return node;
};
var filterReservedProperties = (node) => {
  const set = /* @__PURE__ */ new Set(["prototype", "constructor"]);
  node.fields = node.fields.filter((f) => {
    return !set.has(f.name);
  });
  node.props = node.props.filter((p) => {
    return !set.has(p.name);
  });
  node.members = node.members.filter((m) => {
    return !set.has(m.name);
  });
  return node;
};
var filterConflictingNamedClassMembers = (node) => {
  node.members = node.members.filter((m) => {
    return !node.props.some((prop) => prop.name === m.name && !(m instanceof IntrospectedStaticClassFunction));
  });
  node.fields = node.fields.filter(
    (f) => !node.members.some((n) => n.name === f.name && !(n instanceof IntrospectedStaticClassFunction)) && !node.props.some((n) => n.name === f.name)
  );
  return node;
};
var fixParamSpecSubtypes = (node) => {
  if (node.superType?.namespace === "GObject" && node.superType.name.startsWith("ParamSpec")) {
    node.superType = new TypeIdentifier("ParamSpec", "GObject");
    node.noEmit();
  }
  return node;
};
var fixMissingParent = (node) => {
  const { namespace } = node;
  if (node.superType == null) {
    const isGObject = node.someParent((p) => p.getType().is("GObject", "Object"));
    if (isGObject) {
      node.superType = namespace.assertInstalledImport("GObject").assertClass("Object").getType();
    }
  }
  return node;
};
var removeComplexFields = (node) => {
  const { namespace } = node;
  node.fields = node.fields.filter((f) => {
    const type = f.type.deepUnwrap();
    if (type instanceof NativeType) {
      return true;
    }
    if (type instanceof TypeIdentifier) {
      const classNode = resolveTypeIdentifier(namespace, type);
      if (classNode?.isPrivate) {
        return false;
      }
      if (classNode && classNode instanceof IntrospectedRecord && !classNode.isSimple()) {
        return false;
      }
      const en = namespace.assertInstalledImport(type.namespace).getEnum(type.name);
      if (!(en instanceof IntrospectedError)) {
        return true;
      }
      return false;
    }
    return true;
  });
  return node;
};
var removeReferencesToMissingLibraries = (node) => {
  const { namespace } = node;
  node.fields = node.fields.map((f) => {
    const type = f.type.deepUnwrap();
    if (type instanceof TypeIdentifier) {
      const nsNode = namespace.getInstalledImport(type.namespace);
      if (!nsNode) {
        return f.copy({ type: AnyType });
      }
    }
    return f;
  });
  return node;
};
var removePrivateFields = (node) => {
  node.fields = node.fields.filter((f) => {
    return !f.isPrivate && !f.name.startsWith("_");
  });
  return node;
};
var resolveMainConstructor = (node) => {
  const newConstructor = node.constructors.find((c) => c.name === "new");
  const zeroArgsConstructor = node.constructors.find((c) => c.parameters.length === 0);
  const firstConstructor = node.constructors?.[0];
  if (node.isForeign()) {
    node.mainConstructor = null;
    return node;
  }
  if (zeroArgsConstructor || node.isSimpleWithoutPointers()) {
    node.mainConstructor = IntrospectedDirectAllocationConstructor.fromFields(node.fields, node);
    return node;
  }
  const resolvedConstructor = newConstructor ?? firstConstructor;
  if (resolvedConstructor) {
    node.mainConstructor = resolvedConstructor.copy();
  }
  if (node.isSimple()) {
    node.mainConstructor = IntrospectedDirectAllocationConstructor.fromFields(node.fields, node);
    return node;
  }
  return node;
};
var mergeStaticDefinitions = (node) => {
  if (!node.staticDefinition) {
    return node;
  }
  const { namespace } = node;
  const staticDefinition = namespace.getClass(node.staticDefinition);
  if (!(staticDefinition instanceof IntrospectedRecord)) {
    return node;
  }
  const staticMethods = staticDefinition.members.filter((m) => m instanceof IntrospectedClassFunction).map((m) => {
    const { name, parameters, output_parameters, isIntrospectable: isIntrospectable2 } = m;
    return new IntrospectedStaticClassFunction({
      name,
      parameters,
      output_parameters,
      return_type: m.return(),
      parent: node,
      isIntrospectable: isIntrospectable2
    });
  });
  for (const staticMethod of staticMethods) {
    if (!node.members.some(
      (member) => member.name === staticMethod.name && member instanceof IntrospectedStaticClassFunction
    )) {
      node.members.push(staticMethod);
    }
  }
  return node;
};
function chainVisitors(node, ...args) {
  let currentNode = node;
  for (const visitor of args) {
    currentNode = visitor(currentNode);
  }
  return currentNode;
}
var ClassVisitor = class extends GirVisitor {
  visitClass = (node) => chainVisitors(
    node,
    removeReferencesToMissingLibraries,
    fixMissingParent,
    fixParamSpecSubtypes,
    removeComplexFields,
    removePrivateFields,
    mergeStaticDefinitions,
    filterConflictingNamedClassMembers,
    filterIntrospectableClassMembers,
    filterProtectedFields,
    filterReservedProperties
  );
  visitInterface = (node) => chainVisitors(node, filterIntrospectableClassMembers, filterReservedProperties);
  visitRecord = (node) => chainVisitors(
    node,
    fixMissingParent,
    fixParamSpecSubtypes,
    resolveMainConstructor,
    removeComplexFields,
    removePrivateFields,
    filterConflictingNamedClassMembers,
    filterIntrospectableClassMembers,
    filterProtectedFields,
    filterReservedProperties
  );
};

// ../lib/src/validators/function-parameters.ts
var FunctionParametersVisitor = class extends GirVisitor {
  makeEnumParamsNullable(node) {
    return node.copy({
      parameters: node.parameters.map((param) => {
        const type = param.type.deepUnwrap();
        if (type instanceof TypeIdentifier) {
          const ns = node.namespace.assertInstalledImport(type.namespace);
          const isEnumType = !!ns.getEnum(type.name);
          if (isEnumType) {
            return param.copy({
              type: new NullableType(param.type)
            });
          }
        }
        return param;
      })
    });
  }
  visitFunction = (node) => {
    return this.makeEnumParamsNullable(node);
  };
  visitClassFunction = (node) => {
    return this.makeEnumParamsNullable(node);
  };
};

// ../lib/src/validators/interface.ts
var InterfaceVisitor = class extends GirVisitor {
  visitInterface = (node) => {
    if (!node.noParent && node.superType == null) {
      const gobject = node.namespace.assertInstalledImport("GObject");
      const GObject = gobject.assertClass("Object");
      if (!GObject) {
        throw new Error(`GObject.Object could not be found while generating ${node.namespace.namespace}.${node.name}`);
      }
      node.superType = GObject.getType();
    }
    return node;
  };
};

// ../lib/src/gir/registry.ts
var NSRegistry = class {
  mapping = new TwoKeyMap();
  formatters = /* @__PURE__ */ new Map();
  generators = /* @__PURE__ */ new Map();
  c_mapping = /* @__PURE__ */ new Map();
  transformations = [];
  subtypes = new TwoKeyMap();
  constructor() {
    this.formatters.set("json", new JSONFormatter());
  }
  registerTransformation(visitor) {
    this.transformations.push(visitor);
    this.mapping.forEach((n) => {
      n.accept(visitor);
    });
  }
  registerFormatter(output, formatter) {
    this.formatters.set(output, formatter);
  }
  getFormatter(output) {
    return this.formatters.get(output) ?? new DefaultFormatter();
  }
  registerGenerator(output, generator) {
    this.generators.set(output, generator);
  }
  async getGenerator(output) {
    if (!this.generators.has(output)) {
      let Generator;
      try {
        Generator = await import(`@gi.ts/generator-${output}`);
        if (Generator) {
          console.log(`Loading generator "@gi.ts/generator-${output}"...`);
          this.generators.set(output, Generator.default);
          return Generator.default;
        }
      } catch {
        try {
          Generator = await import(`gi-ts-generator-${output}`);
          console.log(`Loading generator "gi-ts-generator-${output}"...`);
          this.generators.set(output, Generator.default);
          return Generator.default;
        } catch {
          try {
            Generator = await import(`${output}`);
            console.log(`Loading generator "${output}"...`);
            this.generators.set(output, Generator.default);
            return Generator.default;
          } catch {
          }
        }
      }
    }
    return this.generators.get(output);
  }
  _transformNamespace(namespace) {
    this.transformations.forEach((t) => {
      namespace.accept(t);
    });
  }
  namespace(name, version) {
    const namespace = this.mapping.get(name, version);
    return namespace ?? null;
  }
  namespacesForPrefix(c_prefix) {
    return (this.c_mapping.get(c_prefix) ?? []).map(
      (c_mapping) => this.assertNamespace(c_mapping.name, c_mapping.version)
    );
  }
  transform(options2) {
    const GLib = this.assertNamespace("GLib", "2.0");
    const Gio = this.assertNamespace("Gio", "2.0");
    const GObject = this.assertNamespace("GObject", "2.0");
    Gio.package_version = [...GLib.package_version];
    GObject.package_version = [...GLib.package_version];
    const interfaceVisitor = new InterfaceVisitor();
    this.registerTransformation(interfaceVisitor);
    const classVisitor = new ClassVisitor();
    this.registerTransformation(classVisitor);
    const enumParamsVisitor = new FunctionParametersVisitor();
    this.registerTransformation(enumParamsVisitor);
    console.log("Adding generics...");
    generify(this, options2.inferGenerics);
    console.log("Injecting types...");
    inject(this);
  }
  defaultVersionOf(name) {
    if (name === "GLib" || name === "Gio" || name === "GObject") {
      return "2.0";
    }
    const meta = this.mapping.getIfOnly(name);
    if (meta) {
      return meta[0];
    }
    return null;
  }
  assertDefaultVersionOf(name) {
    const version = this.defaultVersionOf(name);
    if (version) {
      return version;
    }
    throw new Error(`No single version found for unspecified dependency: ${JSON.stringify(name)}.`);
  }
  assertNamespace(name, version) {
    const namespace = this.mapping.get(name, version) ?? null;
    if (!namespace) {
      throw new Error(`Namespace '${name}' not found.`);
    }
    return namespace;
  }
  register(namespace) {
    this.mapping.set(namespace.namespace, namespace.version, namespace);
    namespace.c_prefixes.forEach((c_prefix) => {
      const c_map = this.c_mapping.get(c_prefix) || [];
      c_map.push({ name: namespace.namespace, version: namespace.version });
      this.c_mapping.set(c_prefix, c_map);
    });
    this._transformNamespace(namespace);
    return namespace;
  }
};

// ../lib/src/messages.ts
var ERROR_NO_MODULES_FOUND = (girDirectories) => `No module found in ${girDirectories.join(", ")}!
Please make sure that you have installed the necessary gir files.
For example with "sudo apt install libgtk-4-dev" for Gtk4 on Ubuntu or "sudo dnf install gtk4-devel" on Fedora.`;
var ERROR_CONFIG_EXTENSION_UNSUPPORTED = "Only configs with the extension .js and .json are currently supported. Do nothing";
var ERROR_NO_MODULE_SPECIFIED = "Need to specify modules!";
var WARN_NO_GIR_FILE_FOUND_FOR_PACKAGE = (packageName) => `No gir file found for '${packageName}', this module will be ignored`;
var DANGER_HTML_DOC_GENERATOR_NOT_IMPLEMENTED = "The HtmlDocGenerator is currently not implemented. Do nothing...";
var START_MODULE = "Start to generate .d.ts files...";
var FILE_PARSING_DONE = "Files parsed, loading types...";
var TSDATA_PARSING_DONE = "Typescript data loaded, generating .d.ts...";
var GENERATING_TYPES_DONE = "Done.";

// ../lib/src/templates/template-engine.ts
import { mkdir, readdir, readFile as readFile3, writeFile as writeFile3 } from "node:fs/promises";
import { createRequire as createRequire3 } from "node:module";
import { dirname as dirname3, extname, join as join4, resolve as resolve2 } from "node:path";
import ejs from "ejs";
var require4 = createRequire3(import.meta.url);
var TemplateEngine = class {
  log;
  templateDir;
  constructor(templateDir) {
    this.templateDir = templateDir ?? this.resolveTemplateDirectory();
    this.log = new Logger(false, "TemplateEngine");
  }
  /**
   * Resolves the templates directory from the @ts-for-gir/templates package
   * Try require.resolve first, fallback to workspace path for development
   */
  resolveTemplateDirectory() {
    try {
      return join4(dirname3(require4.resolve("@ts-for-gir/templates/package.json")), "templates");
    } catch (_error) {
      return resolve2(process.cwd(), "../../templates/templates");
    }
  }
  /**
   * Gets the append template name for a given template filename
   */
  getAppendTemplateName(templateFilename) {
    let appendTemplateFilename = templateFilename;
    if (appendTemplateFilename.endsWith(".d.ts")) {
      appendTemplateFilename = appendTemplateFilename.replace(".d.ts", ".append.d.ts");
    } else if (extname(appendTemplateFilename)) {
      const ext = extname(appendTemplateFilename);
      appendTemplateFilename = appendTemplateFilename.replace(ext, `.append${ext}`);
    } else {
      appendTemplateFilename += ".append";
    }
    return appendTemplateFilename;
  }
  /**
   * Checks if the template file or directory exists and returns the path if found
   */
  async exists(templateFilename) {
    const fullTemplatePath = join4(this.templateDir, templateFilename);
    if (await fileExists(fullTemplatePath)) {
      return fullTemplatePath;
    }
    return null;
  }
  /**
   * Removes TypeScript directive comments from the first line of a template
   */
  removeTypeScriptDirectives(content) {
    const lines = content.split("\n");
    if (lines.length > 0 && (lines[0].includes("// @ts-nocheck") || lines[0].includes("// @ts-ignore"))) {
      lines.shift();
      return lines.join("\n");
    }
    return content;
  }
  /**
   * Reads a template file from filesystem and gets the raw string back
   */
  async read(templateFilename) {
    const path = await this.exists(templateFilename);
    if (path) {
      const content = await readFile3(path, "utf8");
      return this.removeTypeScriptDirectives(content);
    }
    throw new Error(`Template '${path || templateFilename}' not found'`);
  }
  /**
   * Reads all template files from a directory and gets the raw strings back
   */
  async readAll(templateDirname, fileExtension) {
    const path = await this.exists(templateDirname);
    if (path) {
      const files = (await readdir(path)).filter((file) => file.endsWith(fileExtension));
      if (files.length === 0) {
        throw new Error(`Template directory '${templateDirname}' is empty'`);
      }
      const results = {};
      for (const file of files) {
        const content = await readFile3(join4(path, file), "utf8");
        results[file] = this.removeTypeScriptDirectives(content);
      }
      return results;
    }
    throw new Error(`Template directory '${templateDirname}' not found'`);
  }
  /**
   * Renders a template string with the given data and options
   */
  async render(templateString, data, options2 = {}) {
    try {
      const renderedTpl = await ejs.render(templateString, data, {
        async: true,
        ...options2
      });
      return renderedTpl;
    } catch (error) {
      this.log.error(`Error on render "${templateString}":`, error);
      throw error;
    }
  }
  /**
   * Loads and renders a template and gets the rendered templates back
   */
  async load(templateFilename, data, ejsOptions = {}) {
    const fileContent = await this.read(templateFilename);
    const prepend = await this.render(fileContent, data, ejsOptions);
    let append = "";
    const appendTemplateFilename = this.getAppendTemplateName(templateFilename);
    if (await this.exists(appendTemplateFilename)) {
      const appendFileContent = await this.read(appendTemplateFilename);
      append = await this.render(appendFileContent, data, ejsOptions);
    }
    return { prepend, append };
  }
  /**
   * Loads and renders all templates in a directory and gets the rendered templates back
   */
  async loadAll(templateDirname, fileExtension, data, ejsOptions = {}) {
    const fileContents = await this.readAll(templateDirname, fileExtension);
    for (const file of Object.keys(fileContents)) {
      fileContents[file] = await this.render(fileContents[file], data, ejsOptions);
    }
    return fileContents;
  }
  /**
   * Writes content to the filesystem
   */
  async writeFile(content, outputPath) {
    this.log.info("Writing to", outputPath);
    await mkdir(dirname3(outputPath), { recursive: true });
    await writeFile3(outputPath, content, { encoding: "utf8", flag: "w" });
    return Promise.resolve(outputPath);
  }
};

// ../lib/src/utils/conflicts.ts
var conflictsReporterInstance = null;
var conflictsReporterConfig = {
  enabled: false,
  output: "ts-for-gir-report.json"
};
function configureConflictsReporterInternal(enabled, output = "ts-for-gir-report.json") {
  conflictsReporterConfig = { enabled, output };
  if (conflictsReporterInstance) {
    conflictsReporterInstance = null;
  }
  if (enabled) {
    conflictsReporterInstance = new ConsoleReporter(true, "conflicts", enabled, output);
    const reporterService = ReporterService.getInstance();
    reporterService.registerReporter("conflicts", conflictsReporterInstance);
  }
}
function getConflictsReporterInstance() {
  if (!conflictsReporterInstance) {
    const config = conflictsReporterConfig;
    conflictsReporterInstance = new ConsoleReporter(true, "conflicts", config.enabled, config.output);
    if (config.enabled) {
      const reporterService = ReporterService.getInstance();
      reporterService.registerReporter("conflicts", conflictsReporterInstance);
    }
  }
  return conflictsReporterInstance;
}
var log3 = getConflictsReporterInstance();
function configureConflictsReporter(enabled, output = "ts-for-gir-report.json") {
  configureConflictsReporterInternal(enabled, output);
}
var GOBJECT_RESERVED_METHODS = ["connect", "connect_after", "emit"];
function isConflictingFunction(namespace, childThis, child, parentThis, parent) {
  if (!parent.isIntrospectable || !child.isIntrospectable) {
    return false;
  }
  if (isConstructorConflict(namespace, childThis, child, parentThis, parent)) {
    return true;
  }
  if (isMixedConstructorFunctionConflict(child, parent)) {
    return true;
  }
  if (hasDifferentPrototypes(child, parent)) {
    return false;
  }
  return hasParameterOrReturnTypeConflicts(namespace, childThis, child, parentThis, parent);
}
function filterFunctionConflict(ns, base, elements, conflict_ids, isInheritedMethods = false) {
  const nextType = base.getType();
  return elements.filter((m) => m.name).reduce((prev, next) => {
    const conflictResult = checkFunctionConflicts(ns, base, next, conflict_ids, nextType);
    if (conflictResult.shouldOmit) {
      log3.reportTypeConflict(
        "field_property",
        next.name,
        next.parent?.namespace.namespace || "unknown",
        "Field/property name conflict"
      );
    } else if (conflictResult.hasConflict) {
      if (isInheritedMethods) {
        log3.reportTypeConflict(
          "method",
          next.name,
          next.parent?.namespace.namespace || "unknown",
          "Parent method conflict"
        );
      } else {
        const neverFunction = createNeverFunction(next, base, conflictResult.message);
        prev.push(next, neverFunction);
      }
    } else {
      prev.push(next);
    }
    return prev;
  }, []);
}
function filterConflicts(ns, c, elements, behavior = 1 /* PRESERVE */) {
  const filtered = elements.filter((p) => p?.name);
  const thisType = c.getType();
  const result = [];
  for (const element of filtered) {
    const conflictType = detectConflictType(ns, c, element, thisType);
    if (conflictType) {
      if (behavior === 1 /* PRESERVE */) {
        const conflictElement = createConflictElement(element, conflictType);
        if (conflictElement) {
          result.push(conflictElement);
        } else {
          result.push(element);
        }
      }
    } else {
      result.push(element);
    }
  }
  return result;
}
function isConstructorConflict(namespace, childThis, child, parentThis, parent) {
  if (!(child instanceof IntrospectedConstructor && parent instanceof IntrospectedConstructor)) {
    return false;
  }
  return child.parameters.length > parent.parameters.length || !isSubtypeOf(namespace, childThis, parentThis, child.return(), parent.return()) || child.parameters.some((p, i) => !isSubtypeOf(namespace, childThis, parentThis, p.type, parent.parameters[i].type));
}
function isMixedConstructorFunctionConflict(child, parent) {
  return child instanceof IntrospectedConstructor !== parent instanceof IntrospectedConstructor;
}
function hasDifferentPrototypes(child, parent) {
  return Object.getPrototypeOf(child) !== Object.getPrototypeOf(parent);
}
function hasParameterOrReturnTypeConflicts(namespace, childThis, child, parentThis, parent) {
  if (child.parameters.length > parent.parameters.length) {
    return true;
  }
  if (!isSubtypeOf(namespace, childThis, parentThis, child.return(), parent.return())) {
    return true;
  }
  if (child.parameters.some((np, i) => !isSubtypeOf(namespace, childThis, parentThis, np.type, parent.parameters[i].type))) {
    return true;
  }
  const childHasOutputParams = "output_parameters" in child;
  const parentHasOutputParams = "output_parameters" in parent;
  if (childHasOutputParams && parentHasOutputParams) {
    if (child.output_parameters.length !== parent.output_parameters.length) {
      return true;
    }
    if (child.output_parameters.some(
      (np, i) => !isSubtypeOf(namespace, childThis, parentThis, np.type, parent.output_parameters[i].type)
    )) {
      return true;
    }
  }
  return false;
}
function checkFunctionConflicts(ns, base, functionElement, conflict_ids, nextType) {
  let message = null;
  if (conflict_ids.includes(functionElement.name)) {
    return { hasConflict: true, shouldOmit: false, message };
  }
  const hasParentConflict = base.someParent((resolved_parent) => {
    const parentType = resolved_parent.getType();
    return [...resolved_parent.constructors, ...resolved_parent.members].some((p) => {
      if (p.name && p.name === functionElement.name) {
        const conflicting = isConflictingFunction(ns, nextType, functionElement, parentType, p);
        if (conflicting) {
          message = `// Conflicted with ${resolved_parent.namespace.namespace}.${resolved_parent.name}.${p.name}`;
          return true;
        }
        return false;
      }
      return false;
    });
  });
  const hasFieldConflicts = checkFieldPropertyConflicts(base, functionElement.name);
  const hasGObjectConflicts = checkGObjectConflicts(base, functionElement.name);
  const hasConflict = hasParentConflict || hasGObjectConflicts;
  return {
    hasConflict,
    shouldOmit: hasFieldConflicts && !hasConflict,
    message
  };
}
function checkFieldPropertyConflicts(base, name) {
  return [...base.props, ...base.fields].some((p) => p.name && p.name === name) || base.someParent(
    (resolved_parent) => [...resolved_parent.props, ...resolved_parent.fields].some((p) => p.name && p.name === name)
  );
}
function checkGObjectConflicts(base, name) {
  const isGObject = base.someParent((p) => p.namespace.namespace === "GObject" && p.name === "Object");
  return isGObject && GOBJECT_RESERVED_METHODS.includes(name);
}
function createNeverFunction(original, base, message) {
  const neverParam = new IntrospectedFunctionParameter({
    name: "args",
    direction: "in" /* In */,
    isVarArgs: true,
    type: new ArrayType(NeverType)
  });
  const neverOptions = {
    name: original.name,
    parent: base,
    parameters: [neverParam],
    return_type: AnyType
  };
  let neverFunction;
  if (original instanceof IntrospectedConstructor) {
    neverFunction = new IntrospectedConstructor(neverOptions);
  } else if (original instanceof IntrospectedStaticClassFunction) {
    neverFunction = new IntrospectedStaticClassFunction({ ...neverOptions, parent: original.parent });
  } else if (original instanceof IntrospectedVirtualClassFunction && original.parent instanceof IntrospectedClass) {
    neverFunction = new IntrospectedVirtualClassFunction({ ...neverOptions, parent: original.parent });
  } else if (original instanceof IntrospectedClassFunction) {
    neverFunction = new IntrospectedClassFunction({ ...neverOptions, parent: original.parent });
  } else {
    const parent = Object.getPrototypeOf(original);
    throw new Error(`Unknown function type ${parent?.name} encountered.`);
  }
  if (message) {
    neverFunction.setWarning(message);
  }
  return neverFunction;
}
function detectConflictType(ns, c, element, thisType) {
  const fieldConflict = checkFieldConflicts(c, element);
  if (fieldConflict) return fieldConflict;
  const propertyConflict = checkPropertyConflicts(ns, c, element, thisType);
  if (propertyConflict) return propertyConflict;
  return checkFunctionNameConflicts(ns, c, element, thisType);
}
function checkFieldConflicts(c, element) {
  return c.findParentMap((resolved_parent) => {
    return findMap([...resolved_parent.fields], (p) => {
      if (p.name && p.name === element.name) {
        if (element instanceof IntrospectedProperty) {
          return 4 /* ACCESSOR_PROPERTY_CONFLICT */;
        }
        if (element instanceof IntrospectedField && !isSubtypeOf(c.namespace, c.getType(), resolved_parent.getType(), element.type, p.type)) {
          return 2 /* FIELD_NAME_CONFLICT */;
        }
      }
      return void 0;
    });
  });
}
function checkPropertyConflicts(ns, c, element, thisType) {
  return c.findParentMap((resolved_parent) => {
    return findMap([...resolved_parent.props], (p) => {
      if (p.name && p.name === element.name) {
        if (p.parent instanceof IntrospectedClass && element instanceof IntrospectedField) {
          return 5 /* PROPERTY_ACCESSOR_CONFLICT */;
        }
        if (element instanceof IntrospectedProperty && !isSubtypeOf(ns, thisType, resolved_parent.getType(), element.type, p.type)) {
          log3.reportTypeConflict(
            "general",
            element.name,
            element.parent?.namespace.namespace || "unknown",
            `Conflict with ${p.parent?.name}.${p.name}`
          );
          return 1 /* PROPERTY_NAME_CONFLICT */;
        }
      }
      return void 0;
    });
  });
}
function checkFunctionNameConflicts(ns, c, element, thisType) {
  return c.findParentMap(
    (resolved_parent) => findMap([...resolved_parent.constructors, ...resolved_parent.members], (p) => {
      if (p.name && p.name === element.name) {
        if (element instanceof IntrospectedProperty) {
          return 3 /* FUNCTION_NAME_CONFLICT */;
        }
        if (!(element instanceof IntrospectedClassFunction) || isConflictingFunction(ns, thisType, element, resolved_parent.getType(), p)) {
          return 3 /* FUNCTION_NAME_CONFLICT */;
        }
      }
      return void 0;
    })
  );
}
function createConflictElement(element, conflictType) {
  if (element instanceof IntrospectedField || element instanceof IntrospectedProperty) {
    return element.copy({
      type: new TypeConflict(element.type, conflictType)
    });
  }
  return null;
}

// ../lib/src/utils/generation.ts
function generateMemberName(tsVar) {
  const name = tsVar.name;
  const invalid = isInvalid(name);
  const hasInvalidName = invalid && (tsVar instanceof IntrospectedProperty || tsVar instanceof IntrospectedField);
  const Name = hasInvalidName ? `"${name}"` : name;
  if (!Name) {
    throw new Error('[generateMemberName] "name" not set!');
  }
  const ComputedName = "computed" in tsVar && tsVar.computed ? `[${name}]` : Name;
  return `${ComputedName}`;
}
function addTSDocCommentLines(lines, indentCount = 0) {
  const def = [];
  const indent = generateIndent(indentCount);
  def.push(`${indent}/**`);
  for (const line of lines) {
    def.push(`${indent} * ${line}`);
  }
  def.push(`${indent} */`);
  return def;
}
function addInfoComment(comment, indentCount = 0) {
  const def = [];
  const indent = generateIndent(indentCount);
  if (comment) {
    def.push("");
    def.push(`${indent}// ${comment}`);
    def.push("");
  }
  return def;
}
function mergeDescs(descs, comment, indentCount = 1) {
  const def = [];
  const indent = generateIndent(indentCount);
  for (const desc of descs) {
    def.push(`${indent}${desc}`);
  }
  if (def.length > 0) {
    def.unshift(...addInfoComment(comment, indentCount));
  }
  return def;
}

// ../lib/src/utils/path.ts
import { dirname as dirname4, resolve as resolve3 } from "node:path";
import { fileURLToPath } from "node:url";
var __filename = fileURLToPath(import.meta.url);
var __dirname = resolve3(dirname4(__filename), "../..");

// src/start.ts
import yargs from "yargs";
import { hideBin } from "yargs/helpers";

// src/commands/analyze.ts
import { existsSync as existsSync2, readFileSync as readFileSync2, writeFileSync } from "node:fs";

// src/config/config-loader.ts
import { dirname as dirname5, resolve as resolve4 } from "node:path";
import { cosmiconfig } from "cosmiconfig";

// src/config/config-writer.ts
import { writeFile as writeFile4 } from "node:fs/promises";
import { extname as extname2, join as join6 } from "node:path";

// src/config/defaults.ts
import { existsSync } from "node:fs";
import { join as join5 } from "node:path";
var defaults = {
  print: false,
  configName: ".ts-for-girrc.js",
  root: process.cwd(),
  outdir: "./@types",
  girDirectories: getDefaultGirDirectories(),
  modules: ["*"],
  ignore: [],
  verbose: false,
  ignoreVersionConflicts: false,
  noNamespace: false,
  noComments: false,
  promisify: true,
  npmScope: "@girs",
  workspace: false,
  onlyVersionPrefix: false,
  noPrettyPrint: false,
  noAdvancedVariants: false,
  package: false,
  reporter: false,
  reporterOutput: "ts-for-gir-report.json"
};
function getDefaultGirDirectories() {
  const girDirectories = [
    "/usr/local/share/gir-1.0",
    "/usr/share/gir-1.0",
    "/usr/share/*/gir-1.0",
    "/usr/share/gnome-shell",
    "/usr/share/gnome-shell/gir-1.0",
    "/usr/lib64/mutter-*",
    "/usr/lib/mutter-*",
    "/usr/lib/x86_64-linux-gnu/mutter-*"
  ];
  const dataDirs = process.env.XDG_DATA_DIRS?.split(":") || [];
  for (let dataDir of dataDirs) {
    dataDir = join5(dataDir, "gir-1.0");
    if (!girDirectories.includes(dataDir) && existsSync(dataDir)) {
      girDirectories.push(dataDir);
    }
  }
  return girDirectories;
}

// src/config/config-writer.ts
var logger2 = new Logger(false, "ConfigWriter");
var configFilePath = join6(process.cwd(), defaults.configName);
function setConfigFilePath(path) {
  configFilePath = path;
}
async function addToConfig(configsToAdd, configName) {
  const userConfig = await loadConfigFile(configName);
  const path = userConfig?.filepath || configFilePath;
  const configToStore = {};
  merge(configToStore, userConfig?.config || {}, configsToAdd);
  const fileExtension = extname2(path);
  let writeConfigString = "";
  switch (fileExtension) {
    case ".js":
      writeConfigString = `export default ${JSON.stringify(configToStore, null, 4)}`;
      break;
    case ".json":
      writeConfigString = `${JSON.stringify(configToStore, null, 4)}`;
      break;
    default:
      logger2.error(ERROR_CONFIG_EXTENSION_UNSUPPORTED);
      break;
  }
  if (writeConfigString && path) {
    return writeFile4(path, writeConfigString);
  }
}

// src/config/options.ts
var options = {
  modules: {
    description: "GIR modules to load, e.g. 'Gio-2.0'. Accepts multiple modules",
    array: true,
    default: defaults.modules,
    normalize: true
  },
  girDirectories: {
    type: "string",
    alias: "g",
    description: "GIR directories",
    array: true,
    default: defaults.girDirectories,
    normalize: true
  },
  root: {
    type: "string",
    description: "Root directory of your project",
    default: defaults.root,
    normalize: true
  },
  outdir: {
    type: "string",
    alias: "o",
    description: "Directory to output to",
    default: defaults.outdir,
    normalize: true
  },
  ignore: {
    type: "string",
    alias: "i",
    description: "Modules that should be ignored",
    array: true,
    default: defaults.ignore,
    normalize: true
  },
  verbose: {
    type: "boolean",
    alias: "v",
    description: "Switch on/off the verbose mode",
    default: defaults.verbose,
    normalize: true
  },
  ignoreVersionConflicts: {
    type: "boolean",
    description: "Skip prompts for library version selection when multiple versions are detected",
    default: defaults.ignoreVersionConflicts,
    normalize: true
  },
  print: {
    type: "boolean",
    alias: "p",
    description: "Print the output to console and create no files",
    default: defaults.print,
    normalize: true
  },
  configName: {
    type: "string",
    description: "Specify a custom name for the configuration file",
    default: defaults.configName,
    normalize: true
  },
  noNamespace: {
    type: "boolean",
    alias: "d",
    description: "Do not export all symbols for each module as a namespace",
    default: defaults.noNamespace,
    normalize: true
  },
  noComments: {
    type: "boolean",
    alias: "n",
    description: "Do not generate documentation comments",
    default: defaults.noComments,
    normalize: true
  },
  promisify: {
    type: "boolean",
    description: "Generate promisified functions for async/finish calls",
    default: defaults.promisify,
    normalize: true
  },
  npmScope: {
    type: "string",
    description: "Scope of the generated NPM packages",
    default: defaults.npmScope,
    normalize: true
  },
  workspace: {
    type: "boolean",
    description: "Uses the workspace protocol for the generated packages which can be used with package managers like Yarn and PNPM",
    default: defaults.workspace,
    normalize: true
  },
  onlyVersionPrefix: {
    type: "boolean",
    description: "Only use the version prefix for the ambient module exports. This is useful if, for whatever reason, you want to use different library versions of the same library in your project.",
    default: defaults.onlyVersionPrefix,
    normalize: true
  },
  noPrettyPrint: {
    type: "boolean",
    description: "Do not prettify the generated types",
    default: defaults.noPrettyPrint,
    normalize: true
  },
  noAdvancedVariants: {
    type: "boolean",
    description: "Disable GLib.Variant class with string parsing",
    default: defaults.noAdvancedVariants,
    normalize: true
  },
  package: {
    type: "boolean",
    description: "Generate the typescript types with package.json support",
    default: defaults.package,
    normalize: true
  },
  reporter: {
    type: "boolean",
    description: "Enable generation problem reporter and create a detailed report file",
    default: defaults.reporter,
    normalize: true
  },
  reporterOutput: {
    type: "string",
    description: "Output file path for the reporter (default: ts-for-gir-report.json)",
    default: defaults.reporterOutput,
    normalize: true
  }
};
var generateOptions = {
  modules: options.modules,
  girDirectories: options.girDirectories,
  root: options.root,
  outdir: options.outdir,
  ignore: options.ignore,
  verbose: options.verbose,
  ignoreVersionConflicts: options.ignoreVersionConflicts,
  print: options.print,
  configName: options.configName,
  noNamespace: options.noNamespace,
  noComments: options.noComments,
  promisify: options.promisify,
  npmScope: options.npmScope,
  workspace: options.workspace,
  onlyVersionPrefix: options.onlyVersionPrefix,
  noPrettyPrint: options.noPrettyPrint,
  noAdvancedVariants: options.noAdvancedVariants,
  package: options.package,
  reporter: options.reporter,
  reporterOutput: options.reporterOutput
};
var listOptions = {
  modules: options.modules,
  girDirectories: options.girDirectories,
  root: options.root,
  ignore: options.ignore,
  configName: options.configName,
  verbose: options.verbose
};
var copyOptions = {
  modules: options.modules,
  girDirectories: options.girDirectories,
  root: options.root,
  outdir: options.outdir,
  ignore: options.ignore,
  configName: options.configName,
  verbose: options.verbose
};
var docOptions = {
  modules: options.modules,
  girDirectories: options.girDirectories,
  root: options.root,
  outdir: options.outdir,
  ignore: options.ignore,
  verbose: options.verbose,
  ignoreVersionConflicts: options.ignoreVersionConflicts,
  configName: options.configName,
  reporter: options.reporter,
  reporterOutput: options.reporterOutput
};
var analyzeOptions = {
  reportFile: {
    type: "string",
    alias: "f",
    description: "Path to the report file to analyze",
    demandOption: true,
    normalize: true
  },
  severity: {
    type: "string",
    alias: "s",
    description: "Filter by problem severity (debug, info, warning, error, critical)",
    array: true,
    choices: ["debug", "info", "warning", "error", "critical"]
  },
  category: {
    type: "string",
    alias: "c",
    description: "Filter by problem category",
    array: true,
    choices: [
      "type_resolution",
      "parsing_failure",
      "generation_failure",
      "type_conflict",
      "dependency_issue",
      "configuration",
      "io_error",
      "general"
    ]
  },
  namespace: {
    type: "string",
    alias: "n",
    description: "Filter by namespace/module",
    array: true
  },
  type: {
    type: "string",
    alias: "t",
    description: "Filter by specific type name",
    array: true
  },
  top: {
    type: "number",
    description: "Show top N most problematic items",
    default: 10
  },
  export: {
    type: "string",
    alias: "e",
    description: "Export filtered results to file",
    normalize: true
  },
  format: {
    type: "string",
    description: "Output format (json, csv, table)",
    choices: ["json", "csv", "table"],
    default: "table"
  },
  detailed: {
    type: "boolean",
    alias: "d",
    description: "Show detailed problem information",
    default: false
  },
  summary: {
    type: "boolean",
    description: "Show summary statistics only",
    default: false
  },
  search: {
    type: "string",
    description: "Search for problems containing specific text"
  },
  since: {
    type: "string",
    description: "Show problems from a specific time range (ISO date)"
  },
  until: {
    type: "string",
    description: "Show problems until a specific time (ISO date)"
  },
  verbose: {
    type: "boolean",
    alias: "v",
    description: "Switch on/off the verbose mode",
    default: false
  }
};

// src/config/config-loader.ts
async function loadConfigFile(configName) {
  const configSearchOptions = {
    loaders: {
      // ESM loader
      ".js": async (filepath) => {
        const file = await import(filepath);
        if (file?.default?.default) {
          return file.default.default;
        }
        if (file?.default) {
          return file.default;
        }
        return file;
      }
    }
  };
  if (configName) {
    configSearchOptions.searchPlaces = [configName];
  }
  const configFile = await cosmiconfig(APP_NAME, configSearchOptions).search();
  if (configFile?.filepath) {
    setConfigFilePath(configFile.filepath);
  }
  return configFile;
}
function getOptionsGeneration(config) {
  const generateConfig = {
    ...config
  };
  return generateConfig;
}
function validate2(config) {
  return config;
}
function mergeConfigValue(userConfig, configFileData, key, optionDefault, validator) {
  const fileValue = configFileData[key];
  const userValue = userConfig[key];
  if (fileValue === void 0) return;
  if (validator && !validator(fileValue)) return;
  const isDefault = userValue === optionDefault || Array.isArray(userValue) && Array.isArray(optionDefault) && isEqual(userValue, optionDefault);
  if (isDefault) {
    userConfig[key] = fileValue;
  }
}
async function load(cliOptions) {
  const configFile = await loadConfigFile(cliOptions.configName);
  const configFileData = configFile?.config || {};
  const userConfig = {
    ...cliOptions
  };
  if (configFileData) {
    mergeConfigValue(userConfig, configFileData, "verbose", options.verbose.default, (v) => typeof v === "boolean");
    mergeConfigValue(
      userConfig,
      configFileData,
      "ignoreVersionConflicts",
      options.ignoreVersionConflicts.default,
      (v) => typeof v === "boolean"
    );
    mergeConfigValue(userConfig, configFileData, "print", options.print.default, (v) => typeof v === "boolean");
    mergeConfigValue(
      userConfig,
      configFileData,
      "noNamespace",
      options.noNamespace.default,
      (v) => typeof v === "boolean"
    );
    mergeConfigValue(
      userConfig,
      configFileData,
      "noComments",
      options.noComments.default,
      (v) => typeof v === "boolean"
    );
    mergeConfigValue(userConfig, configFileData, "promisify", options.promisify.default, (v) => typeof v === "boolean");
    mergeConfigValue(userConfig, configFileData, "workspace", options.workspace.default, (v) => typeof v === "boolean");
    mergeConfigValue(
      userConfig,
      configFileData,
      "onlyVersionPrefix",
      options.onlyVersionPrefix.default,
      (v) => typeof v === "boolean"
    );
    mergeConfigValue(
      userConfig,
      configFileData,
      "noPrettyPrint",
      options.noPrettyPrint.default,
      (v) => typeof v === "boolean"
    );
    mergeConfigValue(
      userConfig,
      configFileData,
      "noAdvancedVariants",
      options.noAdvancedVariants.default,
      (v) => typeof v === "boolean"
    );
    mergeConfigValue(userConfig, configFileData, "package", options.package.default, (v) => typeof v === "boolean");
    mergeConfigValue(userConfig, configFileData, "reporter", options.reporter.default, (v) => typeof v === "boolean");
    mergeConfigValue(userConfig, configFileData, "npmScope", options.npmScope.default);
    mergeConfigValue(userConfig, configFileData, "reporterOutput", options.reporterOutput.default);
    mergeConfigValue(userConfig, configFileData, "girDirectories", options.girDirectories.default);
    mergeConfigValue(userConfig, configFileData, "ignore", options.ignore.default);
    mergeConfigValue(userConfig, configFileData, "modules", options.modules.default);
    if (userConfig.root === options.root.default && (configFileData.root || configFile?.filepath)) {
      userConfig.root = configFileData.root || (configFile?.filepath ? dirname5(configFile.filepath) : options.root.default);
    }
    if (userConfig.outdir === options.outdir.default && configFileData.outdir) {
      userConfig.outdir = userConfig.print ? null : configFileData.outdir;
    }
  }
  if (userConfig.outdir && !userConfig.outdir.startsWith("/")) {
    userConfig.outdir = resolve4(userConfig.root, userConfig.outdir);
  }
  if (userConfig.girDirectories) {
    userConfig.girDirectories = userConfig.girDirectories.map((dir) => {
      if (!dir.startsWith("/")) {
        return resolve4(userConfig.root, dir);
      }
      return dir;
    });
  }
  return validate2(userConfig);
}

// src/commands/command-builder.ts
function createBuilder(options2, examples7) {
  return (yargs2) => {
    const optionNames = Object.keys(options2);
    for (const optionName of optionNames) {
      yargs2 = yargs2.option(optionName, options2[optionName]);
    }
    return yargs2.example(examples7);
  };
}

// src/commands/analyze.ts
var command = "analyze [options]";
var description = "Analyze report files generated by ts-for-gir reporter";
var examples = [
  [`${APP_NAME} analyze -f ./ts-for-gir-report.json`, "Show summary statistics of the report"],
  [`${APP_NAME} analyze -f ./ts-for-gir-report.json --summary`, "Show only summary statistics"],
  [`${APP_NAME} analyze -f ./ts-for-gir-report.json --severity error critical`, "Show only errors and critical issues"],
  [
    `${APP_NAME} analyze -f ./ts-for-gir-report.json --category type_resolution --detailed`,
    "Show detailed type resolution problems"
  ],
  [`${APP_NAME} analyze -f ./ts-for-gir-report.json --namespace GLib --top 5`, "Show top 5 problems in GLib namespace"],
  [
    `${APP_NAME} analyze -f ./ts-for-gir-report.json --type time_t --export ./time_t_issues.json`,
    "Export all time_t related issues"
  ],
  [
    `${APP_NAME} analyze -f ./ts-for-gir-report.json --search "Unable to resolve" --format csv`,
    "Search for resolution failures and export as CSV"
  ]
];
var builder = createBuilder(analyzeOptions, examples);
var parseReportDate = (dateValue) => {
  return typeof dateValue === "string" ? new Date(dateValue) : dateValue;
};
var loadReportFile = (filePath) => {
  if (!existsSync2(filePath)) {
    throw new Error(`Report file not found: ${filePath}`);
  }
  try {
    const content = readFileSync2(filePath, "utf-8");
    const report = JSON.parse(content);
    report.metadata.generatedAt = parseReportDate(report.metadata.generatedAt);
    report.statistics.startTime = parseReportDate(report.statistics.startTime);
    if (report.statistics.endTime) {
      report.statistics.endTime = parseReportDate(report.statistics.endTime);
    }
    report.problems = report.problems.map((problem) => ({
      ...problem,
      timestamp: parseReportDate(problem.timestamp)
    }));
    return report;
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : "Unknown error";
    throw new Error(`Failed to parse report file: ${errorMessage}`);
  }
};
var filterProblems = (problems, args) => {
  let filtered = [...problems];
  if (args.severity?.length) {
    filtered = filtered.filter((p) => args.severity?.includes(p.severity));
  }
  if (args.category?.length) {
    filtered = filtered.filter((p) => args.category?.includes(p.category));
  }
  if (args.namespace?.length) {
    filtered = filtered.filter(
      (p) => args.namespace?.some((ns) => p.location?.includes(ns) || p.module?.includes(ns) || p.metadata?.namespace === ns)
    );
  }
  if (args.type?.length) {
    filtered = filtered.filter((p) => Boolean(p.typeName && args.type?.includes(p.typeName)));
  }
  if (args.search) {
    const searchLower = args.search.toLowerCase();
    filtered = filtered.filter(
      (p) => p.message.toLowerCase().includes(searchLower) || p.details?.toLowerCase().includes(searchLower) || p.typeName?.toLowerCase().includes(searchLower)
    );
  }
  if (args.since) {
    const sinceDate = new Date(args.since);
    filtered = filtered.filter((p) => p.timestamp >= sinceDate);
  }
  if (args.until) {
    const untilDate = new Date(args.until);
    filtered = filtered.filter((p) => p.timestamp <= untilDate);
  }
  return filtered;
};
var displaySummary = (report, args) => {
  const { statistics } = report;
  console.log("\u{1F4CA} Report Summary\n");
  console.log(`Generated: ${report.metadata.generatedAt}`);
  console.log(`Version: ${report.metadata.version}`);
  console.log(`Total Problems: ${statistics.totalProblems}`);
  if (statistics.durationMs) {
    console.log(`Generation Duration: ${(statistics.durationMs / 1e3).toFixed(2)}s`);
  }
  console.log("\n\u{1F534} Problems by Severity:");
  Object.entries(statistics.bySeverity).filter(([, count]) => count > 0).sort(([, a], [, b]) => b - a).forEach(([severity, count]) => {
    console.log(`  ${severity}: ${count}`);
  });
  console.log("\n\u{1F4C2} Problems by Category:");
  Object.entries(statistics.byCategory).filter(([, count]) => count > 0).sort(([, a], [, b]) => b - a).forEach(([category, count]) => {
    console.log(`  ${category}: ${count}`);
  });
  if (statistics.typeStatistics.problematicNamespaces.length > 0) {
    console.log("\n\u{1F3E2} Most Problematic Namespaces:");
    const topCount = args.top ?? 10;
    statistics.typeStatistics.problematicNamespaces.slice(0, topCount).forEach((ns) => {
      console.log(`  ${ns.namespace}: ${ns.problems} problems`);
      if (args.detailed) {
        const typesList = ns.types.slice(0, 5).join(", ");
        const moreTypes = ns.types.length > 5 ? "..." : "";
        console.log(`    Types: ${typesList}${moreTypes}`);
      }
    });
  }
  if (statistics.typeStatistics.commonUnresolvedTypes.length > 0) {
    console.log("\n\u{1F50D} Most Common Unresolved Types:");
    const topCount = args.top ?? 10;
    statistics.typeStatistics.commonUnresolvedTypes.slice(0, topCount).forEach((type) => {
      console.log(`  ${type.type}: ${type.count} occurrences`);
      if (args.detailed) {
        const namespacesList = type.namespaces.slice(0, 3).join(", ");
        const moreNamespaces = type.namespaces.length > 3 ? "..." : "";
        console.log(`    Namespaces: ${namespacesList}${moreNamespaces}`);
      }
    });
  }
};
var displayProblems = (problems, args) => {
  if (problems.length === 0) {
    console.log("No problems match the specified filters.");
    return;
  }
  console.log(`
\u{1F50D} Found ${problems.length} matching problems:
`);
  problems.forEach((problem, index) => {
    const message = `${index + 1}. [${problem.severity.toUpperCase()}] ${problem.message}`;
    console.log(message);
    if (args.detailed) {
      console.log(`   ID: ${problem.id}`);
      console.log(`   Category: ${problem.category}`);
      console.log(`   Module: ${problem.module}`);
      if (problem.typeName) {
        console.log(`   Type: ${problem.typeName}`);
      }
      if (problem.location) {
        console.log(`   Location: ${problem.location}`);
      }
      if (problem.details) {
        console.log(`   Details: ${problem.details}`);
      }
      console.log(`   Timestamp: ${problem.timestamp}`);
      if (problem.metadata && Object.keys(problem.metadata).length > 0) {
        console.log(`   Metadata: ${JSON.stringify(problem.metadata)}`);
      }
    } else if (problem.typeName) {
      const location = problem.location ?? "unknown";
      console.log(`   Type: ${problem.typeName} | Location: ${location}`);
    }
    if (index < problems.length - 1) {
      console.log("");
    }
  });
};
var formatAsTable = (problems) => {
  if (problems.length === 0) {
    return "No problems found.";
  }
  const headers = ["Severity", "Category", "Module", "Type", "Message"];
  const rows = problems.map((p) => [
    p.severity,
    p.category,
    p.module ?? "",
    p.typeName ?? "",
    p.message.length > 50 ? `${p.message.substring(0, 47)}...` : p.message
  ]);
  const columnWidths = headers.map((header, i) => Math.max(header.length, ...rows.map((row) => row[i].length)));
  const separator = columnWidths.map((w) => "-".repeat(w)).join(" | ");
  const headerRow = headers.map((h, i) => h.padEnd(columnWidths[i])).join(" | ");
  const dataRows = rows.map((row) => row.map((cell, i) => cell.padEnd(columnWidths[i])).join(" | "));
  return [headerRow, separator, ...dataRows].join("\n");
};
var formatAsCsv = (problems) => {
  const headers = ["id", "severity", "category", "module", "typeName", "location", "message", "details", "timestamp"];
  const rows = problems.map((p) => [
    p.id,
    p.severity,
    p.category,
    p.module ?? "",
    p.typeName ?? "",
    p.location ?? "",
    `"${p.message.replace(/"/g, '""')}"`,
    `"${(p.details ?? "").replace(/"/g, '""')}"`,
    p.timestamp.toISOString()
  ]);
  return [headers.join(","), ...rows.map((row) => row.join(","))].join("\n");
};
var exportResults = (problems, filePath, format, logger9) => {
  let content;
  switch (format) {
    case "json": {
      content = JSON.stringify(problems, null, 2);
      break;
    }
    case "csv": {
      content = formatAsCsv(problems);
      break;
    }
    case "table": {
      content = formatAsTable(problems);
      break;
    }
    default: {
      throw new Error(`Unsupported export format: ${format}`);
    }
  }
  writeFileSync(filePath, content, "utf-8");
  logger9.success(`Results exported to: ${filePath}`);
};
var handler = async (args) => {
  const logger9 = new Logger(args.verbose ?? false, "AnalyzeCommand");
  try {
    const report = loadReportFile(args.reportFile);
    if (args.verbose) {
      logger9.info(`Loaded report with ${report.problems.length} problems`);
    }
    const hasFilters = Boolean(args.severity || args.category || args.namespace || args.type || args.search);
    if (args.summary || !hasFilters) {
      displaySummary(report, args);
    }
    if (args.summary) {
      return;
    }
    const filteredProblems = filterProblems(report.problems, args);
    if (hasFilters || args.detailed) {
      displayProblems(filteredProblems, args);
    }
    if (args.export) {
      const format = args.format ?? "json";
      exportResults(filteredProblems, args.export, format, logger9);
    }
    if (hasFilters && !args.summary) {
      console.log(
        `
\u{1F4CB} Filter Summary: Showing ${filteredProblems.length} of ${report.problems.length} total problems`
      );
    }
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : "Unknown error";
    logger9.error(`Analysis failed: ${errorMessage}`);
    process.exit(1);
  }
};
var analyze = {
  command,
  description,
  builder,
  handler,
  examples
};

// src/commands/copy.ts
import { copyFile, mkdir as mkdir2 } from "node:fs/promises";
import { basename as basename2, join as join8 } from "node:path";

// src/module-loader/dependency-resolver.ts
var DependencyResolver = class {
  modDependencyMap = {};
  /**
   * Extends the modDependencyMap by the current Module,
   * should be called for each girModule so that the modDependencyMap is complete
   */
  extendDependencyMapByGirModule(girModule) {
    this.modDependencyMap[girModule.packageName] = girModule.dependencies || [];
  }
  /**
   * Figure out transitive module dependencies
   */
  traverseDependencies(packageName, result = {}) {
    const deps = this.modDependencyMap[packageName];
    if (isIterable(deps)) {
      for (const dep of deps) {
        if (result[dep.packageName]) continue;
        result[dep.packageName] = dep;
        this.traverseDependencies(dep.packageName, result);
      }
    }
  }
  /**
   * Get transitive dependencies for a package
   */
  getTransitiveDependencies(packageName) {
    const result = {};
    this.traverseDependencies(packageName, result);
    return Object.values(result);
  }
  /**
   * Find modules that depend on the module with the name 'packageName'
   */
  findModulesDependingOnPackage(girModulesGroupedMap, packageName) {
    const girModules = [];
    for (const girModulesGrouped of Object.values(girModulesGroupedMap)) {
      for (const girModuleResolvedBy of girModulesGrouped.modules) {
        if (girModuleResolvedBy.packageName === packageName) {
          continue;
        }
        for (const dep of girModuleResolvedBy.module.dependencies) {
          if (dep.packageName === packageName && !girModules.includes(girModuleResolvedBy)) {
            girModules.push(girModuleResolvedBy);
          }
        }
      }
    }
    return girModules;
  }
  /**
   * Find modules that depend on the modules with the names in `packageNames`
   */
  findModulesDependingOnPackages(girModulesGroupedMap, packageNames) {
    let girModules = [];
    for (const packageName of packageNames) {
      girModules = [...girModules, ...this.findModulesDependingOnPackage(girModulesGroupedMap, packageName)];
    }
    return girModules;
  }
  /**
   * Returns a girModule found by `packageName` property
   */
  findGirModuleByFullNames(girModules, packageNames) {
    return girModules.filter((girModule) => packageNames.includes(girModule.packageName));
  }
  /**
   * Checks if a girModules with the `packageNames` exists
   */
  existsGirModules(girModules, packageName) {
    const foundModule = this.findGirModuleByFullNames(girModules, [packageName]);
    return foundModule.length > 0;
  }
};

// src/module-loader/file-finder.ts
import { basename, join as join7 } from "node:path";
import { glob as glob2 } from "glob";
var FileFinder = class {
  constructor(girDirectories, dependencyManager) {
    this.girDirectories = girDirectories;
    this.dependencyManager = dependencyManager;
  }
  /**
   * Find modules with the possibility to use wild cards for module names. E.g. `Gtk*` or `'*'`
   * @param globPackageNames Module names with potential wildcards
   * @param ignore Modules to ignore
   */
  async findGirFiles(globPackageNames, ignore = []) {
    const foundFiles = /* @__PURE__ */ new Set();
    for (let i = 0; i < globPackageNames.length; i++) {
      if (!globPackageNames[i]) {
        continue;
      }
      const filename = `${globPackageNames[i]}.gir`;
      const pattern = this.girDirectories.map((girDirectory) => join7(girDirectory, filename));
      const ignoreGirs = ignore.map((girDirectory) => `${girDirectory}.gir`);
      const files = await glob2(pattern, { ignore: ignoreGirs });
      for (const file of files) {
        foundFiles.add(file);
      }
    }
    return foundFiles;
  }
  /**
   * Convert GIR file paths to Dependency objects
   * @param girFiles Set of GIR file paths
   */
  async girFilePathToDependencies(girFiles) {
    const dependencies = [];
    for (const girFile of girFiles) {
      const packageName = basename(girFile, ".gir");
      const { namespace, version } = splitModuleName(packageName);
      const dep = await this.dependencyManager.get(namespace, version);
      dependencies.push(dep);
    }
    return dependencies;
  }
};

// src/module-loader/module-grouper.ts
var ModuleGrouper = class {
  /**
   * Groups Gir modules by name id
   * E.g. Gtk-3.0 and Gtk-4.0 will be grouped
   */
  groupGirFiles(resolveGirModules) {
    const girModulesGrouped = {};
    for (const resolveGirModule of resolveGirModules) {
      const { namespace } = splitModuleName(resolveGirModule.packageName);
      const id = namespace.toLowerCase();
      if (!girModulesGrouped[id]) {
        girModulesGrouped[id] = {
          namespace,
          modules: [resolveGirModule],
          hasConflict: false
        };
      } else {
        girModulesGrouped[id].modules.push(resolveGirModule);
        girModulesGrouped[id].hasConflict = true;
      }
    }
    return girModulesGrouped;
  }
  /**
   * Sorts out the module the user has not selected via cli prompt
   * @param girModulesGrouped Grouped modules
   * @param selected Users selected module packageName
   */
  sortVersionsByAnswer(girModulesGrouped, selected) {
    const keep = /* @__PURE__ */ new Set();
    let ignore = [];
    if (!girModulesGrouped.hasConflict) {
      keep.add(girModulesGrouped.modules[0]);
    } else {
      const keepModules = this.findGirModuleByFullNames(girModulesGrouped.modules, selected);
      const girModulePackageNames = girModulesGrouped.modules.map((resolveGirModule) => resolveGirModule.packageName);
      if (!keepModules || keepModules.length <= 0) {
        throw new Error("Module not found!");
      }
      for (const keepModule of keepModules) {
        keep.add(keepModule);
      }
      const toIgnore = girModulePackageNames.filter((packageName) => !selected.includes(packageName));
      ignore = ignore.concat(toIgnore);
    }
    return {
      keep,
      ignore
    };
  }
  /**
   * Find modules by package names
   */
  findGirModuleByFullNames(girModules, packageNames) {
    return girModules.filter((girModule) => packageNames.includes(girModule.packageName));
  }
};

// src/module-loader/prompt-handler.ts
import { select } from "@inquirer/prompts";
import { bold } from "colorette";
var PromptHandler = class {
  log;
  constructor(verbose) {
    this.log = new Logger(verbose, "PromptHandler");
  }
  /**
   * Ask if user wants to ignore dependencies
   */
  async askIgnoreDepsPrompt(deps) {
    const size = deps.length || deps.size || 0;
    if (size > 0) {
      this.log.log(bold("\nThe following modules have the ignored modules as dependencies:"));
      for (const dep of deps) {
        this.log.log(`- ${dep.packageName}`);
      }
      this.log.log(bold("\n"));
      return select({
        message: "Do you want to ignore them too?",
        choices: [
          { value: "Yes", name: "Yes" },
          { value: "No", name: "No" },
          { value: "Go back", name: "Go back" }
        ]
      });
    }
    this.log.log(bold("\nNo dependencies found on the ignored modules"));
    return select({
      message: "Do you want to continue?",
      choices: [
        { value: "Yes", name: "Yes" },
        { value: "Go back", name: "Go back" }
      ]
    });
  }
  /**
   * Ask for module version selection
   */
  async askForVersionsPrompt(girModulesGrouped) {
    const choices = ["All", ...girModulesGrouped.modules.map((module) => module.packageName)];
    const selected = await select({
      message: `Multiple versions of '${girModulesGrouped.namespace}' found, which one do you want to use?`,
      choices: choices.map((choice) => ({
        value: choice,
        name: choice
      }))
    });
    if (selected === "All") {
      return {
        selected: choices.filter((choice) => choice !== "All"),
        unselected: []
      };
    }
    return {
      selected: [selected],
      unselected: choices.filter((choice) => choice !== selected && choice !== "All")
    };
  }
  /**
   * Ask if user wants to add ignored modules to config
   */
  async askAddToIgnoreToConfigPrompt(ignoredModules) {
    const shouldAdd = await select({
      message: `Do you want to add the ignored modules to your config so that you don't need to select them again next time?
  Config path: '${configFilePath}'`,
      choices: [
        { value: "No", name: "No" },
        { value: "Yes", name: "Yes" }
      ]
    });
    if (shouldAdd === "Yes") {
      await addToConfig({
        ignore: Array.from(ignoredModules)
      });
      this.log.log(`Add ignored modules to '${configFilePath}'`);
    }
  }
  /**
   * Show ignored modules
   */
  showIgnoredModules(ignore) {
    if (ignore && ignore.length > 0) {
      const ignoreLogList = `- ${ignore.join("\n- ")}`;
      this.log.log(bold("\n The following modules will be ignored:"));
      this.log.log(`
${ignoreLogList}
`);
    }
  }
};

// src/module-loader.ts
var ModuleLoader = class {
  constructor(config, registry) {
    this.config = config;
    this.registry = registry;
    this.log = new Logger(config.verbose, "ModuleLoader");
    this.dependencyManager = DependencyManager.getInstance(config);
    this.dependencyResolver = new DependencyResolver();
    this.fileFinder = new FileFinder(config.girDirectories, this.dependencyManager);
    this.moduleGrouper = new ModuleGrouper();
    this.promptHandler = new PromptHandler(config.verbose);
  }
  log;
  dependencyManager;
  dependencyResolver;
  fileFinder;
  moduleGrouper;
  promptHandler;
  /**
   * Sets the traverse dependencies for the current girModule,
   * is required so that all dependencies can be found internally when generating the dependency imports for the module .d.ts file
   */
  async initGirModules(girModules) {
    for (const girModule of girModules) {
      const dependencies = this.dependencyResolver.getTransitiveDependencies(girModule.packageName);
      await girModule.module.initTransitiveDependencies(dependencies);
    }
  }
  /**
   * Reads a gir xml module file and creates an object of GirModule.
   * Also sets the setDependencyMap
   */
  async loadAndCreateGirModule(dependency) {
    if (!dependency.exists || dependency.path === null) {
      return null;
    }
    this.log.log(`Loading ${dependency.packageName}...`);
    const girModule = await GirModule.load(dependency, this.config, this.registry);
    this.dependencyResolver.extendDependencyMapByGirModule(girModule);
    return girModule;
  }
  /**
   * If multiple versions of the same module are found, this will ask the user with input prompts for the version they wish to use.
   * Ignores also modules that depend on a module that should be ignored
   */
  async askForEachConflictVersionsPrompt(girModulesGroupedMap, ignore) {
    let keep = /* @__PURE__ */ new Set();
    for (const girModulesGrouped of Object.values(girModulesGroupedMap)) {
      girModulesGrouped.modules = girModulesGrouped.modules.filter(
        (girGroup) => !ignore.includes(girGroup.packageName)
      );
      girModulesGrouped.hasConflict = girModulesGrouped.modules.length >= 2;
      if (girModulesGrouped.modules.length <= 0) {
        continue;
      }
      if (!girModulesGrouped.hasConflict) {
        keep = union(keep, girModulesGrouped.modules);
      } else {
        let goBack = true;
        let versionAnswer = null;
        let ignoreDepsAnswer = null;
        let wouldIgnoreDeps = [];
        while (goBack) {
          versionAnswer = await this.promptHandler.askForVersionsPrompt(girModulesGrouped);
          wouldIgnoreDeps = this.dependencyResolver.findModulesDependingOnPackages(
            girModulesGroupedMap,
            versionAnswer.unselected
          );
          wouldIgnoreDeps = wouldIgnoreDeps.filter((dep) => !ignore.includes(dep.packageName));
          ignoreDepsAnswer = await this.promptHandler.askIgnoreDepsPrompt(wouldIgnoreDeps);
          goBack = ignoreDepsAnswer === "Go back";
        }
        if (!versionAnswer) {
          throw new Error("Error in processing the prompt versionAnswer");
        }
        if (ignoreDepsAnswer === "Yes") {
          ignore = ignore.concat(wouldIgnoreDeps.map((dep) => dep.packageName));
        }
        const unionMe = this.moduleGrouper.sortVersionsByAnswer(girModulesGrouped, versionAnswer.selected);
        keep = union(keep, unionMe.keep);
        ignore = ignore.concat(unionMe.ignore);
      }
    }
    if (ignore && ignore.length > 0) {
      this.promptHandler.showIgnoredModules(ignore);
      await this.promptHandler.askAddToIgnoreToConfigPrompt(ignore);
    }
    return {
      keep,
      ignore
    };
  }
  /**
   * Reads the gir xml module files and creates an object of GirModule for each module
   */
  async loadGirModules(dependencies, ignoreDependencies = [], girModules = [], resolvedBy = 1 /* BY_HAND */, failedGirModules = /* @__PURE__ */ new Set()) {
    let newModuleFound = false;
    dependencies = [...dependencies];
    while (dependencies.length > 0) {
      const dependency = dependencies.shift();
      if (!dependency?.packageName) continue;
      if (!this.dependencyResolver.existsGirModules(girModules, dependency.packageName)) {
        const girModule = await this.loadAndCreateGirModule(dependency);
        if (!girModule) {
          if (!failedGirModules.has(dependency.packageName)) {
            this.log.warn(WARN_NO_GIR_FILE_FOUND_FOR_PACKAGE(dependency.packageName));
            failedGirModules.add(dependency.packageName);
          }
        } else if (girModule?.packageName) {
          const addModule = {
            namespace: dependency.namespace,
            version: dependency.version,
            packageName: girModule.packageName,
            module: girModule,
            resolvedBy,
            path: dependency.path
          };
          girModules.push(addModule);
          newModuleFound = true;
        }
      }
    }
    if (!newModuleFound) {
      return {
        loaded: girModules,
        failed: failedGirModules
      };
    }
    await this.initGirModules(girModules);
    for (const girModule of girModules) {
      const transitiveDependencies = girModule.module.transitiveDependencies;
      if (transitiveDependencies.length > 0) {
        await this.loadGirModules(
          transitiveDependencies,
          ignoreDependencies,
          girModules,
          0 /* DEPENDENCE */,
          failedGirModules
        );
      }
    }
    return {
      loaded: girModules,
      failed: failedGirModules
    };
  }
  /**
   * Loads all found `packageNames`
   * @param packageNames Module names to load
   * @param ignore Modules to ignore
   * @param doNotAskForVersionOnConflict Set this to false if you want to get a prompt for each version conflict
   */
  async getModulesResolved(packageNames, ignore = [], doNotAskForVersionOnConflict = true) {
    const girFiles = await this.fileFinder.findGirFiles([...packageNames], ignore);
    const GLib = await this.dependencyManager.get("GLib", "2.0");
    const Gio = await this.dependencyManager.get("Gio", "2.0");
    const GObject = await this.dependencyManager.get("GObject", "2.0");
    const Cairo = await this.dependencyManager.get("cairo", "1.0");
    const dependencies = await this.fileFinder.girFilePathToDependencies(girFiles);
    const { loaded, failed } = await this.loadGirModules(
      [
        GLib,
        Gio,
        GObject,
        Cairo,
        ...dependencies.filter(
          (dep) => dep.namespace !== "GLib" && dep.namespace !== "Gio" && dep.namespace !== "GObject" && dep.namespace !== "cairo"
        )
      ],
      ignore
    );
    let keep = [];
    if (doNotAskForVersionOnConflict) {
      keep = loaded;
    } else {
      const girModulesGrouped = this.moduleGrouper.groupGirFiles(loaded);
      const filtered = await this.askForEachConflictVersionsPrompt(girModulesGrouped, ignore);
      keep = Array.from(filtered.keep);
    }
    const grouped = this.moduleGrouper.groupGirFiles(keep);
    return { keep, grouped, ignore, failed };
  }
  /**
   * Find modules
   * @param modules Module names to find
   * @param ignore Modules to ignore
   */
  async getModules(modules, ignore = []) {
    const girFiles = await this.fileFinder.findGirFiles(modules, ignore);
    const dependencies = await this.fileFinder.girFilePathToDependencies(girFiles);
    const { loaded, failed } = await this.loadGirModules(dependencies, ignore);
    const grouped = this.moduleGrouper.groupGirFiles(loaded);
    return { grouped, loaded, failed: Array.from(failed) };
  }
  /**
   * Start parsing the gir modules
   */
  parse(girModules) {
    for (const girModule of girModules) {
      girModule.module.parse();
    }
  }
};

// src/commands/copy.ts
var command2 = "copy [modules..]";
var description2 = "Scan for *.gir files and copy them to a new directory";
var logger3 = new Logger(false, "CopyCommand");
var examples2 = [
  [`${APP_NAME} copy -o ./gir`, "Copy found *.gir files to ./gir"],
  [
    `${APP_NAME} copy -g /usr/share/gir-1.0 --ignore=Gtk-3.0 xrandr-1.3 -o ./gir`,
    "Copy all found *.gir files in /usr/share/gir-1.0 excluding Gtk-3.0 and xrandr-1.3 to ./gir"
  ]
];
var builder2 = createBuilder(copyOptions, examples2);
var copyGirFile = async (config, depModule) => {
  if (!depModule.path) {
    logger3.danger(`- ${depModule.packageName} not found`);
    return;
  }
  if (!config.outdir) {
    logger3.error("outdir not found");
    return;
  }
  const filename = basename2(depModule.path);
  const dest = join8(config.outdir, filename);
  if (depModule.path === dest) {
    logger3.yellow(`Skip ${depModule.path}`);
    return;
  }
  logger3.success(`Copy ${depModule.path}`);
  await copyFile(depModule.path, dest);
};
var handler2 = async (args) => {
  const config = await load(args);
  const generateConfig = getOptionsGeneration(config);
  const registry = new NSRegistry();
  const moduleLoader = new ModuleLoader(generateConfig, registry);
  const { grouped, failed } = await moduleLoader.getModules(config.modules, config.ignore);
  const moduleGroups = Object.values(grouped);
  if (Object.keys(grouped).length === 0) {
    return logger3.error(ERROR_NO_MODULES_FOUND(config.girDirectories));
  }
  if (!config.outdir) {
    logger3.error("outdir not found");
    return;
  }
  await mkdir2(config.outdir, { recursive: true }).catch((err) => {
    logger3.error(`Failed to copy gir files to ${config.outdir}: ${err}`);
  });
  for (const module of moduleGroups) {
    for (const mod of module.modules) {
      await copyGirFile(config, mod);
    }
  }
  if (failed.length > 0) {
    logger3.danger("\nDependencies not found:");
    for (const fail of failed) {
      logger3.white(`- ${fail}`);
    }
  }
};
var copy = {
  command: command2,
  description: description2,
  builder: builder2,
  handler: handler2,
  examples: examples2
};

// src/generation-handler.ts
import { mkdir as mkdir3 } from "node:fs/promises";

// ../generator-html-doc/src/html-doc-generator.ts
var HtmlDocGenerator = class _HtmlDocGenerator {
  log;
  config;
  registry;
  constructor(config, registry) {
    this.config = config;
    this.registry = registry;
    this.log = new Logger(config.verbose, _HtmlDocGenerator.name);
  }
  async start() {
    return Promise.resolve(this.log.danger(DANGER_HTML_DOC_GENERATOR_NOT_IMPLEMENTED));
  }
  generate(_module) {
    throw new Error("Method not implemented.");
  }
  finish(_girModules) {
    throw new Error("Method not implemented.");
  }
};

// ../generator-json/src/json-generator.ts
function generateType(type) {
  if (type instanceof TypeIdentifier) {
    return {
      kind: "identifier" /* identifier */,
      name: type.name,
      namespace: type.namespace
    };
  } else if (type instanceof NativeType) {
    return {
      kind: "native" /* native */,
      type: type.expression()
    };
  } else if (type instanceof ClosureType) {
    return {
      kind: "closure" /* closure */,
      type: generateType(type.type),
      user_data: type.user_data
    };
  } else if (type instanceof ArrayType) {
    return {
      kind: "array" /* array */,
      type: generateType(type.type),
      depth: type.arrayDepth
    };
  } else if (type instanceof NullableType) {
    return {
      kind: "null" /* nulled */,
      type: generateType(type.type)
    };
  } else if (type instanceof TypeConflict) {
    return generateType(type.type);
  } else if (type instanceof TupleType) {
    return {
      kind: "tuple" /* tuple */,
      types: type.types.map((t) => generateType(t))
    };
  } else if (type instanceof OrType) {
    return {
      kind: "or" /* or */,
      types: type.types.map((t) => generateType(t))
    };
  } else {
    return {
      kind: "native" /* native */,
      type: "any"
    };
  }
}
var JsonGenerator = class _JsonGenerator {
  namespace;
  options;
  log;
  constructor(namespace, options2) {
    this.namespace = namespace;
    this.options = options2;
    this.log = new ConsoleReporter(options2.verbose, _JsonGenerator.name, options2.reporter, options2.reporterOutput);
    if (options2.reporter) {
      const reporterService = ReporterService.getInstance();
      reporterService.registerReporter(`${_JsonGenerator.name}(${namespace.packageName})`, this.log);
    }
  }
  generateDoc(doc2) {
    const HTML_BREAK = /<br\/>\s?/gi;
    const HTML_SQUASH = /<[^>]*>/gi;
    return doc2.replaceAll(HTML_BREAK, "\n").replaceAll(HTML_SQUASH, "").replaceAll(/^\s*\*+\s*/gm, "").replaceAll(/^\s*\n/gm, "").trim();
  }
  generateMetadata(metadata) {
    return JSON.parse(JSON.stringify(metadata));
  }
  generateParameters(parameters) {
    return parameters.map((param) => this.generateParameter(param));
  }
  generateParameter(node) {
    const type = generateType(node.type);
    return {
      kind: "parameter" /* parameter */,
      doc: node.doc ? this.generateDoc(node.doc) : null,
      metadata: node.metadata ? this.generateMetadata(node.metadata) : null,
      private: false,
      optional: node.isOptional,
      varargs: node.isVarArgs,
      name: node.name,
      type
    };
  }
  generateCallbackType(_node) {
    return [{}, {}];
  }
  generateCallback(node) {
    const parameters = this.generateParameters(node.parameters);
    const returnType = generateType(node.return());
    return {
      kind: "callback" /* callback */,
      doc: node.doc ? this.generateDoc(node.doc) : null,
      metadata: node.metadata ? this.generateMetadata(node.metadata) : null,
      private: false,
      name: node.name,
      type: this.generateCallbackType(node),
      parameters,
      returnType
    };
  }
  generateClassCallback(node) {
    const parameters = this.generateParameters(node.parameters);
    const returnType = generateType(node.return());
    return {
      kind: "callback" /* callback */,
      doc: node.doc ? this.generateDoc(node.doc) : null,
      metadata: node.metadata ? this.generateMetadata(node.metadata) : null,
      private: false,
      name: node.name,
      type: this.generateCallbackType(node),
      parameters,
      returnType
    };
  }
  // For now, simplified implementation - can be extended later with full methods
  async generateNamespace(node) {
    return {
      kind: "namespace" /* namespace */,
      imports: {},
      version: node.version,
      name: node.namespace,
      alias: [],
      enums: [],
      errors: [],
      functions: [],
      callbacks: [],
      constants: [],
      records: [],
      interfaces: [],
      classes: []
    };
  }
  async stringifyNamespace(node) {
    try {
      const namespace = await this.generateNamespace(node);
      return JSON.stringify(namespace, null, 2);
    } catch (error) {
      this.log.error(`Failed to stringify namespace: ${error}`);
      return null;
    }
  }
};

// ../generator-json/src/json-definition-generator.ts
var JsonDefinitionGenerator = class _JsonDefinitionGenerator {
  log;
  config;
  registry;
  constructor(config, registry) {
    this.config = config;
    this.registry = registry;
    this.log = new ConsoleReporter(
      this.config.verbose,
      _JsonDefinitionGenerator.name,
      this.config.reporter,
      this.config.reporterOutput
    );
    if (this.config.reporter) {
      const reporterService = ReporterService.getInstance();
      reporterService.registerReporter(_JsonDefinitionGenerator.name, this.log);
    }
  }
  async generate(module) {
    const jsonGenerator = new JsonGenerator(module, this.config);
    const output = await jsonGenerator.stringifyNamespace(module);
    if (output) {
      if (this.config.outdir) {
        const fs = await import("node:fs/promises");
        const path = await import("node:path");
        const filename = `${module.packageName}.json`;
        const filepath = path.join(this.config.outdir, filename);
        await fs.writeFile(filepath, output, "utf8");
        this.log.info(`Generated ${filename}`);
      } else {
        this.log.log(output);
      }
    } else {
      this.log.error(`Failed to generate JSON for ${module.packageName}`);
    }
  }
  async start() {
    this.log.info("Starting JSON generation...");
  }
  async finish(girModules) {
    this.log.success(`JSON generation completed for ${girModules.length} modules`);
  }
};

// ../generator-typescript/src/template-processor.ts
import { dirname as dirname6, join as join9, relative } from "node:path";
var TemplateProcessor = class extends TemplateEngine {
  data;
  packageName;
  registry;
  deps;
  config;
  reporter;
  constructor(data, packageName, registry, deps, config) {
    super();
    this.packageName = packageName;
    this.registry = registry;
    this.deps = deps;
    this.config = config;
    const dep = DependencyManager.getInstance(config);
    let outdir = config.outdir || "./";
    outdir = relative(config.root, outdir);
    const typeDir = outdir;
    this.data = {
      ...data,
      APP_NAME,
      APP_USAGE,
      APP_SOURCE,
      APP_VERSION,
      PACKAGE_DESC: PACKAGE_DESC(packageName, data?.girModule?.libraryVersion),
      PACKAGE_KEYWORDS: PACKAGE_KEYWORDS(packageName),
      importName: transformImportName(packageName),
      dep,
      deps,
      typeDir,
      join: join9,
      dirname: dirname6,
      ...this.config,
      packageName: this.packageName
    };
    this.reporter = new ConsoleReporter(
      config.verbose,
      `TemplateProcessor (${this.packageName})`,
      config.reporter,
      config.reporterOutput
    );
    if (config.reporter) {
      const reporterService = ReporterService.getInstance();
      reporterService.registerReporter(`TemplateProcessor(${packageName})`, this.reporter);
    }
  }
  /**
   * Loads and renders a template and gets the rendered templates back
   * @param templateFilename
   * @param ejsOptions EJS options
   * @param overrideTemplateData Override template data if you want
   */
  async load(templateFilename, ejsOptions = {}, overrideTemplateData = {}) {
    const mergedData = { ...this.data, ...overrideTemplateData };
    return super.load(templateFilename, mergedData, ejsOptions);
  }
  /**
   * Loads and renders all templates in a directory and gets the rendered templates back
   * @param templateDirname
   * @param fileExtension
   * @param ejsOptions EJS options
   * @param overrideTemplateData Override template data if you want
   * @returns The rendered templates
   */
  async loadAll(templateDirname, fileExtension, ejsOptions = {}, overrideTemplateData = {}) {
    const mergedData = { ...this.data, ...overrideTemplateData };
    return super.loadAll(templateDirname, fileExtension, mergedData, ejsOptions);
  }
  /**
   * Loads an template, render the template and write the template to the filesystem
   * @param templateFilename The filename of the template
   * @param baseOutputPath The base output directory path where the templates should be written to
   * @param outputFilename The filename of the output file
   * @param content A (optional) string that should be appended to the rendered template
   * @param ejsOptions EJS options
   * @param overrideTemplateData Override template data if you want
   * @return The rendered template string
   */
  async create(templateFilename, baseOutputPath, outputFilename, content = "", ejsOptions = {}, overrideTemplateData = {}) {
    const { prepend, append } = await this.load(templateFilename, ejsOptions, overrideTemplateData);
    const code = `${prepend}
${content}
${append}`;
    await this.write(code, baseOutputPath, outputFilename);
    return code;
  }
  /**
   * Loads all templates with file extension in dir, render the templates and write the template to the filesystem
   * @param fileExtension The file extension of the templates
   * @param templateDirname The directory where the templates are located
   * @param baseOutputPath The base output directory path where the templates should be written to
   * @param outputDirname The child output directory of the base output directory where the templates should be written to
   * @param append A (optional) string that should be appended to the rendered template
   * @param ejsOptions EJS options
   * @param overrideTemplateData Override template data if you want
   * @return The rendered (and if possible prettified) templates
   */
  async createAll(fileExtension, templateDirname, baseOutputPath, outputDirname, append = "", ejsOptions = {}, overrideTemplateData = {}) {
    const rendered = await this.loadAll(templateDirname, fileExtension, ejsOptions, overrideTemplateData);
    const result = {};
    for (const filename of Object.keys(rendered)) {
      const destPath = join9(baseOutputPath, outputDirname, filename);
      result[destPath] = `${rendered[filename]}
${append}`;
      await this.write(result[destPath], baseOutputPath, join9(outputDirname, filename));
    }
    return result;
  }
  /**
   * Gets the output path for a file based on package configuration
   * This is TypeScript-specific logic for handling package.json mode
   */
  getOutputPath(baseOutputPath, outputFilename) {
    const filePath = this.config.package ? join9(this.data?.importName || this.packageName, outputFilename) : outputFilename;
    const outputPath = join9(baseOutputPath, filePath);
    return outputPath;
  }
  /**
   * Writes (and optionally formats) the `content` to the filesystem
   * Includes TypeScript-specific formatting logic
   * @param content The content (normally the content of a rendered template file) that should be written to the filesystem
   * @param baseOutputPath The base output directory path where the templates should be written to
   * @param outputFilename The filename of the output file
   * @returns
   */
  async write(content, baseOutputPath, outputFilename) {
    const outputPath = this.getOutputPath(baseOutputPath, outputFilename);
    if (!this.config.noPrettyPrint) {
      try {
        if (outputFilename.endsWith(".d.ts")) {
          this.reporter.info("Formatting", outputPath);
          content = await this.registry.getFormatter("dts").format(content);
        }
      } catch (error) {
        this.reporter.error("Failed to format output...", error);
      }
    }
    return super.writeFile(content, outputPath);
  }
};

// ../generator-typescript/src/npm-package.ts
var NpmPackage = class _NpmPackage {
  config;
  moduleTemplateProcessor;
  dependencyManager;
  log;
  packageName;
  constructor(config, dependencyManager, registry, dependencyOrModule, deps) {
    this.config = config;
    this.packageName = dependencyOrModule.packageName;
    this.log = new Logger(this.config.verbose, _NpmPackage.name);
    this.dependencyManager = dependencyManager;
    this.moduleTemplateProcessor = new TemplateProcessor(
      {
        name: dependencyOrModule.namespace,
        namespace: dependencyOrModule.namespace,
        version: dependencyOrModule.version,
        importName: dependencyOrModule.importName,
        // registry: registry,
        girModule: dependencyOrModule instanceof GirModule ? dependencyOrModule : void 0
      },
      dependencyOrModule.packageName,
      registry,
      deps,
      this.config
    );
  }
  async exportNPMPackage() {
    await this.exportNPMPackageJson();
    await this.exportNPMReadme();
    await this.exportTSConfig();
    await this.exportTypeDoc();
  }
  async exportNPMPackageJson() {
    const template = "package.json";
    if (this.config.outdir) {
      await this.moduleTemplateProcessor.create(
        template,
        this.config.outdir,
        template
        // output filename
      );
    } else {
      const { append, prepend } = await this.moduleTemplateProcessor.load(template);
      this.log.log(append + prepend);
    }
  }
  async exportNPMReadme() {
    const girModuleImportName = this.packageName.toUpperCase();
    let template = girModuleImportName ? `README-${girModuleImportName}.md` : "README.md";
    const outputFilename = "README.md";
    if (!await this.moduleTemplateProcessor.exists(template)) {
      template = "README.md";
    }
    if (this.config.outdir) {
      await this.moduleTemplateProcessor.create(template, this.config.outdir, outputFilename);
    } else {
      const { append, prepend } = await this.moduleTemplateProcessor.load(template);
      this.log.log(append + prepend);
    }
  }
  async exportTSConfig() {
    const template = "tsconfig.json";
    if (this.config.outdir) {
      await this.moduleTemplateProcessor.create(
        template,
        this.config.outdir,
        template
        // output filename
      );
    } else {
      const { append, prepend } = await this.moduleTemplateProcessor.load(template);
      this.log.log(append + prepend);
    }
  }
  async exportTypeDoc() {
    const template = "typedoc.json";
    if (this.config.outdir) {
      await this.moduleTemplateProcessor.create(
        template,
        this.config.outdir,
        template
        // output filename
      );
    } else {
      const { append, prepend } = await this.moduleTemplateProcessor.load(template);
      this.log.log(append + prepend);
    }
  }
};

// ../generator-typescript/src/overrides/glib.ts
function override(node) {
  node.assertClass("Variant").noEmit();
  node.assertClass("VariantType").noEmit();
  node.assertClass("VariantBuilder").noEmit();
  node.assertClass("VariantDict").noEmit();
  return "";
}

// ../generator-typescript/src/overrides/gobject.ts
function override2(node) {
  const ParamSpec = node.assertClass("ParamSpec");
  const type_function = new IntrospectedClassFunction({
    name: "__type__",
    parent: ParamSpec,
    parameters: [
      new IntrospectedFunctionParameter({
        name: "arg",
        type: NeverType,
        direction: "in" /* In */
      })
    ],
    return_type: new NativeType("A")
    // TODO: Add support for generic native type replacement.
    // return_type: UnknownType
  });
  ParamSpec.members.push(type_function.copy());
  try {
    const propertyMember = node.members.get("Property");
    if (propertyMember) {
      if (Array.isArray(propertyMember)) {
        propertyMember.forEach((m) => {
          if ("noEmit" in m && typeof m.noEmit === "function") {
            m.noEmit();
          }
        });
      } else if ("noEmit" in propertyMember && typeof propertyMember.noEmit === "function") {
        propertyMember.noEmit();
      }
    }
  } catch (_error) {
  }
  return "";
}

// ../generator-typescript/src/module-generator.ts
var ModuleGenerator = class _ModuleGenerator extends FormatGenerator {
  log;
  dependencyManager;
  // packageData?: PackageDataParser
  config;
  moduleTemplateProcessor;
  /**
   * @param _config The config to use without the override config
   */
  constructor(namespace, config, registry) {
    super(namespace, config);
    this.config = config;
    this.log = new ConsoleReporter(
      this.config.verbose,
      _ModuleGenerator.name,
      this.config.reporter,
      this.config.reporterOutput
    );
    if (this.config.reporter) {
      const reporterService = ReporterService.getInstance();
      reporterService.registerReporter(`${_ModuleGenerator.name}(${namespace.packageName})`, this.log);
    }
    this.dependencyManager = DependencyManager.getInstance(this.config);
    const girModule = namespace;
    this.moduleTemplateProcessor = new TemplateProcessor(
      {
        name: girModule.namespace,
        namespace: girModule.namespace,
        version: girModule.version,
        importName: girModule.importName,
        girModule
      },
      girModule.packageName,
      registry,
      girModule.transitiveDependencies,
      this.config
    );
  }
  /**
   * Wraps content in module declarations for ModuleDeclaration format
   */
  wrapInModuleDeclaration(content, girModule) {
    const { namespace: name, version } = girModule.dependency;
    const header = `
/**
 * ${name} ${version}
 * 
 * Generated from ${girModule.package_version.join(".")}
 */
`;
    const moduleIdentifier = `gi://${name}`;
    const versionedNamespaceIdentifier = `${name}${girModule.dependency.version.split(".")[0].replace(/[^A-z0-9_]/g, "_")}`;
    const versionedModuleIdentifier = `${moduleIdentifier}?version=${girModule.dependency.version}`;
    const [versionedModuleHeader, versionedModuleSuffix] = [
      `declare module "${versionedModuleIdentifier}" {
          namespace ${versionedNamespaceIdentifier} {`,
      `};

        export default ${versionedNamespaceIdentifier};
      }`
    ];
    const moduleDefinition = `declare module "${moduleIdentifier}" {
        export * from "${versionedModuleIdentifier}";
      }`;
    return [header, versionedModuleHeader, content, versionedModuleSuffix, moduleDefinition].join("\n\n");
  }
  generateClassCallback(node) {
    return this.generateCallback(node);
  }
  generateConstructor(node) {
    const Parameters = this.generateParameters(node.parameters);
    return [`constructor(${Parameters});`];
  }
  generateDirectAllocationConstructor(node) {
    const ConstructorFields = node.parameters.map((param) => param.asField().asString(this)).join("\n");
    return [
      `
    constructor(properties?: Partial<{
      ${ConstructorFields}
    }>);`
    ];
  }
  generateParameters(parameters) {
    return parameters.flatMap((p) => {
      return p.asString(this);
    }).join(", ");
  }
  generateConstructorFunction(node) {
    const { namespace, options: options2 } = this;
    const Parameters = this.generateParameters(node.parameters);
    const invalid = isInvalid(node.name);
    const name = invalid ? `["${node.name}"]` : node.name;
    const warning = node.getWarning();
    const genericTypes = this.generateGenericParameters(node.generics);
    return [
      `${warning ? `${warning}
` : ""}`,
      ...this.addGirDocComment(node.doc),
      `static ${name}${genericTypes}(${Parameters}): ${node.return().resolve(namespace, options2).rootPrint(namespace, options2)};`
    ];
  }
  generateRecord(node) {
    const structFor = node.structFor;
    if (structFor) {
      const resolvedIdentifier = structFor.resolveIdentifier(this.namespace, this.config);
      if (resolvedIdentifier) {
        return this.generateAlias(
          new IntrospectedAlias({
            name: node.name,
            namespace: node.namespace,
            type: new ClassStructTypeIdentifier(structFor.name, structFor.namespace)
          })
        );
      }
      return [];
    }
    return this.generateClass(node);
  }
  generateInterface(node) {
    const isGObject = node.someParent((p) => p.namespace.namespace === "GObject" && p.name === "Object");
    const functions = filterFunctionConflict(node.namespace, node, node.members, []);
    const hasStaticFunctions = functions.some((f) => f instanceof IntrospectedStaticClassFunction);
    const hasNamespace = isGObject || hasStaticFunctions || node.callbacks.length > 0;
    return [
      ...this.generateClassNamespaces(node),
      ...hasNamespace ? this.generateInterfaceNamespace(node) : [],
      ...this.generateImplementationInterface(node),
      ...hasNamespace ? this.generateInterfaceDeclaration(node) : []
    ];
  }
  generateInterfaceNamespace(node) {
    const isGObject = node.someParent((p) => p.namespace.namespace === "GObject" && p.name === "Object");
    const namespace = node.namespace;
    const functions = filterFunctionConflict(node.namespace, node, node.members, []);
    const staticFunctions = functions.filter(
      (f) => f instanceof IntrospectedStaticClassFunction
    );
    const staticFields = node.fields.filter((f) => f.isStatic).map(
      (f) => f.copy({
        isStatic: false
      })
    );
    const gtypeNamespace = namespace.namespace === "GObject" ? "" : "GObject.";
    return [
      `export interface ${node.name}Namespace {
      ${isGObject ? `$gtype: ${gtypeNamespace}GType<${node.name}>;` : ""}
      prototype: ${node.name};
      ${staticFields.length > 0 ? staticFields.flatMap((sf) => sf.asString(this)).join("\n") : ""}
      ${staticFunctions.length > 0 ? staticFunctions.flatMap((sf) => {
        return sf.asClassFunction(node).asString(this);
      }).join("\n") : ""}    
      }`
    ];
  }
  generateInterfaceDeclaration(node) {
    return [
      `

export const ${node.name}: ${node.name}Namespace & {
        new (): ${node.name} // This allows \`obj instanceof ${node.name}\`
    }
`
    ];
  }
  generateError(node) {
    const { namespace } = this;
    const clazz = node.asClass();
    clazz.members = [];
    clazz.members.push(...Array.from(node.functions.values()));
    const GLib = namespace.assertInstalledImport("GLib");
    const GLibError = GLib.assertClass("Error");
    clazz.superType = GLibError.getType();
    clazz.mainConstructor = new IntrospectedConstructor({
      name: "new",
      parent: clazz,
      parameters: [
        new IntrospectedFunctionParameter({
          name: "options",
          type: NativeType.of("{ message: string, code: number}"),
          direction: "in" /* In */
        })
      ],
      return_type: clazz.getType()
    });
    return clazz.asString(this);
  }
  generateSignal(node, type = 0 /* CONNECT */) {
    switch (type) {
      case 0 /* CONNECT */:
        return node.asConnect(false).asString(this);
      case 1 /* CONNECT_AFTER */:
        return node.asConnect(true).asString(this);
      case 2 /* EMIT */:
        return node.asEmit().asString(this);
    }
  }
  generateStaticClassFunction(node) {
    return this.generateClassFunction(node);
  }
  generateVirtualClassFunction(node) {
    return this.generateClassFunction(node);
  }
  generateExport(type, name, definition, indentCount = 0) {
    const exp = !this.config.noNamespace ? "" : "export ";
    const indent = generateIndent(indentCount);
    if (!definition.startsWith(":")) {
      definition = ` ${definition}`;
    }
    return `${indent}${exp}${type} ${name}${definition}`;
  }
  generateProperty(tsProp, construct, indentCount = 0) {
    const desc = [];
    desc.push(...this.addGirDocComment(tsProp.doc, [], indentCount));
    const indent = generateIndent(indentCount);
    const name = generateMemberName(tsProp);
    const { readable, writable, constructOnly } = tsProp;
    const hasGetter = readable;
    const hasSetter = writable && !constructOnly;
    let type = tsProp.type;
    let getterAnnotation = "";
    let setterAnnotation = "";
    let getterSetterAnnotation = "";
    let printAsProperty = false;
    if (type instanceof TypeConflict) {
      switch (type.conflictType) {
        case 3 /* FUNCTION_NAME_CONFLICT */:
        case 2 /* FIELD_NAME_CONFLICT */:
          getterSetterAnnotation = setterAnnotation = "// This accessor conflicts with a field or function name in a parent class or interface.\n";
          type = new BinaryType(type.unwrap(), AnyType);
          printAsProperty = true;
          break;
        case 4 /* ACCESSOR_PROPERTY_CONFLICT */:
          getterSetterAnnotation = getterAnnotation = "// This accessor conflicts with a property or field in a parent class or interface.\n";
          type = new BinaryType(type.unwrap(), AnyType);
          printAsProperty = true;
          break;
        case 5 /* PROPERTY_ACCESSOR_CONFLICT */:
          type = new BinaryType(type.unwrap(), AnyType);
          break;
        case 1 /* PROPERTY_NAME_CONFLICT */:
          getterSetterAnnotation = setterAnnotation = getterAnnotation = "// This accessor conflicts with another accessor's type in a parent class or interface.\n";
          type = new BinaryType(type.unwrap(), AnyType);
          break;
      }
      if (construct && !(type instanceof BinaryType)) {
        type = new BinaryType(type instanceof TypeConflict ? type.unwrap() : type, AnyType);
      }
    }
    const Type = type.resolve(this.namespace, this.options).rootPrint(this.namespace, this.options) || "any";
    if (construct) {
      return [`${name}: ${Type};`];
    }
    if (printAsProperty) {
      desc.push(`${getterSetterAnnotation}${indent} ${name}: ${Type};`);
      return desc;
    }
    if (hasGetter && hasSetter) {
      desc.push(
        `${getterAnnotation}${indent}get ${name}(): ${Type};`,
        `${setterAnnotation}${indent}set ${name}(val: ${Type});`
      );
    } else if (hasGetter) {
      desc.push(`${getterSetterAnnotation}${indent}get ${name}(): ${Type};`);
    } else {
      desc.push(`${getterSetterAnnotation}${indent}set ${name}(val: ${Type});`);
    }
    return desc;
  }
  generateField(tsProp, indentCount = 0) {
    const desc = [];
    const isStatic = tsProp.isStatic;
    desc.push(...this.addGirDocComment(tsProp.doc, [], indentCount));
    const indent = generateIndent(indentCount);
    const name = generateMemberName(tsProp);
    const staticStr = isStatic ? "static " : "";
    const readonly = !tsProp.writable ? "readonly " : "";
    const affix = tsProp.optional ? "?" : "";
    let commentOut = "";
    let type = tsProp.type;
    if (type instanceof TypeConflict) {
      if (type.conflictType === 5 /* PROPERTY_ACCESSOR_CONFLICT */) {
        commentOut = "\n// @ts-expect-error This property conflicts with an accessor in a parent class or interface.\n";
        type = type.unwrap();
      } else if (type.conflictType === 3 /* FUNCTION_NAME_CONFLICT */) {
        commentOut = "\n// This field conflicts with a function in a parent class or interface.\n";
        type = new BinaryType(type.unwrap(), AnyType);
      } else {
        type = type.unwrap();
      }
    }
    const typeStr = this.generateType(type);
    desc.push(`${indent}${commentOut}${staticStr}${readonly}${name}${affix}: ${typeStr}`);
    return desc;
  }
  generateProperties(tsProps, comment, indentCount = 0) {
    const def = [];
    for (const tsProp of tsProps) {
      def.push(...this.generateProperty(tsProp, false, indentCount));
    }
    if (def.length > 0) {
      def.unshift(...addInfoComment(comment, indentCount));
    }
    return def;
  }
  generateFields(tsProps, comment, indentCount = 0) {
    const def = [];
    for (const tsProp of tsProps) {
      def.push(...this.generateField(tsProp));
    }
    if (def.length > 0) {
      def.unshift(...addInfoComment(comment, indentCount));
    }
    return def;
  }
  /**
   * @param tsType The type expression
   * @param namespace Provides the namespace to import relative to, defaults to the current namespace
   * @returns A string for the type expression
   */
  generateType(tsType) {
    return tsType.resolve(this.namespace, this.config).print(this.namespace, this.config);
  }
  generateDirectedType(tsType, direction) {
    return resolveDirectedType(tsType, direction)?.resolve(this.namespace, this.config)?.print(this.namespace, this.config) ?? tsType.resolve(this.namespace, this.config).print(this.namespace, this.config);
  }
  generateInParameters(inParams) {
    const inParamsDef = [];
    for (const inParam of inParams) {
      inParamsDef.push(...this.generateParameter(inParam));
    }
    return inParamsDef;
  }
  /**
   * Adds documentation comments
   * @see https://github.com/microsoft/tsdoc
   * @param lines
   * @param indentCount
   */
  addTSDocCommentLines(lines, indentCount = 0) {
    return addTSDocCommentLines(lines, indentCount);
  }
  /**
   * Adds the documentation as comments
   * @see https://github.com/microsoft/tsdoc
   * @param girDoc
   * @param indentCount
   * @param overwriteDoc
   * @returns
   */
  addGirDocComment(tsDoc, tags = [], indentCount = 0) {
    const desc = [];
    const indent = generateIndent(indentCount);
    if (this.config.noComments) {
      return desc;
    }
    const text = tsDoc ? transformGirDocText(tsDoc) : null;
    if (text) {
      desc.push(`${indent}/**`);
      if (text) {
        const lines = text.split("\n");
        if (lines.length) {
          for (const line of lines) {
            desc.push(`${indent} * ${line}`);
          }
        }
      }
      for (const tag of tags) {
        if (tag.paramName) {
          desc.push(`${indent} * @${tag.tagName} ${tag.paramName} ${tag.text}`);
        } else {
          desc.push(`${indent} * @${tag.tagName} ${tag.text}`);
        }
      }
      desc.push(`${indent} */`);
    }
    return desc;
  }
  /**
   * Adds an info comment, is used for debugging the generated types
   * @param comment
   * @param indentCount
   * @returns
   */
  addInfoComment(comment, indentCount = 0) {
    const def = [];
    if (this.config.noComments) {
      return def;
    }
    const indent = generateIndent(indentCount);
    if (comment) {
      def.push("");
      def.push(`${indent}// ${comment}`);
      def.push("");
    }
    return def;
  }
  mergeDescs(descs, comment, indentCount = 1) {
    const def = [];
    const indent = generateIndent(indentCount);
    for (const desc of descs) {
      def.push(`${indent}${desc}`);
    }
    if (def.length > 0) {
      def.unshift(...addInfoComment(comment, indentCount));
    }
    return def;
  }
  generateParameter(tsParam) {
    const types = tsParam.type;
    const name = tsParam.name;
    const typeStr = this.generateDirectedType(types, "in" /* In */);
    const optional = tsParam.isOptional && !tsParam.isVarArgs;
    const affix = optional ? "?" : "";
    const prefix = tsParam.isVarArgs ? "..." : "";
    return [`${prefix}${name}${affix}: ${typeStr}`];
  }
  /**
   *
   * @param tsGenerics
   * @param isOut If this generic parameters are out do only generate the type parameter names
   * @returns
   */
  generateGenericParameters(nodes, withDefaults = true) {
    const { namespace, options: options2 } = this;
    const list2 = nodes.map((generic) => {
      const Type = generic.type.rootPrint(namespace, options2);
      if (generic.defaultType && withDefaults) {
        const defaultType = generic.defaultType.rootPrint(namespace, options2);
        if (generic.constraint) {
          const constraint = generic.constraint.rootPrint(namespace, options2);
          return `${Type} extends ${constraint} = ${defaultType}`;
        }
        return `${Type} = ${defaultType}`;
      } else if (generic.constraint && withDefaults) {
        const constraint = generic.constraint.rootPrint(namespace, options2);
        return `${Type} extends ${constraint}`;
      } else {
        return `${Type}`;
      }
    });
    if (list2.length > 0) {
      return `<${list2.join(", ")}>`;
    }
    return "";
  }
  generateFunctionReturn(tsFunction) {
    if (tsFunction.name === "constructor") {
      return "";
    }
    const typeStr = this.generateDirectedType(tsFunction.return(), "out" /* Out */);
    const outputParameters = tsFunction.output_parameters;
    if (outputParameters.length > 0) {
      const excludeActualReturnValueFromArray = typeStr === "void" || typeStr === "";
      const returns = [
        ...excludeActualReturnValueFromArray ? [] : [`${typeStr}`],
        ...outputParameters.map((op) => {
          return resolveDirectedType(op.type, "out" /* Out */)?.resolve(this.namespace, this.options) ?? op.type.resolve(this.namespace, this.options);
        }).map((p) => p.rootPrint(this.namespace, this.options))
      ];
      if (returns.length > 1) {
        return `[${returns.join(", ")}]`;
      } else {
        return `${returns[0]}`;
      }
    }
    return typeStr;
  }
  generateClassFunction(node) {
    return this.generateFunction(node);
  }
  generateFunction(tsFunction, indentCount = 0) {
    const def = [];
    const indent = generateIndent(indentCount);
    let { name } = tsFunction;
    const isStatic = tsFunction instanceof IntrospectedStaticClassFunction;
    const isGlobal = !(tsFunction instanceof IntrospectedClassFunction);
    const isArrowType = tsFunction instanceof IntrospectedCallback || tsFunction instanceof IntrospectedClassCallback;
    const { parameters: inParams } = tsFunction;
    if (tsFunction.doc)
      def.push(
        ...this.addGirDocComment(
          tsFunction.doc,
          [
            ...this.namespace.getTsDocInParamTags(tsFunction.parameters),
            ...this.namespace.getTsDocReturnTags(tsFunction)
          ],
          indentCount
        )
      );
    const warning = tsFunction.getWarning();
    if (warning) def.push(warning);
    const staticStr = isStatic && tsFunction.name !== "constructor" ? "static " : "";
    const globalStr = isGlobal ? "function " : "";
    const genericStr = this.generateGenericParameters(tsFunction.generics);
    const commentOut = "";
    let exportStr = "";
    if (isGlobal) {
      exportStr = !this.config.noNamespace ? "" : "export ";
    }
    const returnType = this.generateFunctionReturn(tsFunction);
    let retSep = "";
    if (returnType) {
      if (isArrowType) {
        name = "";
        retSep = " =>";
      } else {
        retSep = ":";
      }
    }
    if (isInvalid(name) && !isGlobal) {
      name = `["${name}"]`;
    }
    const inParamsDef = this.generateInParameters(inParams);
    def.push(
      `${indent}${commentOut}${exportStr}${staticStr}${globalStr}${name}${genericStr}(${inParamsDef.join(
        ", "
      )})${retSep} ${returnType}`
    );
    return def;
  }
  generateFunctions(tsFunctions, indentCount = 1, comment) {
    const def = [];
    for (const girFunction of tsFunctions) {
      def.push(...this.generateFunction(girFunction, indentCount));
    }
    if (def.length > 0) {
      def.unshift(...addInfoComment(comment, indentCount));
    }
    return def;
  }
  generateCallback(tsCallback, indentCount = 0, classModuleName) {
    const def = [];
    def.push(...this.addGirDocComment(tsCallback.doc, [], indentCount));
    const indent = generateIndent(indentCount);
    const indentBody = generateIndent(indentCount + 1);
    const { parameters: inParams } = tsCallback;
    const returnTypeStr = this.generateType(tsCallback.return());
    let { name } = tsCallback;
    const generics = tsCallback.generics;
    name = removeNamespace(name, tsCallback.namespace.namespace);
    if (classModuleName) name = removeClassModule(name, classModuleName);
    const genericParameters = this.generateGenericParameters(generics);
    const inParamsDef = this.generateInParameters(inParams);
    const interfaceHead = `${name}${genericParameters}`;
    def.push(this.generateExport("interface", `${interfaceHead}`, "{", indentCount));
    def.push(`${indentBody}(${inParamsDef.join(", ")}): ${returnTypeStr}`);
    def.push(`${indent}}`);
    return def;
  }
  generateCallbackInterfaces(tsCallbacks, indentCount = 0, classModuleName, comment) {
    const def = [];
    for (const tsCallback of tsCallbacks) {
      def.push(...this.generateCallback(tsCallback, indentCount, classModuleName), "");
    }
    if (def.length > 0) {
      def.unshift(...addInfoComment(comment, indentCount));
    }
    return def;
  }
  generateEnum(girEnum, indentCount = 0) {
    const desc = [];
    const { name, namespace } = girEnum;
    desc.push(...this.addGirDocComment(girEnum.doc, [], indentCount));
    const isInvalidEnum = Array.from(girEnum.members.keys()).some(
      (name2) => name2.match(/^[0-9]+$/) || name2 === "NaN" || name2 === "Infinity"
    );
    if (isInvalidEnum) {
      desc.push(...girEnum.asClass().asString(this));
      return desc;
    }
    desc.push("");
    desc.push(...this.addGirDocComment(girEnum.doc, [], indentCount));
    desc.push(`export namespace ${name} {`);
    const gtypeNamespace = namespace.namespace === "GObject" ? "" : "GObject.";
    desc.push(`    export const $gtype: ${gtypeNamespace}GType<${name}>;`);
    desc.push("}");
    desc.push("");
    desc.push(this.generateExport("enum", name, "{", indentCount));
    if (girEnum.members) {
      for (const girEnumMember of girEnum.members.values()) {
        if (!girEnumMember) continue;
        desc.push(...this.generateEnumMember(girEnumMember, indentCount + 1));
      }
    }
    desc.push("}");
    return desc;
  }
  generateEnumMember(tsMember, indentCount = 1) {
    const desc = [];
    desc.push(...this.addGirDocComment(tsMember.doc, [], indentCount));
    const invalid = isInvalid(tsMember.name);
    const indent = generateIndent(indentCount);
    if (invalid) {
      desc.push(`${indent}"${tsMember.name}",`);
    } else {
      desc.push(`${indent}${tsMember.name},`);
    }
    return desc;
  }
  generateConst(tsConst, indentCount = 0) {
    const desc = [];
    desc.push(...this.addGirDocComment(tsConst.doc, [], indentCount));
    const indent = generateIndent(indentCount);
    const exp = !this.config.noNamespace ? "" : "export ";
    const ComputedName = generateMemberName(tsConst);
    const typeStr = this.generateType(tsConst.type);
    desc.push(`${indent}${exp}const ${ComputedName}: ${typeStr}`);
    return desc;
  }
  generateAlias(girAlias, indentCount = 0) {
    const { namespace, options: options2 } = this;
    const desc = [];
    const indent = generateIndent(indentCount);
    const genericList = girAlias.generics.map((g) => {
      if (g.type) {
        return `${g.name} = ${g.type.resolve(namespace, options2).rootPrint(namespace, options2)}`;
      }
      return `${g.name}`;
    }).join(", ");
    const generics = genericList ? `<${genericList}>` : "";
    const exp = !this.config.noNamespace ? "" : "export ";
    desc.push(`${indent}${exp}type ${girAlias.name}${generics} = ${girAlias.type.print(this.namespace, this.config)}`);
    return desc;
  }
  generateConstructPropsInterface(girClass, indentCount = 0) {
    const def = [];
    const isGObjectObject = girClass.name === "Object" && girClass.namespace.namespace === "GObject";
    if (!isGObjectObject && !girClass.someParent((p) => p.namespace.namespace === "GObject" && p.name === "Object")) {
      return def;
    }
    const indent = generateIndent(indentCount);
    const exp = !this.config.noNamespace ? "" : "export ";
    let ext = "";
    const resolution = girClass.resolveParents();
    const superType = girClass.superType;
    const superTypeIdentifier = superType?.resolveIdentifier(this.namespace, this.config)?.print(this.namespace, this.config);
    const genericTypes = this.generateGenericParameters(girClass.generics);
    const constructPropInterfaceName = "ConstructorProps";
    if (superTypeIdentifier) {
      const interfaceExtends = "implements" in resolution ? resolution.implements().map(
        (iface) => iface.identifier.resolveIdentifier(this.namespace, this.config)?.print(this.namespace, this.config)
      ).filter((identifier) => !!identifier).map((identifier) => {
        const identifierParts = identifier.split("<");
        const generics2 = identifierParts.length > 1 ? `<${identifierParts[1]}` : "";
        return `${identifierParts[0]}.${constructPropInterfaceName}${generics2}`;
      }) : [];
      const superTypeIdentifierParts = superTypeIdentifier.split("<");
      const generics = superTypeIdentifierParts.length > 1 ? `<${superTypeIdentifierParts[1]}` : "";
      const superTypeExtends = `${superTypeIdentifierParts[0]}.${constructPropInterfaceName}${generics}`;
      ext = `extends ${[superTypeExtends, ...interfaceExtends].join(", ")}`;
    }
    def.push(...addInfoComment("Constructor properties interface", indentCount));
    const { props } = girClass;
    const ConstructorProps = filterConflicts(girClass.namespace, girClass, props, 1 /* PRESERVE */).flatMap((v) => v.asString(this, true)).join("\n    ");
    def.push(`${indent}${exp}interface ${constructPropInterfaceName}${genericTypes} ${ext} {`);
    def.push(ConstructorProps);
    def.push(`${indent}}`, "");
    return def;
  }
  generateClassStaticFields(girClass, indentCount = 1) {
    const def = [];
    def.push(
      ...this.generateFields(
        filterConflicts(
          girClass.namespace,
          girClass,
          girClass.fields.filter((field) => field.isStatic)
        ),
        "Static fields",
        indentCount
      )
    );
    return def;
  }
  generateClassSignalsProperty(girClass, indentCount = 1) {
    const def = [];
    const isGObjectObject = girClass.name === "Object" && girClass.namespace.namespace === "GObject";
    const hasGObjectParent = isGObjectObject || girClass.someParent((p) => p.namespace.namespace === "GObject" && p.name === "Object");
    if (hasGObjectParent) {
      def.push(
        "",
        `${generateIndent(indentCount)}/**`,
        `${generateIndent(indentCount)} * Compile-time signal type information.`,
        `${generateIndent(indentCount)} *`,
        `${generateIndent(indentCount)} * This instance property is generated only for TypeScript type checking.`,
        `${generateIndent(indentCount)} * It is not defined at runtime and should not be accessed in JS code.`,
        `${generateIndent(indentCount)} * @internal`,
        `${generateIndent(indentCount)} */`,
        `${generateIndent(indentCount)}$signals: ${girClass.name}.SignalSignatures;`,
        ""
      );
    }
    return def;
  }
  generateClassMemberFields(girClass, indentCount = 1) {
    const def = [];
    def.push(
      ...this.generateFields(
        filterConflicts(
          girClass.namespace,
          girClass,
          girClass.fields.filter((field) => !field.isStatic)
        ),
        "Fields",
        indentCount
      )
    );
    return def;
  }
  generateClassFields(girClass, indentCount = 1) {
    const def = [];
    def.push(
      ...this.generateClassStaticFields(girClass, indentCount),
      ...this.generateClassMemberFields(girClass, indentCount)
    );
    return def;
  }
  generateClassProperties(girClass, indentCount = 1) {
    const def = [];
    def.push(
      ...this.generateProperties(
        filterConflicts(girClass.namespace, girClass, girClass.props),
        "Properties",
        indentCount
      )
    );
    return def;
  }
  generateClassStaticMethods(girClass, indentCount = 1) {
    const def = [];
    def.push(
      ...this.generateFunctions(
        filterFunctionConflict(
          girClass.parent,
          girClass,
          [...girClass.members].filter((member) => member instanceof IntrospectedStaticClassFunction),
          []
        ),
        indentCount,
        "Static methods"
      )
    );
    return def;
  }
  generateClassMethods(girClass, indentCount = 1) {
    const def = [];
    def.push(
      ...this.generateFunctions(
        promisifyIfEnabled(
          this.options,
          filterFunctionConflict(
            girClass.parent,
            girClass,
            [...girClass.members].filter(
              (member) => !(member instanceof IntrospectedStaticClassFunction) && !(member instanceof IntrospectedVirtualClassFunction)
            ),
            []
          )
        ),
        indentCount,
        "Methods"
      )
    );
    return def;
  }
  generateClassConstructors(girClass, indentCount = 1) {
    const def = [];
    if (girClass.mainConstructor instanceof IntrospectedDirectAllocationConstructor)
      def.push(...this.generateDirectAllocationConstructor(girClass.mainConstructor));
    else if (girClass.mainConstructor instanceof IntrospectedConstructor)
      def.push(...this.generateConstructor(girClass.mainConstructor));
    else if (girClass.someParent((p) => p.namespace.namespace === "GObject" && p.name === "Object"))
      def.push(`
constructor(properties?: Partial<${girClass.name}.ConstructorProps>, ...args: any[]);
`);
    if (!girClass.__ts__indexSignature || girClass.__ts__indexSignature.includes("[key: string]: any")) {
      def.push("_init(...args: any[]): void;\n");
    }
    def.push(
      ...filterFunctionConflict(girClass.parent, girClass, girClass.constructors, []).flatMap(
        (constructorFunction) => this.generateConstructorFunction(constructorFunction)
      )
    );
    if (def.length) {
      def.unshift(...addInfoComment("Constructors", indentCount));
    }
    return def;
  }
  /**
   * Instance methods, vfunc_ prefix
   * @param girClass
   */
  generateClassVirtualMethods(girClass, indentCount = 1) {
    const def = [];
    def.push(
      ...this.generateFunctions(
        filterFunctionConflict(
          girClass.parent,
          girClass,
          [...girClass.members.values()].filter((fn) => fn instanceof IntrospectedVirtualClassFunction),
          []
        ),
        indentCount,
        "Virtual methods"
      )
    );
    return def;
  }
  generateClassSignalInterfaces(girClass, indentCount = 0) {
    const def = [];
    const _tsSignals = girClass.signals;
    def.push(...this.generateSignalSignatures(girClass, indentCount));
    return def;
  }
  /**
   * Generate SignalSignatures interface for type-safe signal handling
   *
   * This creates a comprehensive mapping of signal names to their callback types,
   * enabling TypeScript to provide proper type checking and IntelliSense for
   * GObject signals using the centralized getAllSignals() method from the model.
   */
  generateSignalSignatures(girClass, indentCount = 0) {
    const def = [];
    const indent = generateIndent(indentCount);
    def.push(`${indent}// Signal signatures`);
    def.push(`${indent}interface SignalSignatures`);
    const parentSignatures = [];
    const parentResolution = girClass.resolveParents().extends();
    if (parentResolution && parentResolution.node instanceof IntrospectedClass) {
      const parentClass = parentResolution.node;
      const parentTypeIdentifier = parentResolution.identifier.resolveIdentifier(this.namespace, this.config)?.print(this.namespace, this.config);
      const hasSignalMethods = parentClass.signals?.length > 0;
      const isNotTemplateWorkaround = !(this.namespace.namespace === "Gimp" && ["ParamObject", "ParamItem", "ParamArray"].includes(parentClass.name));
      if (parentTypeIdentifier && (hasSignalMethods || isNotTemplateWorkaround)) {
        parentSignatures.push(`${parentTypeIdentifier}.SignalSignatures`);
      }
    }
    const interfaceSignatures = girClass.resolveParents().implements().filter((iface) => iface.node instanceof IntrospectedInterface).filter((iface) => {
      const node = iface.node;
      return node.signals && node.signals.length > 0;
    }).map((iface) => {
      const interfaceTypeIdentifier = iface.identifier.resolveIdentifier(this.namespace, this.config)?.print(this.namespace, this.config);
      return interfaceTypeIdentifier ? `${interfaceTypeIdentifier}.SignalSignatures` : null;
    }).filter((sig) => !!sig);
    parentSignatures.push(...interfaceSignatures);
    if (parentSignatures.length > 0) {
      def.push(` extends ${parentSignatures.join(", ")} {`);
    } else {
      const isGObjectObject = girClass.name === "Object" && girClass.namespace.namespace === "GObject";
      if (isGObjectObject) {
        def.push(" {");
      } else {
        const gobjectNamespace = this.namespace.assertInstalledImport("GObject");
        const gobjectObjectClass = gobjectNamespace.assertClass("Object");
        const gobjectRef = gobjectObjectClass.getType().resolveIdentifier(this.namespace, this.config)?.print(this.namespace, this.config);
        const fallbackRef = gobjectRef ? `${gobjectRef}.SignalSignatures` : "GObject.Object.SignalSignatures";
        def.push(` extends ${fallbackRef} {`);
      }
    }
    const allSignals = girClass.getAllSignals();
    allSignals.forEach((signalInfo) => {
      const signalKey = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(signalInfo.name) ? signalInfo.name : `"${signalInfo.name}"`;
      let cbType;
      if (signalInfo.isNotifySignal) {
        const gobjectRef = this.namespace.namespace === "GObject" ? "" : "GObject.";
        cbType = `(pspec: ${gobjectRef}ParamSpec) => void`;
      } else if (signalInfo.signal) {
        const paramTypes = signalInfo.signal.parameters.map((p, idx) => `arg${idx}: ${this.generateType(p.type)}`).join(", ");
        let returnType = signalInfo.signal.return_type;
        if (signalInfo.signal.return_type.equals(BooleanType)) {
          returnType = new BinaryType(BooleanType, VoidType);
        }
        const returnTypeStr = this.generateType(returnType);
        cbType = `(${paramTypes}) => ${returnTypeStr}`;
      } else {
        const paramTypes = signalInfo.parameterTypes?.map((type, idx) => `arg${idx}: ${type}`) || [];
        const returnTypeStr = signalInfo.returnType || "void";
        cbType = `(${paramTypes.join(", ")}) => ${returnTypeStr}`;
      }
      def.push(`${indent}    ${signalKey}: ${cbType};`);
    });
    def.push(`${indent}}`);
    def.push("");
    return def;
  }
  generateSignals(girClass) {
    const signalFunctions = [
      new IntrospectedClassFunction({
        name: "connect",
        parent: girClass,
        parameters: [],
        return_type: NumberType
      }),
      new IntrospectedClassFunction({
        name: "connect_after",
        parent: girClass,
        parameters: [],
        return_type: NumberType
      }),
      new IntrospectedClassFunction({
        name: "emit",
        parent: girClass,
        parameters: [],
        return_type: VoidType
      })
    ];
    const filteredFunctions = filterConflicts(girClass.namespace, girClass, signalFunctions, 0 /* DELETE */);
    const allowedNames = new Set(filteredFunctions.map((f) => f.name));
    const gobjectRef = this.namespace.namespace === "GObject" ? "" : "GObject.";
    const methods = [];
    if (allowedNames.has("connect")) {
      methods.push(
        // Type-safe overload for known signals
        `connect<K extends keyof ${girClass.name}.SignalSignatures>(signal: K, callback: ${gobjectRef}SignalCallback<this, ${girClass.name}.SignalSignatures[K]>): number;`,
        // Fallback overload for dynamic signals
        "connect(signal: string, callback: (...args: any[]) => any): number;"
      );
    }
    if (allowedNames.has("connect_after")) {
      methods.push(
        // Type-safe overload for known signals
        `connect_after<K extends keyof ${girClass.name}.SignalSignatures>(signal: K, callback: ${gobjectRef}SignalCallback<this, ${girClass.name}.SignalSignatures[K]>): number;`,
        // Fallback overload for dynamic signals
        "connect_after(signal: string, callback: (...args: any[]) => any): number;"
      );
    }
    if (allowedNames.has("emit")) {
      methods.push(
        // Type-safe overload for known signals
        `emit<K extends keyof ${girClass.name}.SignalSignatures>(signal: K, ...args: ${gobjectRef}GjsParameters<${girClass.name}.SignalSignatures[K]> extends [any, ...infer Q] ? Q : never): void;`,
        // Fallback overload for dynamic signals
        "emit(signal: string, ...args: any[]): void;"
      );
    }
    return methods;
  }
  generateClassSignals(girClass) {
    const def = [];
    const signalDescs = this.generateSignals(girClass);
    def.push(...mergeDescs(signalDescs, "Signals", 1));
    return def;
  }
  generateClassNamespaces(girClass, indentCount = 0) {
    const def = [];
    const bodyDef = [];
    if (!girClass) return def;
    const indent = generateIndent(indentCount);
    const exp = !this.config.noNamespace ? "" : "export ";
    if (girClass instanceof IntrospectedClass) {
      bodyDef.push(...this.generateClassSignalInterfaces(girClass, indentCount + 1));
    }
    bodyDef.push(...this.generateClassCallbacks(girClass));
    bodyDef.push(...this.generateConstructPropsInterface(girClass, indentCount + 1));
    if (!bodyDef.length) {
      return [];
    }
    def.push(`${indent}${exp}namespace ${girClass.name} {`);
    def.push(...bodyDef);
    def.push(`${indent}}`, "");
    return def;
  }
  generateClassCallbacks(girClass) {
    if (girClass.callbacks.length === 0) return [];
    return girClass.callbacks.flatMap((c) => this.generateClassCallback(c));
  }
  /**
   * In Typescript, interfaces and classes can have the same name,
   * so we use this to generate interfaces with the same name to implement multiple inheritance
   * @param girClass
   * @param namespace
   */
  generateImplementationInterface(girClass) {
    const def = [];
    if (!girClass) return def;
    const genericParameters = this.generateGenericParameters(girClass.generics);
    const resolution = girClass.resolveParents();
    const superType = resolution.extends();
    const implementationNames = [
      ...superType ? [superType.node.getType().print(this.namespace, this.config)] : [],
      ..."implements" in resolution ? resolution.implements().map((i) => i.node.getType().print(this.namespace, this.config)) : []
    ];
    const ext = implementationNames.length ? ` extends ${implementationNames.join(", ")}` : "";
    const interfaceHead = `${girClass.name}${genericParameters}${ext}`;
    def.push(this.generateExport("interface", interfaceHead, "{"));
    if (girClass.__ts__indexSignature) {
      def.push(`
${girClass.__ts__indexSignature}
`);
    }
    def.push(...this.generateClassProperties(girClass));
    def.push(...this.generateClassMemberFields(girClass));
    def.push(...this.generateClassMethods(girClass));
    def.push(...this.generateClassVirtualMethods(girClass));
    def.push("}");
    def.push("");
    return def;
  }
  extends(node) {
    const { namespace: ns, options: options2 } = this;
    if (node.superType) {
      const ResolvedType = node.superType.resolveIdentifier(ns, options2);
      const Type = ResolvedType?.print(ns, options2);
      if (Type) {
        return ` extends ${Type}`;
      }
      throw new Error(
        `Unable to resolve type: ${node.superType.name} from ${node.superType.namespace} in ${node.namespace.namespace} ${node.namespace.version}, falling back to GObject.Object`
      );
    }
    return "";
  }
  implements(node) {
    const { namespace, options: options2 } = this;
    const interfaces = node.interfaces.map((i) => {
      const identifier = i.resolveIdentifier(namespace, options2);
      if (!identifier) {
        throw new Error(
          `Unable to resolve type: ${i.name} from ${i.namespace} in ${node.namespace.namespace} ${node.namespace.version}`
        );
      }
      return identifier;
    });
    if (interfaces.length > 0) {
      return ` implements ${interfaces.map((i) => {
        const Type = i.print(namespace, options2);
        return `${Type}`;
      }).join(", ")}`;
    }
    return "";
  }
  /**
   * Represents a record, GObject class or interface as a Typescript class
   * @param girClass
   * @param namespace
   */
  generateClass(girClass) {
    const def = [];
    def.push(...this.generateClassNamespaces(girClass));
    def.push(...this.addGirDocComment(girClass.doc, [], 0));
    const genericParameters = this.generateGenericParameters(girClass.generics);
    const ext = this.extends(girClass);
    const impl = girClass instanceof IntrospectedClass ? this.implements(girClass) : "";
    const classHead = `${girClass.name}${genericParameters}${ext}${impl}`;
    {
      const isAbstract = girClass instanceof IntrospectedClass && girClass.isAbstract;
      const isOpaque = girClass instanceof IntrospectedRecord && girClass.isPrivate && !girClass.mainConstructor;
      if (isAbstract || isOpaque) {
        def.push(this.generateExport("abstract class", classHead, "{"));
      } else {
        def.push(this.generateExport("class", classHead, "{"));
      }
      const gtypeNamespace = this.namespace.namespace === "GObject" ? "" : "GObject.";
      def.push(`static $gtype: ${gtypeNamespace}GType<${girClass.name}>;`);
      if (girClass.__ts__indexSignature) {
        def.push(`
${girClass.__ts__indexSignature}
`);
      }
      def.push(...this.generateClassProperties(girClass));
      def.push(...this.generateClassSignalsProperty(girClass));
      def.push(...this.generateClassFields(girClass));
      def.push(...this.generateClassConstructors(girClass));
      if (girClass instanceof IntrospectedClass) {
        def.push(...this.generateClassSignals(girClass));
      }
      def.push(...this.generateClassStaticMethods(girClass));
      def.push(...this.generateClassVirtualMethods(girClass));
      def.push(...this.generateClassMethods(girClass));
      if (girClass instanceof IntrospectedClass) {
        const implementedProperties = girClass.implementedProperties().map((prop) => prop.copy({ parent: girClass }));
        const implementedMethods = girClass.implementedMethods(implementedProperties).map((method) => method.copy({ parent: girClass }));
        const generatedImplementedProperties = filterConflicts(
          girClass.namespace,
          girClass,
          implementedProperties
        ).flatMap((m) => m.asString(this));
        if (generatedImplementedProperties.length > 0)
          def.push("\n// Inherited properties", ...generatedImplementedProperties);
        const filteredImplMethods = promisifyIfEnabled(
          this.options,
          filterFunctionConflict(girClass.namespace, girClass, implementedMethods, [])
        );
        const generatedImplementedMethods = filteredImplMethods.flatMap((m) => m.asString(this));
        if (generatedImplementedMethods.length > 0) def.push("\n// Inherited methods", ...generatedImplementedMethods);
      }
      def.push("}");
      def.push("");
    }
    return def;
  }
  async stringifyNamespace(node) {
    const result = await this.generateNamespace(node);
    return result?.join("\n") ?? null;
  }
  /**
   * Generates a namespace as a string (similar to DtsGenerator)
   */
  async generateNamespaceString(node) {
    const result = await this.generateNamespace(node);
    return result?.join("\n") ?? null;
  }
  /**
   * Generates a module declaration (similar to DtsModuleGenerator)
   */
  async generateModuleDeclaration(node) {
    try {
      this.log.debug(`Resolving the types of ${node.namespace}...`);
      const result = await this.generateModule(node);
      if (!result) {
        this.log.reportGenerationFailure(node.namespace, new Error("Failed to generate module"), "Module Declaration");
        return null;
      }
      const content = result.join("\n");
      return this.wrapInModuleDeclaration(content, node);
    } catch (err) {
      this.log.reportGenerationFailure(node.namespace, err, "Module Declaration");
      return null;
    }
  }
  /**
   * Generates inline DTS content (similar to DtsInlineGenerator)
   */
  async generateInline(node) {
    try {
      this.log.debug(`Resolving the types of ${node.namespace}...`);
      const { namespace: name, version } = node.dependency;
      const header = `
/**
 * ${name} ${version}
 * 
 * Generated from ${node.package_version.join(".")}
 */
`;
      const base = `

`;
      const result = await this.generateModule(node);
      if (!result) {
        this.log.reportGenerationFailure(node.namespace, new Error("Failed to generate inline content"), "DTS Inline");
        return null;
      }
      const content = result.join("\n");
      const output = [header, base, content].join("\n\n");
      this.log.debug(`Printing ${node.namespace}...`);
      return output;
    } catch (err) {
      this.log.reportGenerationFailure(node.namespace, err, "DTS Inline");
      return null;
    }
  }
  async exportModuleIndexJS() {
    const template = "index.js";
    const target = "index.js";
    if (this.config.outdir) {
      await this.moduleTemplateProcessor.create(template, this.config.outdir, target);
    } else {
      const { append, prepend } = await this.moduleTemplateProcessor.load(template);
      this.log.log(append + prepend);
    }
  }
  async exportModuleIndexTS() {
    const template = "index.d.ts";
    const target = "index.d.ts";
    if (this.config.outdir) {
      await this.moduleTemplateProcessor.create(template, this.config.outdir, target);
    } else {
      const { append, prepend } = await this.moduleTemplateProcessor.load(template);
      this.log.log(append + prepend);
    }
  }
  async exportModuleJS(girModule) {
    const template = "module.js";
    const target = `${girModule.importName}.js`;
    if (this.config.outdir) {
      await this.moduleTemplateProcessor.create(template, this.config.outdir, target);
    } else {
      const { append, prepend } = await this.moduleTemplateProcessor.load(template);
      this.log.log(append + prepend);
    }
  }
  async exportModuleAmbientTS(girModule) {
    const template = "module-ambient.d.ts";
    const target = `${girModule.importName}-ambient.d.ts`;
    if (this.config.outdir) {
      await this.moduleTemplateProcessor.create(template, this.config.outdir, target);
    } else {
      const { append, prepend } = await this.moduleTemplateProcessor.load(template);
      this.log.log(append + prepend);
    }
  }
  async exportModuleAmbientJS(girModule) {
    const template = "module-ambient.js";
    const target = `${girModule.importName}-ambient.js`;
    if (this.config.outdir) {
      await this.moduleTemplateProcessor.create(template, this.config.outdir, target);
    } else {
      const { append, prepend } = await this.moduleTemplateProcessor.load(template);
      this.log.log(append + prepend);
    }
  }
  async exportModuleImportTS(girModule) {
    const template = "module-import.d.ts";
    const target = `${girModule.importName}-import.d.ts`;
    if (this.config.outdir) {
      await this.moduleTemplateProcessor.create(template, this.config.outdir, target);
    } else {
      const { append, prepend } = await this.moduleTemplateProcessor.load(template);
      this.log.log(append + prepend);
    }
  }
  async exportModuleImportJS(girModule) {
    const template = "module-import.js";
    const target = `${girModule.importName}-import.js`;
    if (this.config.outdir) {
      await this.moduleTemplateProcessor.create(template, this.config.outdir, target);
    } else {
      const { append, prepend } = await this.moduleTemplateProcessor.load(template);
      this.log.log(append + prepend);
    }
  }
  async exportModuleTS() {
    const { namespace: girModule } = this;
    const template = "module.d.ts";
    const explicitTemplate = `${girModule.importName}.d.ts`;
    const target = explicitTemplate;
    const output = await this.generateModule(girModule);
    if (!output) {
      this.log.error("Failed to generate gir module");
      return;
    }
    const outputArray = output;
    if (await this.moduleTemplateProcessor.exists(explicitTemplate)) {
      const { append: appendExplicit, prepend: prependExplicit } = await this.moduleTemplateProcessor.load(explicitTemplate);
      outputArray.unshift(prependExplicit);
      outputArray.push(appendExplicit);
    }
    const { append, prepend } = await this.moduleTemplateProcessor.load(template);
    outputArray.unshift(prepend);
    outputArray.push(append);
    if (this.config.outdir) {
      await this.moduleTemplateProcessor.write(outputArray.join("\n"), this.config.outdir, target);
    } else {
      this.log.log(outputArray.join("\n"));
    }
  }
  async generateModule(girModule) {
    const out = [];
    out.push(...this.addTSDocCommentLines([girModule.packageName]));
    out.push("");
    if (this.options.promisify) {
      promisifyNamespaceFunctions(girModule);
    }
    let overrideSuffix = "";
    if (!this.options.noAdvancedVariants && girModule.namespace === "GLib") {
      overrideSuffix = override(girModule);
    } else if (girModule.namespace === "GObject") {
      overrideSuffix = override2(girModule);
    }
    if (girModule.members) {
      for (const m of girModule.members.values()) {
        out.push(
          ...(Array.isArray(m) ? m : [m]).flatMap((m2) => m2 ?? []).filter((m2) => m2.emit).flatMap((m2) => m2.asString(this) ?? "")
        );
      }
    }
    out.push(
      ...this.generateConst(
        new IntrospectedConstant({
          // TODO:
          doc: printGirDocComment(
            {
              text: "Name of the imported GIR library",
              tags: [
                {
                  text: "https://gitlab.gnome.org/GNOME/gjs/-/blob/master/gi/ns.cpp#L188",
                  tagName: "see",
                  paramName: ""
                }
              ]
            },
            this.config
          ),
          namespace: this.namespace,
          value: null,
          name: "__name__",
          type: new NativeType("string")
          // isInjected: false,
          // tsTypeName: 'constant',
          // girTypeName: 'constant',
        }),
        0
      ),
      ...this.generateConst(
        new IntrospectedConstant({
          doc: printGirDocComment(
            {
              text: "Version of the imported GIR library",
              tags: [
                {
                  text: "https://gitlab.gnome.org/GNOME/gjs/-/blob/master/gi/ns.cpp#L189",
                  tagName: "see",
                  paramName: ""
                }
              ]
            },
            this.config
          ),
          namespace: this.namespace,
          name: "__version__",
          type: new NativeType("string"),
          value: null
        }),
        0
      )
    );
    if (overrideSuffix) {
      out.push("", overrideSuffix);
    }
    return Promise.resolve(out);
  }
  /**
   * Generates a namespace for the given GirModule.
   * @deprecated Use `generateModule` instead @ewlsh
   * @param girModule The GirModule to generate a namespace for.
   * @returns A promise that resolves to the generated namespace.
   */
  async generateNamespace(girModule) {
    const out = await this.generateModule(girModule);
    if (!this.config.noNamespace) {
      return Promise.resolve(out);
    }
    out.unshift("");
    out.unshift(`export namespace ${girModule.namespace} {`);
    out.unshift("");
    out.push("}");
    out.push("");
    out.push(`export default ${girModule.namespace};`);
    return Promise.resolve(out);
  }
  /**
   * Generates a module as a single string (DTS compatibility)
   */
  async generateModuleString(girModule) {
    const result = await this.generateModule(girModule);
    return result.join("\n");
  }
  /**
   * Generates a namespace as a single string (DTS compatibility)
   */
  async generateNamespaceAsString(girModule) {
    const result = await this.generateNamespace(girModule);
    return result.join("\n");
  }
  async exportModule(_registry, girModule) {
    await this.exportModuleTS();
    if (this.config.package) {
      await this.exportModuleJS(girModule);
      await this.exportModuleIndexTS();
      await this.exportModuleIndexJS();
      await this.exportModuleAmbientTS(girModule);
      await this.exportModuleAmbientJS(girModule);
      await this.exportModuleImportTS(girModule);
      await this.exportModuleImportJS(girModule);
      const pkg = new NpmPackage(
        this.config,
        this.dependencyManager,
        _registry,
        girModule,
        girModule.transitiveDependencies
      );
      await pkg.exportNPMPackage();
    }
  }
};
function promisifyIfEnabled(options2, functions) {
  if (options2.promisify) {
    return promisifyFunctions(functions);
  }
  return functions;
}

// ../generator-typescript/src/type-definition-generator.ts
var TypeDefinitionGenerator = class _TypeDefinitionGenerator {
  log;
  //readonly moduleGenerator!: ModuleGenerator
  config;
  registry;
  dependencyManager;
  //readonly packageData: PackageDataParser
  constructor(config, registry) {
    this.config = config;
    this.registry = registry;
    this.log = new ConsoleReporter(
      this.config.verbose,
      _TypeDefinitionGenerator.name,
      this.config.reporter,
      this.config.reporterOutput
    );
    if (this.config.reporter) {
      const reporterService = ReporterService.getInstance();
      reporterService.registerReporter(_TypeDefinitionGenerator.name, this.log);
    }
    this.dependencyManager = DependencyManager.getInstance(this.config);
  }
  async exportGjs() {
    const { config, dependencyManager } = this;
    if (!config.outdir) return;
    const gjs = dependencyManager.getGjs();
    const templateProcessor = new TemplateProcessor(
      {},
      gjs.packageName,
      this.registry,
      await dependencyManager.core(),
      config
    );
    if (this.config.package) {
      await templateProcessor.create("index.d.ts", config.outdir, "index.d.ts", void 0, void 0, {
        name: gjs.importName
      });
      await templateProcessor.create("index.js", config.outdir, "index.js", void 0, void 0, {
        name: gjs.importName
      });
      await templateProcessor.create("gjs/gjs.d.ts", config.outdir, "gjs.d.ts");
      await templateProcessor.create("gjs/gjs.js", config.outdir, "gjs.js");
      await templateProcessor.create("gjs/dom.d.ts", config.outdir, "dom.d.ts");
      await templateProcessor.create("gjs/dom.js", config.outdir, "dom.js");
      await templateProcessor.create("gjs/gettext.d.ts", config.outdir, "gettext.d.ts");
      await templateProcessor.create("gjs/gettext.js", config.outdir, "gettext.js");
      await templateProcessor.create("gjs/system.d.ts", config.outdir, "system.d.ts");
      await templateProcessor.create("gjs/system.js", config.outdir, "system.js");
      await templateProcessor.create("gjs/cairo.d.ts", config.outdir, "cairo.d.ts");
      await templateProcessor.create("gjs/cairo.js", config.outdir, "cairo.js");
      await templateProcessor.create("gjs/console.d.ts", config.outdir, "console.d.ts");
      await templateProcessor.create("gjs/console.js", config.outdir, "console.js");
      await templateProcessor.create("gjs/gjs-ambient.d.ts", config.outdir, "gjs-ambient.d.ts");
      await templateProcessor.create("gjs/gjs-ambient.js", config.outdir, "gjs-ambient.js");
      const pkg = new NpmPackage(config, dependencyManager, this.registry, gjs, await dependencyManager.core());
      await pkg.exportNPMPackage();
    } else {
      const gjsContent = await templateProcessor.load("gjs/gjs.d.ts");
      await templateProcessor.write(`${gjsContent.prepend}
${gjsContent.append}`, config.outdir, "gjs.d.ts");
      const gettextContent = await templateProcessor.load("gjs/gettext.d.ts");
      await templateProcessor.write(
        `${gettextContent.prepend}
${gettextContent.append}`,
        config.outdir,
        "gettext.d.ts"
      );
      const systemContent = await templateProcessor.load("gjs/system.d.ts");
      await templateProcessor.write(`${systemContent.prepend}
${systemContent.append}`, config.outdir, "system.d.ts");
      const cairoContent = await templateProcessor.load("gjs/cairo.d.ts");
      await templateProcessor.write(`${cairoContent.prepend}
${cairoContent.append}`, config.outdir, "cairo.d.ts");
      const consoleContent = await templateProcessor.load("gjs/console.d.ts");
      await templateProcessor.write(
        `${consoleContent.prepend}
${consoleContent.append}`,
        config.outdir,
        "console.d.ts"
      );
      const domContent = await templateProcessor.load("gjs/dom.d.ts");
      await templateProcessor.write(`${domContent.prepend}
${domContent.append}`, config.outdir, "dom.d.ts");
    }
  }
  async exportAllModules(girModules) {
    const { config, dependencyManager } = this;
    if (config.package) {
      throw new Error("Export all modules is not implemented for package.json mode");
    }
    if (!config.outdir) return;
    const templateProcessor = new TemplateProcessor(
      { girModules },
      "index",
      this.registry,
      dependencyManager.all(),
      config
    );
    await templateProcessor.create("gi.d.ts", config.outdir, "gi.d.ts");
    await templateProcessor.create("index-locally.d.ts", config.outdir, "index.d.ts");
  }
  async generate(module) {
    const moduleGenerator = new ModuleGenerator(module, this.config, this.registry);
    await moduleGenerator.exportModule(this.registry, module);
  }
  async start() {
  }
  async finish(girModules) {
    await this.exportGjs();
    if (!this.config.package) {
      await this.exportAllModules(girModules);
    }
  }
};

// src/generation-handler.ts
var GenerationHandler = class {
  log;
  generator;
  config;
  registry;
  reporterService;
  constructor(config, type, registry) {
    this.registry = registry;
    this.config = config;
    this.log = new ConsoleReporter(config.verbose, "GenerationHandler", config.reporter, config.reporterOutput);
    this.reporterService = ReporterService.getInstance();
    this.reporterService.configure(config.reporter, config.reporterOutput);
    TypeIdentifier.configureReporter(config.reporter, config.reporterOutput);
    configureConflictsReporter(config.reporter, config.reporterOutput);
    if (config.reporter) {
      this.reporterService.registerReporter("GenerationHandler", this.log);
    }
    switch (type) {
      case 0 /* TYPES */:
        this.generator = new TypeDefinitionGenerator(config, this.registry);
        break;
      case 1 /* HTML_DOC */:
        this.generator = new HtmlDocGenerator(config, this.registry);
        break;
      case 2 /* JSON */:
        this.generator = new JsonDefinitionGenerator(config, this.registry);
        break;
      default:
        throw new Error("Unknown Generator");
    }
  }
  async start(girModules) {
    this.log.info(START_MODULE);
    if (girModules.length === 0) {
      this.log.error(ERROR_NO_MODULE_SPECIFIED);
    }
    this.log.info(FILE_PARSING_DONE);
    this.log.info(TSDATA_PARSING_DONE);
    try {
      if (this.config.outdir) {
        await mkdir3(this.config.outdir, { recursive: true });
      }
      this.registry.transform({
        inferGenerics: true,
        verbose: this.config.verbose,
        reporter: this.config.reporter,
        reporterOutput: this.config.reporterOutput
      });
      await this.generator.start();
      for (const girModule of girModules) {
        this.log.log(` - ${girModule.packageName} ...`);
        await this.generator.generate(girModule);
      }
      await this.generator.finish(girModules);
      this.log.success(GENERATING_TYPES_DONE);
    } finally {
      if (this.config.reporter) {
        await this.generateComprehensiveReport();
      }
    }
  }
  async generateComprehensiveReport() {
    try {
      this.reporterService.printComprehensiveSummary();
      await this.reporterService.saveComprehensiveReport();
      const report = this.reporterService.generateComprehensiveReport();
      const totalProblems = report.statistics.totalProblems;
      const modulesProcessed = this.reporterService.getReporters().size;
      if (totalProblems > 0) {
        this.log.info(`\u{1F4CA} Generated comprehensive report: ${totalProblems} issues across ${modulesProcessed} modules`);
      } else {
        this.log.success("\u{1F389} Generation completed without any reported issues across all modules!");
      }
    } catch (error) {
      this.log.danger(`Failed to generate comprehensive report: ${error}`);
    }
  }
};

// src/commands/doc.ts
var command3 = "doc [modules..]";
var description3 = "The HTML documentation generator is not yet implemented, but feel free to implement it \u{1F917}";
var logger4 = new Logger(false, "DocCommand");
var builder3 = (yargs2) => {
  const optionNames = Object.keys(docOptions);
  for (const optionName of optionNames) {
    yargs2 = yargs2.option(optionName, docOptions[optionName]);
  }
  return yargs2.example(examples3);
};
var handler3 = async (args) => {
  const config = await load(args);
  const generateConfig = getOptionsGeneration(config);
  const registry = new NSRegistry();
  if (generateConfig.reporter) {
    TypeIdentifier.configureReporter(generateConfig.reporter, generateConfig.reporterOutput);
    configureConflictsReporter(generateConfig.reporter, generateConfig.reporterOutput);
  }
  const moduleLoader = new ModuleLoader(generateConfig, registry);
  const { keep } = await moduleLoader.getModulesResolved(
    config.modules,
    config.ignore || [],
    config.ignoreVersionConflicts
  );
  if (keep.length === 0) {
    logger4.error(ERROR_NO_MODULES_FOUND(config.girDirectories));
    return;
  }
  const tsForGir = new GenerationHandler(generateConfig, 1 /* HTML_DOC */, registry);
  await tsForGir.start(Array.from(keep).map((girModuleResolvedBy) => girModuleResolvedBy.module));
};
var examples3 = [];
var doc = {
  command: command3,
  description: description3,
  builder: builder3,
  handler: handler3,
  examples: examples3
};

// src/formatters/typescript-formatter.ts
import prettier from "prettier";
var logger5 = new Logger(false, "TypeScriptFormatter");
var TypeScriptFormatter = class extends Formatter {
  format(input) {
    try {
      return prettier.format(input, {
        singleQuote: true,
        parser: "typescript",
        printWidth: 120,
        tabWidth: 4
      });
    } catch (error) {
      logger5.warn("Failed to format with prettier, returning original input", error);
      return Promise.resolve(input);
    }
  }
};

// src/commands/generate.ts
var command4 = "generate [modules..]";
var description4 = "Generates Typescript type definition .d.ts files from GIR for GJS";
var logger6 = new Logger(false, "GenerateCommand");
var examples4 = [
  [
    `${APP_NAME} generate`,
    `Run '${APP_NAME} generate' in your gjs project to generate typings for your project, pass the gir modules you need for your project`
  ],
  [`${APP_NAME} generate Gtk*`, "You can also use wild cards"],
  [`${APP_NAME} generate '*'`, "If you want to parse all of your locally installed gir modules run"],
  [`${APP_NAME} generate --configName='.ts-for-gir.gtk4.rc.js`, "Use a special config file"],
  [`${APP_NAME} generate --ignore=Gtk-4.0 xrandr-1.3`, "Generate .d.ts. files but not for Gtk-4.0 and xrandr-1.3"]
];
var builder4 = createBuilder(generateOptions, examples4);
var handler4 = async (args) => {
  const config = await load(args);
  const generateConfig = getOptionsGeneration(config);
  const registry = new NSRegistry();
  registry.registerFormatter("dts", new TypeScriptFormatter());
  const moduleLoader = new ModuleLoader(generateConfig, registry);
  if (generateConfig.reporter) {
    TypeIdentifier.configureReporter(generateConfig.reporter, generateConfig.reporterOutput);
    configureConflictsReporter(generateConfig.reporter, generateConfig.reporterOutput);
  }
  let tsForGir = null;
  try {
    const { keep } = await moduleLoader.getModulesResolved(
      config.modules,
      config.ignore || [],
      config.ignoreVersionConflicts
    );
    if (keep.length === 0) {
      logger6.error(ERROR_NO_MODULES_FOUND(config.girDirectories));
      return;
    }
    moduleLoader.parse(keep);
    tsForGir = new GenerationHandler(generateConfig, 0 /* TYPES */, registry);
    const girModules = Array.from(keep).map((girModuleResolvedBy) => girModuleResolvedBy.module);
    await tsForGir.start(girModules);
  } catch (error) {
    if (generateConfig.reporter && tsForGir) {
      const service = ReporterService.getInstance();
      if (tsForGir.log) {
        tsForGir.log.reportGenerationFailure(
          "Main",
          error instanceof Error ? error : new Error(String(error)),
          "Generation failed"
        );
      }
      await service.printComprehensiveSummary();
      await service.saveComprehensiveReport();
    }
    throw error;
  }
};
var generate = {
  command: command4,
  description: description4,
  builder: builder4,
  handler: handler4,
  examples: examples4
};

// src/commands/json.ts
var command5 = "json [modules..]";
var description5 = "Generates JSON representation from GIR files for analysis and tooling";
var logger7 = new Logger(false, "JsonCommand");
var examples5 = [
  [`${APP_NAME} json`, `Run '${APP_NAME} json' in your gjs project to generate JSON files for your project`],
  [`${APP_NAME} json Gtk*`, "You can also use wild cards"],
  [`${APP_NAME} json '*'`, "If you want to parse all of your locally installed gir modules run"],
  [`${APP_NAME} json --configName='.ts-for-gir.gtk4.rc.js`, "Use a special config file"],
  [`${APP_NAME} json --ignore=Gtk-4.0 xrandr-1.3`, "Generate JSON files but not for Gtk-4.0 and xrandr-1.3"]
];
var builder5 = createBuilder(generateOptions, examples5);
var handler5 = async (args) => {
  const config = await load(args);
  const generateConfig = getOptionsGeneration(config);
  const registry = new NSRegistry();
  const moduleLoader = new ModuleLoader(generateConfig, registry);
  if (generateConfig.reporter) {
    TypeIdentifier.configureReporter(generateConfig.reporter, generateConfig.reporterOutput);
    configureConflictsReporter(generateConfig.reporter, generateConfig.reporterOutput);
  }
  let tsForGir = null;
  try {
    const { keep } = await moduleLoader.getModulesResolved(
      config.modules,
      config.ignore || [],
      config.ignoreVersionConflicts
    );
    if (keep.length === 0) {
      logger7.error(ERROR_NO_MODULES_FOUND(config.girDirectories));
      return;
    }
    moduleLoader.parse(keep);
    tsForGir = new GenerationHandler(generateConfig, 2 /* JSON */, registry);
    const girModules = Array.from(keep).map((girModuleResolvedBy) => girModuleResolvedBy.module);
    await tsForGir.start(girModules);
  } catch (error) {
    if (generateConfig.reporter && tsForGir) {
      const service = ReporterService.getInstance();
      if (tsForGir.log) {
        tsForGir.log.reportGenerationFailure(
          "Main",
          error instanceof Error ? error : new Error(String(error)),
          "JSON generation failed"
        );
      }
      await service.printComprehensiveSummary();
      await service.saveComprehensiveReport();
    }
    throw error;
  }
};
var json = {
  command: command5,
  description: description5,
  builder: builder5,
  handler: handler5,
  examples: examples5
};

// src/commands/list.ts
var command6 = "list [modules..]";
var description6 = "Lists all available GIR modules";
var logger8 = new Logger(false, "ListCommand");
var examples6 = [
  [`${APP_NAME} list -g ./vala-girs/gir-1.0`, "Lists all available GIR modules in ./vala-girs/gir-1.0"],
  [
    `${APP_NAME} list --ignore=Gtk-3.0 xrandr-1.3`,
    "Lists all available GIR modules in /usr/share/gir-1.0 but not Gtk-3.0 and xrandr-1.3"
  ]
];
var builder6 = createBuilder(listOptions, examples6);
var handler6 = async (args) => {
  const config = await load(args);
  const generateConfig = getOptionsGeneration(config);
  const registry = new NSRegistry();
  const moduleLoader = new ModuleLoader(generateConfig, registry);
  const { grouped, failed } = await moduleLoader.getModules(config.modules, config.ignore);
  const moduleGroups = Object.values(grouped);
  if (Object.keys(grouped).length === 0) {
    return logger8.error(ERROR_NO_MODULES_FOUND(config.girDirectories));
  }
  const conflictModules = moduleGroups.filter((moduleGroup) => moduleGroup.hasConflict);
  const byHandModules = moduleGroups.filter((moduleGroup) => moduleGroup.modules[0].resolvedBy === 1 /* BY_HAND */);
  const depModules = moduleGroups.filter((moduleGroup) => moduleGroup.modules[0].resolvedBy === 0 /* DEPENDENCE */);
  logger8.info("\nSearch for gir files in:");
  for (const dir of config.girDirectories) {
    logger8.white(`- ${dir}`);
  }
  logger8.info("\nSelected Modules:");
  for (const moduleGroup of byHandModules) {
    for (const depModule of moduleGroup.modules) {
      logger8.white(`- ${depModule.packageName}`);
      logger8.gray(`  - ${depModule.path}`);
    }
  }
  if (depModules.length > 0) {
    logger8.yellow("\nDependencies:");
    for (const moduleGroup of depModules) {
      for (const depModule of moduleGroup.modules) {
        logger8.white(`- ${depModule.packageName}`);
        logger8.gray(`- ${depModule.path}`);
      }
    }
  }
  if (conflictModules.length > 0) {
    logger8.danger("\nConflicts:");
    for (const moduleGroup of conflictModules) {
      logger8.white(`- ${moduleGroup.namespace}`);
      for (const conflictModule of moduleGroup.modules) {
        logger8.white(`  - ${conflictModule.packageName}`);
        logger8.gray(`  - ${conflictModule.path}`);
      }
    }
  }
  if (failed.length > 0) {
    logger8.danger("\nDependencies not found:");
    for (const fail of failed) {
      logger8.white(`- ${fail}`);
    }
  }
};
var list = {
  command: command6,
  description: description6,
  builder: builder6,
  handler: handler6,
  examples: examples6
};

// src/start.ts
void yargs(hideBin(process.argv)).scriptName(APP_NAME).strict().usage(APP_USAGE).version(APP_VERSION).command(analyze).command(generate).command(json).command(list).command(copy).command(doc).demandCommand(1).help().argv;
/*! Bundled license information:

lodash/lodash.js:
  (**
   * @license
   * Lodash <https://lodash.com/>
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)
*/
